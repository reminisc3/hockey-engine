{"ast":null,"code":"/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 3.2.0, Thu Nov 18 2021\n *\n * http://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\nconst _global = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : global;\n\nconst keys = Object.keys;\nconst isArray = Array.isArray;\n\nif (typeof Promise !== 'undefined' && !_global.Promise) {\n  _global.Promise = Promise;\n}\n\nfunction extend(obj, extension) {\n  if (typeof extension !== 'object') return obj;\n  keys(extension).forEach(function (key) {\n    obj[key] = extension[key];\n  });\n  return obj;\n}\n\nconst getProto = Object.getPrototypeOf;\nconst _hasOwn = {}.hasOwnProperty;\n\nfunction hasOwn(obj, prop) {\n  return _hasOwn.call(obj, prop);\n}\n\nfunction props(proto, extension) {\n  if (typeof extension === 'function') extension = extension(getProto(proto));\n  (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(key => {\n    setProp(proto, key, extension[key]);\n  });\n}\n\nconst defineProperty = Object.defineProperty;\n\nfunction setProp(obj, prop, functionOrGetSet, options) {\n  defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ? {\n    get: functionOrGetSet.get,\n    set: functionOrGetSet.set,\n    configurable: true\n  } : {\n    value: functionOrGetSet,\n    configurable: true,\n    writable: true\n  }, options));\n}\n\nfunction derive(Child) {\n  return {\n    from: function (Parent) {\n      Child.prototype = Object.create(Parent.prototype);\n      setProp(Child.prototype, \"constructor\", Child);\n      return {\n        extend: props.bind(null, Child.prototype)\n      };\n    }\n  };\n}\n\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\nfunction getPropertyDescriptor(obj, prop) {\n  const pd = getOwnPropertyDescriptor(obj, prop);\n  let proto;\n  return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n}\n\nconst _slice = [].slice;\n\nfunction slice(args, start, end) {\n  return _slice.call(args, start, end);\n}\n\nfunction override(origFunc, overridedFactory) {\n  return overridedFactory(origFunc);\n}\n\nfunction assert(b) {\n  if (!b) throw new Error(\"Assertion Failed\");\n}\n\nfunction asap$1(fn) {\n  if (_global.setImmediate) setImmediate(fn);else setTimeout(fn, 0);\n}\n\nfunction arrayToObject(array, extractor) {\n  return array.reduce((result, item, i) => {\n    var nameAndValue = extractor(item, i);\n    if (nameAndValue) result[nameAndValue[0]] = nameAndValue[1];\n    return result;\n  }, {});\n}\n\nfunction tryCatch(fn, onerror, args) {\n  try {\n    fn.apply(null, args);\n  } catch (ex) {\n    onerror && onerror(ex);\n  }\n}\n\nfunction getByKeyPath(obj, keyPath) {\n  if (hasOwn(obj, keyPath)) return obj[keyPath];\n  if (!keyPath) return obj;\n\n  if (typeof keyPath !== 'string') {\n    var rv = [];\n\n    for (var i = 0, l = keyPath.length; i < l; ++i) {\n      var val = getByKeyPath(obj, keyPath[i]);\n      rv.push(val);\n    }\n\n    return rv;\n  }\n\n  var period = keyPath.indexOf('.');\n\n  if (period !== -1) {\n    var innerObj = obj[keyPath.substr(0, period)];\n    return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n  }\n\n  return undefined;\n}\n\nfunction setByKeyPath(obj, keyPath, value) {\n  if (!obj || keyPath === undefined) return;\n  if ('isFrozen' in Object && Object.isFrozen(obj)) return;\n\n  if (typeof keyPath !== 'string' && 'length' in keyPath) {\n    assert(typeof value !== 'string' && 'length' in value);\n\n    for (var i = 0, l = keyPath.length; i < l; ++i) {\n      setByKeyPath(obj, keyPath[i], value[i]);\n    }\n  } else {\n    var period = keyPath.indexOf('.');\n\n    if (period !== -1) {\n      var currentKeyPath = keyPath.substr(0, period);\n      var remainingKeyPath = keyPath.substr(period + 1);\n      if (remainingKeyPath === \"\") {\n        if (value === undefined) {\n          if (isArray(obj) && !isNaN(parseInt(currentKeyPath))) obj.splice(currentKeyPath, 1);else delete obj[currentKeyPath];\n        } else obj[currentKeyPath] = value;\n      } else {\n        var innerObj = obj[currentKeyPath];\n        if (!innerObj) innerObj = obj[currentKeyPath] = {};\n        setByKeyPath(innerObj, remainingKeyPath, value);\n      }\n    } else {\n      if (value === undefined) {\n        if (isArray(obj) && !isNaN(parseInt(keyPath))) obj.splice(keyPath, 1);else delete obj[keyPath];\n      } else obj[keyPath] = value;\n    }\n  }\n}\n\nfunction delByKeyPath(obj, keyPath) {\n  if (typeof keyPath === 'string') setByKeyPath(obj, keyPath, undefined);else if ('length' in keyPath) [].map.call(keyPath, function (kp) {\n    setByKeyPath(obj, kp, undefined);\n  });\n}\n\nfunction shallowClone(obj) {\n  var rv = {};\n\n  for (var m in obj) {\n    if (hasOwn(obj, m)) rv[m] = obj[m];\n  }\n\n  return rv;\n}\n\nconst concat = [].concat;\n\nfunction flatten(a) {\n  return concat.apply([], a);\n}\n\nconst intrinsicTypeNames = \"Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\".split(',').concat(flatten([8, 16, 32, 64].map(num => [\"Int\", \"Uint\", \"Float\"].map(t => t + num + \"Array\")))).filter(t => _global[t]);\nconst intrinsicTypes = intrinsicTypeNames.map(t => _global[t]);\narrayToObject(intrinsicTypeNames, x => [x, true]);\nlet circularRefs = null;\n\nfunction deepClone(any) {\n  circularRefs = typeof WeakMap !== 'undefined' && new WeakMap();\n  const rv = innerDeepClone(any);\n  circularRefs = null;\n  return rv;\n}\n\nfunction innerDeepClone(any) {\n  if (!any || typeof any !== 'object') return any;\n  let rv = circularRefs && circularRefs.get(any);\n  if (rv) return rv;\n\n  if (isArray(any)) {\n    rv = [];\n    circularRefs && circularRefs.set(any, rv);\n\n    for (var i = 0, l = any.length; i < l; ++i) {\n      rv.push(innerDeepClone(any[i]));\n    }\n  } else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\n    rv = any;\n  } else {\n    const proto = getProto(any);\n    rv = proto === Object.prototype ? {} : Object.create(proto);\n    circularRefs && circularRefs.set(any, rv);\n\n    for (var prop in any) {\n      if (hasOwn(any, prop)) {\n        rv[prop] = innerDeepClone(any[prop]);\n      }\n    }\n  }\n\n  return rv;\n}\n\nconst {\n  toString\n} = {};\n\nfunction toStringTag(o) {\n  return toString.call(o).slice(8, -1);\n}\n\nconst iteratorSymbol = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';\nconst getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n  var i;\n  return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n} : function () {\n  return null;\n};\nconst NO_CHAR_ARRAY = {};\n\nfunction getArrayOf(arrayLike) {\n  var i, a, x, it;\n\n  if (arguments.length === 1) {\n    if (isArray(arrayLike)) return arrayLike.slice();\n    if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string') return [arrayLike];\n\n    if (it = getIteratorOf(arrayLike)) {\n      a = [];\n\n      while (x = it.next(), !x.done) a.push(x.value);\n\n      return a;\n    }\n\n    if (arrayLike == null) return [arrayLike];\n    i = arrayLike.length;\n\n    if (typeof i === 'number') {\n      a = new Array(i);\n\n      while (i--) a[i] = arrayLike[i];\n\n      return a;\n    }\n\n    return [arrayLike];\n  }\n\n  i = arguments.length;\n  a = new Array(i);\n\n  while (i--) a[i] = arguments[i];\n\n  return a;\n}\n\nconst isAsyncFunction = typeof Symbol !== 'undefined' ? fn => fn[Symbol.toStringTag] === 'AsyncFunction' : () => false;\nvar debug = typeof location !== 'undefined' && /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\n\nfunction setDebug(value, filter) {\n  debug = value;\n  libraryFilter = filter;\n}\n\nvar libraryFilter = () => true;\n\nconst NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\n\nfunction getErrorWithStack() {\n  if (NEEDS_THROW_FOR_STACK) try {\n    getErrorWithStack.arguments;\n    throw new Error();\n  } catch (e) {\n    return e;\n  }\n  return new Error();\n}\n\nfunction prettyStack(exception, numIgnoredFrames) {\n  var stack = exception.stack;\n  if (!stack) return \"\";\n  numIgnoredFrames = numIgnoredFrames || 0;\n  if (stack.indexOf(exception.name) === 0) numIgnoredFrames += (exception.name + exception.message).split('\\n').length;\n  return stack.split('\\n').slice(numIgnoredFrames).filter(libraryFilter).map(frame => \"\\n\" + frame).join('');\n}\n\nvar dexieErrorNames = ['Modify', 'Bulk', 'OpenFailed', 'VersionChange', 'Schema', 'Upgrade', 'InvalidTable', 'MissingAPI', 'NoSuchDatabase', 'InvalidArgument', 'SubTransaction', 'Unsupported', 'Internal', 'DatabaseClosed', 'PrematureCommit', 'ForeignAwait'];\nvar idbDomErrorNames = ['Unknown', 'Constraint', 'Data', 'TransactionInactive', 'ReadOnly', 'Version', 'NotFound', 'InvalidState', 'InvalidAccess', 'Abort', 'Timeout', 'QuotaExceeded', 'Syntax', 'DataClone'];\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\nvar defaultTexts = {\n  VersionChanged: \"Database version changed by other database connection\",\n  DatabaseClosed: \"Database has been closed\",\n  Abort: \"Transaction aborted\",\n  TransactionInactive: \"Transaction has already completed or failed\",\n  MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n};\n\nfunction DexieError(name, msg) {\n  this._e = getErrorWithStack();\n  this.name = name;\n  this.message = msg;\n}\n\nderive(DexieError).from(Error).extend({\n  stack: {\n    get: function () {\n      return this._stack || (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n    }\n  },\n  toString: function () {\n    return this.name + \": \" + this.message;\n  }\n});\n\nfunction getMultiErrorMessage(msg, failures) {\n  return msg + \". Errors: \" + Object.keys(failures).map(key => failures[key].toString()).filter((v, i, s) => s.indexOf(v) === i).join('\\n');\n}\n\nfunction ModifyError(msg, failures, successCount, failedKeys) {\n  this._e = getErrorWithStack();\n  this.failures = failures;\n  this.failedKeys = failedKeys;\n  this.successCount = successCount;\n  this.message = getMultiErrorMessage(msg, failures);\n}\n\nderive(ModifyError).from(DexieError);\n\nfunction BulkError(msg, failures) {\n  this._e = getErrorWithStack();\n  this.name = \"BulkError\";\n  this.failures = Object.keys(failures).map(pos => failures[pos]);\n  this.failuresByPos = failures;\n  this.message = getMultiErrorMessage(msg, failures);\n}\n\nderive(BulkError).from(DexieError);\nvar errnames = errorList.reduce((obj, name) => (obj[name] = name + \"Error\", obj), {});\nconst BaseException = DexieError;\nvar exceptions = errorList.reduce((obj, name) => {\n  var fullName = name + \"Error\";\n\n  function DexieError(msgOrInner, inner) {\n    this._e = getErrorWithStack();\n    this.name = fullName;\n\n    if (!msgOrInner) {\n      this.message = defaultTexts[name] || fullName;\n      this.inner = null;\n    } else if (typeof msgOrInner === 'string') {\n      this.message = `${msgOrInner}${!inner ? '' : '\\n ' + inner}`;\n      this.inner = inner || null;\n    } else if (typeof msgOrInner === 'object') {\n      this.message = `${msgOrInner.name} ${msgOrInner.message}`;\n      this.inner = msgOrInner;\n    }\n  }\n\n  derive(DexieError).from(BaseException);\n  obj[name] = DexieError;\n  return obj;\n}, {});\nexceptions.Syntax = SyntaxError;\nexceptions.Type = TypeError;\nexceptions.Range = RangeError;\nvar exceptionMap = idbDomErrorNames.reduce((obj, name) => {\n  obj[name + \"Error\"] = exceptions[name];\n  return obj;\n}, {});\n\nfunction mapError(domError, message) {\n  if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name]) return domError;\n  var rv = new exceptionMap[domError.name](message || domError.message, domError);\n\n  if (\"stack\" in domError) {\n    setProp(rv, \"stack\", {\n      get: function () {\n        return this.inner.stack;\n      }\n    });\n  }\n\n  return rv;\n}\n\nvar fullNameExceptions = errorList.reduce((obj, name) => {\n  if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1) obj[name + \"Error\"] = exceptions[name];\n  return obj;\n}, {});\nfullNameExceptions.ModifyError = ModifyError;\nfullNameExceptions.DexieError = DexieError;\nfullNameExceptions.BulkError = BulkError;\n\nfunction nop() {}\n\nfunction mirror(val) {\n  return val;\n}\n\nfunction pureFunctionChain(f1, f2) {\n  if (f1 == null || f1 === mirror) return f2;\n  return function (val) {\n    return f2(f1(val));\n  };\n}\n\nfunction callBoth(on1, on2) {\n  return function () {\n    on1.apply(this, arguments);\n    on2.apply(this, arguments);\n  };\n}\n\nfunction hookCreatingChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function () {\n    var res = f1.apply(this, arguments);\n    if (res !== undefined) arguments[0] = res;\n    var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n    this.onsuccess = null;\n    this.onerror = null;\n    var res2 = f2.apply(this, arguments);\n    if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n    if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    return res2 !== undefined ? res2 : res;\n  };\n}\n\nfunction hookDeletingChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function () {\n    f1.apply(this, arguments);\n    var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n    this.onsuccess = this.onerror = null;\n    f2.apply(this, arguments);\n    if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n    if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n  };\n}\n\nfunction hookUpdatingChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function (modifications) {\n    var res = f1.apply(this, arguments);\n    extend(modifications, res);\n    var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n    this.onsuccess = null;\n    this.onerror = null;\n    var res2 = f2.apply(this, arguments);\n    if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n    if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    return res === undefined ? res2 === undefined ? undefined : res2 : extend(res, res2);\n  };\n}\n\nfunction reverseStoppableEventChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function () {\n    if (f2.apply(this, arguments) === false) return false;\n    return f1.apply(this, arguments);\n  };\n}\n\nfunction promisableChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function () {\n    var res = f1.apply(this, arguments);\n\n    if (res && typeof res.then === 'function') {\n      var thiz = this,\n          i = arguments.length,\n          args = new Array(i);\n\n      while (i--) args[i] = arguments[i];\n\n      return res.then(function () {\n        return f2.apply(thiz, args);\n      });\n    }\n\n    return f2.apply(this, arguments);\n  };\n}\n\nvar INTERNAL = {};\nconst LONG_STACKS_CLIP_LIMIT = 100,\n      MAX_LONG_STACKS = 20,\n      ZONE_ECHO_LIMIT = 100,\n      [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === 'undefined' ? [] : (() => {\n  let globalP = Promise.resolve();\n  if (typeof crypto === 'undefined' || !crypto.subtle) return [globalP, getProto(globalP), globalP];\n  const nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n  return [nativeP, getProto(nativeP), globalP];\n})(),\n      nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\nconst NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\nconst patchGlobalPromise = !!resolvedGlobalPromise;\nvar stack_being_generated = false;\nvar schedulePhysicalTick = resolvedGlobalPromise ? () => {\n  resolvedGlobalPromise.then(physicalTick);\n} : _global.setImmediate ? setImmediate.bind(null, physicalTick) : _global.MutationObserver ? () => {\n  var hiddenDiv = document.createElement(\"div\");\n  new MutationObserver(() => {\n    physicalTick();\n    hiddenDiv = null;\n  }).observe(hiddenDiv, {\n    attributes: true\n  });\n  hiddenDiv.setAttribute('i', '1');\n} : () => {\n  setTimeout(physicalTick, 0);\n};\n\nvar asap = function (callback, args) {\n  microtickQueue.push([callback, args]);\n\n  if (needsNewPhysicalTick) {\n    schedulePhysicalTick();\n    needsNewPhysicalTick = false;\n  }\n};\n\nvar isOutsideMicroTick = true,\n    needsNewPhysicalTick = true,\n    unhandledErrors = [],\n    rejectingErrors = [],\n    currentFulfiller = null,\n    rejectionMapper = mirror;\nvar globalPSD = {\n  id: 'global',\n  global: true,\n  ref: 0,\n  unhandleds: [],\n  onunhandled: globalError,\n  pgp: false,\n  env: {},\n  finalize: function () {\n    this.unhandleds.forEach(uh => {\n      try {\n        globalError(uh[0], uh[1]);\n      } catch (e) {}\n    });\n  }\n};\nvar PSD = globalPSD;\nvar microtickQueue = [];\nvar numScheduledCalls = 0;\nvar tickFinalizers = [];\n\nfunction DexiePromise(fn) {\n  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');\n  this._listeners = [];\n  this.onuncatched = nop;\n  this._lib = false;\n  var psd = this._PSD = PSD;\n\n  if (debug) {\n    this._stackHolder = getErrorWithStack();\n    this._prev = null;\n    this._numPrev = 0;\n  }\n\n  if (typeof fn !== 'function') {\n    if (fn !== INTERNAL) throw new TypeError('Not a function');\n    this._state = arguments[1];\n    this._value = arguments[2];\n    if (this._state === false) handleRejection(this, this._value);\n    return;\n  }\n\n  this._state = null;\n  this._value = null;\n  ++psd.ref;\n  executePromiseTask(this, fn);\n}\n\nconst thenProp = {\n  get: function () {\n    var psd = PSD,\n        microTaskId = totalEchoes;\n\n    function then(onFulfilled, onRejected) {\n      var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n      const cleanup = possibleAwait && !decrementExpectedAwaits();\n      var rv = new DexiePromise((resolve, reject) => {\n        propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n      });\n      debug && linkToPreviousPromise(rv, this);\n      return rv;\n    }\n\n    then.prototype = INTERNAL;\n    return then;\n  },\n  set: function (value) {\n    setProp(this, 'then', value && value.prototype === INTERNAL ? thenProp : {\n      get: function () {\n        return value;\n      },\n      set: thenProp.set\n    });\n  }\n};\nprops(DexiePromise.prototype, {\n  then: thenProp,\n  _then: function (onFulfilled, onRejected) {\n    propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n  },\n  catch: function (onRejected) {\n    if (arguments.length === 1) return this.then(null, onRejected);\n    var type = arguments[0],\n        handler = arguments[1];\n    return typeof type === 'function' ? this.then(null, err => err instanceof type ? handler(err) : PromiseReject(err)) : this.then(null, err => err && err.name === type ? handler(err) : PromiseReject(err));\n  },\n  finally: function (onFinally) {\n    return this.then(value => {\n      onFinally();\n      return value;\n    }, err => {\n      onFinally();\n      return PromiseReject(err);\n    });\n  },\n  stack: {\n    get: function () {\n      if (this._stack) return this._stack;\n\n      try {\n        stack_being_generated = true;\n        var stacks = getStack(this, [], MAX_LONG_STACKS);\n        var stack = stacks.join(\"\\nFrom previous: \");\n        if (this._state !== null) this._stack = stack;\n        return stack;\n      } finally {\n        stack_being_generated = false;\n      }\n    }\n  },\n  timeout: function (ms, msg) {\n    return ms < Infinity ? new DexiePromise((resolve, reject) => {\n      var handle = setTimeout(() => reject(new exceptions.Timeout(msg)), ms);\n      this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n    }) : this;\n  }\n});\nif (typeof Symbol !== 'undefined' && Symbol.toStringTag) setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\nglobalPSD.env = snapShot();\n\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.resolve = resolve;\n  this.reject = reject;\n  this.psd = zone;\n}\n\nprops(DexiePromise, {\n  all: function () {\n    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n    return new DexiePromise(function (resolve, reject) {\n      if (values.length === 0) resolve([]);\n      var remaining = values.length;\n      values.forEach((a, i) => DexiePromise.resolve(a).then(x => {\n        values[i] = x;\n        if (! --remaining) resolve(values);\n      }, reject));\n    });\n  },\n  resolve: value => {\n    if (value instanceof DexiePromise) return value;\n    if (value && typeof value.then === 'function') return new DexiePromise((resolve, reject) => {\n      value.then(resolve, reject);\n    });\n    var rv = new DexiePromise(INTERNAL, true, value);\n    linkToPreviousPromise(rv, currentFulfiller);\n    return rv;\n  },\n  reject: PromiseReject,\n  race: function () {\n    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n    return new DexiePromise((resolve, reject) => {\n      values.map(value => DexiePromise.resolve(value).then(resolve, reject));\n    });\n  },\n  PSD: {\n    get: () => PSD,\n    set: value => PSD = value\n  },\n  totalEchoes: {\n    get: () => totalEchoes\n  },\n  newPSD: newScope,\n  usePSD: usePSD,\n  scheduler: {\n    get: () => asap,\n    set: value => {\n      asap = value;\n    }\n  },\n  rejectionMapper: {\n    get: () => rejectionMapper,\n    set: value => {\n      rejectionMapper = value;\n    }\n  },\n  follow: (fn, zoneProps) => {\n    return new DexiePromise((resolve, reject) => {\n      return newScope((resolve, reject) => {\n        var psd = PSD;\n        psd.unhandleds = [];\n        psd.onunhandled = reject;\n        psd.finalize = callBoth(function () {\n          run_at_end_of_this_or_next_physical_tick(() => {\n            this.unhandleds.length === 0 ? resolve() : reject(this.unhandleds[0]);\n          });\n        }, psd.finalize);\n        fn();\n      }, zoneProps, resolve, reject);\n    });\n  }\n});\n\nif (NativePromise) {\n  if (NativePromise.allSettled) setProp(DexiePromise, \"allSettled\", function () {\n    const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n    return new DexiePromise(resolve => {\n      if (possiblePromises.length === 0) resolve([]);\n      let remaining = possiblePromises.length;\n      const results = new Array(remaining);\n      possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => results[i] = {\n        status: \"fulfilled\",\n        value\n      }, reason => results[i] = {\n        status: \"rejected\",\n        reason\n      }).then(() => --remaining || resolve(results)));\n    });\n  });\n  if (NativePromise.any && typeof AggregateError !== 'undefined') setProp(DexiePromise, \"any\", function () {\n    const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n    return new DexiePromise((resolve, reject) => {\n      if (possiblePromises.length === 0) reject(new AggregateError([]));\n      let remaining = possiblePromises.length;\n      const failures = new Array(remaining);\n      possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => resolve(value), failure => {\n        failures[i] = failure;\n        if (! --remaining) reject(new AggregateError(failures));\n      }));\n    });\n  });\n}\n\nfunction executePromiseTask(promise, fn) {\n  try {\n    fn(value => {\n      if (promise._state !== null) return;\n      if (value === promise) throw new TypeError('A promise cannot be resolved with itself.');\n      var shouldExecuteTick = promise._lib && beginMicroTickScope();\n\n      if (value && typeof value.then === 'function') {\n        executePromiseTask(promise, (resolve, reject) => {\n          value instanceof DexiePromise ? value._then(resolve, reject) : value.then(resolve, reject);\n        });\n      } else {\n        promise._state = true;\n        promise._value = value;\n        propagateAllListeners(promise);\n      }\n\n      if (shouldExecuteTick) endMicroTickScope();\n    }, handleRejection.bind(null, promise));\n  } catch (ex) {\n    handleRejection(promise, ex);\n  }\n}\n\nfunction handleRejection(promise, reason) {\n  rejectingErrors.push(reason);\n  if (promise._state !== null) return;\n  var shouldExecuteTick = promise._lib && beginMicroTickScope();\n  reason = rejectionMapper(reason);\n  promise._state = false;\n  promise._value = reason;\n  debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(() => {\n    var origProp = getPropertyDescriptor(reason, \"stack\");\n    reason._promise = promise;\n    setProp(reason, \"stack\", {\n      get: () => stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack\n    });\n  });\n  addPossiblyUnhandledError(promise);\n  propagateAllListeners(promise);\n  if (shouldExecuteTick) endMicroTickScope();\n}\n\nfunction propagateAllListeners(promise) {\n  var listeners = promise._listeners;\n  promise._listeners = [];\n\n  for (var i = 0, len = listeners.length; i < len; ++i) {\n    propagateToListener(promise, listeners[i]);\n  }\n\n  var psd = promise._PSD;\n  --psd.ref || psd.finalize();\n\n  if (numScheduledCalls === 0) {\n    ++numScheduledCalls;\n    asap(() => {\n      if (--numScheduledCalls === 0) finalizePhysicalTick();\n    }, []);\n  }\n}\n\nfunction propagateToListener(promise, listener) {\n  if (promise._state === null) {\n    promise._listeners.push(listener);\n\n    return;\n  }\n\n  var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n\n  if (cb === null) {\n    return (promise._state ? listener.resolve : listener.reject)(promise._value);\n  }\n\n  ++listener.psd.ref;\n  ++numScheduledCalls;\n  asap(callListener, [cb, promise, listener]);\n}\n\nfunction callListener(cb, promise, listener) {\n  try {\n    currentFulfiller = promise;\n    var ret,\n        value = promise._value;\n\n    if (promise._state) {\n      ret = cb(value);\n    } else {\n      if (rejectingErrors.length) rejectingErrors = [];\n      ret = cb(value);\n      if (rejectingErrors.indexOf(value) === -1) markErrorAsHandled(promise);\n    }\n\n    listener.resolve(ret);\n  } catch (e) {\n    listener.reject(e);\n  } finally {\n    currentFulfiller = null;\n    if (--numScheduledCalls === 0) finalizePhysicalTick();\n    --listener.psd.ref || listener.psd.finalize();\n  }\n}\n\nfunction getStack(promise, stacks, limit) {\n  if (stacks.length === limit) return stacks;\n  var stack = \"\";\n\n  if (promise._state === false) {\n    var failure = promise._value,\n        errorName,\n        message;\n\n    if (failure != null) {\n      errorName = failure.name || \"Error\";\n      message = failure.message || failure;\n      stack = prettyStack(failure, 0);\n    } else {\n      errorName = failure;\n      message = \"\";\n    }\n\n    stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n  }\n\n  if (debug) {\n    stack = prettyStack(promise._stackHolder, 2);\n    if (stack && stacks.indexOf(stack) === -1) stacks.push(stack);\n    if (promise._prev) getStack(promise._prev, stacks, limit);\n  }\n\n  return stacks;\n}\n\nfunction linkToPreviousPromise(promise, prev) {\n  var numPrev = prev ? prev._numPrev + 1 : 0;\n\n  if (numPrev < LONG_STACKS_CLIP_LIMIT) {\n    promise._prev = prev;\n    promise._numPrev = numPrev;\n  }\n}\n\nfunction physicalTick() {\n  beginMicroTickScope() && endMicroTickScope();\n}\n\nfunction beginMicroTickScope() {\n  var wasRootExec = isOutsideMicroTick;\n  isOutsideMicroTick = false;\n  needsNewPhysicalTick = false;\n  return wasRootExec;\n}\n\nfunction endMicroTickScope() {\n  var callbacks, i, l;\n\n  do {\n    while (microtickQueue.length > 0) {\n      callbacks = microtickQueue;\n      microtickQueue = [];\n      l = callbacks.length;\n\n      for (i = 0; i < l; ++i) {\n        var item = callbacks[i];\n        item[0].apply(null, item[1]);\n      }\n    }\n  } while (microtickQueue.length > 0);\n\n  isOutsideMicroTick = true;\n  needsNewPhysicalTick = true;\n}\n\nfunction finalizePhysicalTick() {\n  var unhandledErrs = unhandledErrors;\n  unhandledErrors = [];\n  unhandledErrs.forEach(p => {\n    p._PSD.onunhandled.call(null, p._value, p);\n  });\n  var finalizers = tickFinalizers.slice(0);\n  var i = finalizers.length;\n\n  while (i) finalizers[--i]();\n}\n\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\n  function finalizer() {\n    fn();\n    tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n  }\n\n  tickFinalizers.push(finalizer);\n  ++numScheduledCalls;\n  asap(() => {\n    if (--numScheduledCalls === 0) finalizePhysicalTick();\n  }, []);\n}\n\nfunction addPossiblyUnhandledError(promise) {\n  if (!unhandledErrors.some(p => p._value === promise._value)) unhandledErrors.push(promise);\n}\n\nfunction markErrorAsHandled(promise) {\n  var i = unhandledErrors.length;\n\n  while (i) if (unhandledErrors[--i]._value === promise._value) {\n    unhandledErrors.splice(i, 1);\n    return;\n  }\n}\n\nfunction PromiseReject(reason) {\n  return new DexiePromise(INTERNAL, false, reason);\n}\n\nfunction wrap(fn, errorCatcher) {\n  var psd = PSD;\n  return function () {\n    var wasRootExec = beginMicroTickScope(),\n        outerScope = PSD;\n\n    try {\n      switchToZone(psd, true);\n      return fn.apply(this, arguments);\n    } catch (e) {\n      errorCatcher && errorCatcher(e);\n    } finally {\n      switchToZone(outerScope, false);\n      if (wasRootExec) endMicroTickScope();\n    }\n  };\n}\n\nconst task = {\n  awaits: 0,\n  echoes: 0,\n  id: 0\n};\nvar taskCounter = 0;\nvar zoneStack = [];\nvar zoneEchoes = 0;\nvar totalEchoes = 0;\nvar zone_id_counter = 0;\n\nfunction newScope(fn, props, a1, a2) {\n  var parent = PSD,\n      psd = Object.create(parent);\n  psd.parent = parent;\n  psd.ref = 0;\n  psd.global = false;\n  psd.id = ++zone_id_counter;\n  var globalEnv = globalPSD.env;\n  psd.env = patchGlobalPromise ? {\n    Promise: DexiePromise,\n    PromiseProp: {\n      value: DexiePromise,\n      configurable: true,\n      writable: true\n    },\n    all: DexiePromise.all,\n    race: DexiePromise.race,\n    allSettled: DexiePromise.allSettled,\n    any: DexiePromise.any,\n    resolve: DexiePromise.resolve,\n    reject: DexiePromise.reject,\n    nthen: getPatchedPromiseThen(globalEnv.nthen, psd),\n    gthen: getPatchedPromiseThen(globalEnv.gthen, psd)\n  } : {};\n  if (props) extend(psd, props);\n  ++parent.ref;\n\n  psd.finalize = function () {\n    --this.parent.ref || this.parent.finalize();\n  };\n\n  var rv = usePSD(psd, fn, a1, a2);\n  if (psd.ref === 0) psd.finalize();\n  return rv;\n}\n\nfunction incrementExpectedAwaits() {\n  if (!task.id) task.id = ++taskCounter;\n  ++task.awaits;\n  task.echoes += ZONE_ECHO_LIMIT;\n  return task.id;\n}\n\nfunction decrementExpectedAwaits() {\n  if (!task.awaits) return false;\n  if (--task.awaits === 0) task.id = 0;\n  task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n  return true;\n}\n\nif (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n  incrementExpectedAwaits = decrementExpectedAwaits = nop;\n}\n\nfunction onPossibleParallellAsync(possiblePromise) {\n  if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n    incrementExpectedAwaits();\n    return possiblePromise.then(x => {\n      decrementExpectedAwaits();\n      return x;\n    }, e => {\n      decrementExpectedAwaits();\n      return rejection(e);\n    });\n  }\n\n  return possiblePromise;\n}\n\nfunction zoneEnterEcho(targetZone) {\n  ++totalEchoes;\n\n  if (!task.echoes || --task.echoes === 0) {\n    task.echoes = task.id = 0;\n  }\n\n  zoneStack.push(PSD);\n  switchToZone(targetZone, true);\n}\n\nfunction zoneLeaveEcho() {\n  var zone = zoneStack[zoneStack.length - 1];\n  zoneStack.pop();\n  switchToZone(zone, false);\n}\n\nfunction switchToZone(targetZone, bEnteringZone) {\n  var currentZone = PSD;\n\n  if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (! --zoneEchoes || targetZone !== PSD)) {\n    enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n  }\n\n  if (targetZone === PSD) return;\n  PSD = targetZone;\n  if (currentZone === globalPSD) globalPSD.env = snapShot();\n\n  if (patchGlobalPromise) {\n    var GlobalPromise = globalPSD.env.Promise;\n    var targetEnv = targetZone.env;\n    nativePromiseProto.then = targetEnv.nthen;\n    GlobalPromise.prototype.then = targetEnv.gthen;\n\n    if (currentZone.global || targetZone.global) {\n      Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n      GlobalPromise.all = targetEnv.all;\n      GlobalPromise.race = targetEnv.race;\n      GlobalPromise.resolve = targetEnv.resolve;\n      GlobalPromise.reject = targetEnv.reject;\n      if (targetEnv.allSettled) GlobalPromise.allSettled = targetEnv.allSettled;\n      if (targetEnv.any) GlobalPromise.any = targetEnv.any;\n    }\n  }\n}\n\nfunction snapShot() {\n  var GlobalPromise = _global.Promise;\n  return patchGlobalPromise ? {\n    Promise: GlobalPromise,\n    PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n    all: GlobalPromise.all,\n    race: GlobalPromise.race,\n    allSettled: GlobalPromise.allSettled,\n    any: GlobalPromise.any,\n    resolve: GlobalPromise.resolve,\n    reject: GlobalPromise.reject,\n    nthen: nativePromiseProto.then,\n    gthen: GlobalPromise.prototype.then\n  } : {};\n}\n\nfunction usePSD(psd, fn, a1, a2, a3) {\n  var outerScope = PSD;\n\n  try {\n    switchToZone(psd, true);\n    return fn(a1, a2, a3);\n  } finally {\n    switchToZone(outerScope, false);\n  }\n}\n\nfunction enqueueNativeMicroTask(job) {\n  nativePromiseThen.call(resolvedNativePromise, job);\n}\n\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n  return typeof fn !== 'function' ? fn : function () {\n    var outerZone = PSD;\n    if (possibleAwait) incrementExpectedAwaits();\n    switchToZone(zone, true);\n\n    try {\n      return fn.apply(this, arguments);\n    } finally {\n      switchToZone(outerZone, false);\n      if (cleanup) enqueueNativeMicroTask(decrementExpectedAwaits);\n    }\n  };\n}\n\nfunction getPatchedPromiseThen(origThen, zone) {\n  return function (onResolved, onRejected) {\n    return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));\n  };\n}\n\nconst UNHANDLEDREJECTION = \"unhandledrejection\";\n\nfunction globalError(err, promise) {\n  var rv;\n\n  try {\n    rv = promise.onuncatched(err);\n  } catch (e) {}\n\n  if (rv !== false) try {\n    var event,\n        eventData = {\n      promise: promise,\n      reason: err\n    };\n\n    if (_global.document && document.createEvent) {\n      event = document.createEvent('Event');\n      event.initEvent(UNHANDLEDREJECTION, true, true);\n      extend(event, eventData);\n    } else if (_global.CustomEvent) {\n      event = new CustomEvent(UNHANDLEDREJECTION, {\n        detail: eventData\n      });\n      extend(event, eventData);\n    }\n\n    if (event && _global.dispatchEvent) {\n      dispatchEvent(event);\n      if (!_global.PromiseRejectionEvent && _global.onunhandledrejection) try {\n        _global.onunhandledrejection(event);\n      } catch (_) {}\n    }\n\n    if (debug && event && !event.defaultPrevented) {\n      console.warn(`Unhandled rejection: ${err.stack || err}`);\n    }\n  } catch (e) {}\n}\n\nvar rejection = DexiePromise.reject;\n\nfunction tempTransaction(db, mode, storeNames, fn) {\n  if (!db.idbdb || !db._state.openComplete && !PSD.letThrough && !db._vip) {\n    if (db._state.openComplete) {\n      return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n    }\n\n    if (!db._state.isBeingOpened) {\n      if (!db._options.autoOpen) return rejection(new exceptions.DatabaseClosed());\n      db.open().catch(nop);\n    }\n\n    return db._state.dbReadyPromise.then(() => tempTransaction(db, mode, storeNames, fn));\n  } else {\n    var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n\n    try {\n      trans.create();\n    } catch (ex) {\n      return rejection(ex);\n    }\n\n    return trans._promise(mode, (resolve, reject) => {\n      return newScope(() => {\n        PSD.trans = trans;\n        return fn(resolve, reject, trans);\n      });\n    }).then(result => {\n      return trans._completion.then(() => result);\n    });\n  }\n}\n\nconst DEXIE_VERSION = '3.2.0';\nconst maxString = String.fromCharCode(65535);\nconst minKey = -Infinity;\nconst INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\nconst STRING_EXPECTED = \"String expected.\";\nconst connections = [];\nconst isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\nconst hasIEDeleteObjectStoreBug = isIEOrEdge;\nconst hangsOnDeleteLargeKeyRange = isIEOrEdge;\n\nconst dexieStackFrameFilter = frame => !/(dexie\\.js|dexie\\.min\\.js)/.test(frame);\n\nconst DBNAMES_DB = '__dbnames';\nconst READONLY = 'readonly';\nconst READWRITE = 'readwrite';\n\nfunction combine(filter1, filter2) {\n  return filter1 ? filter2 ? function () {\n    return filter1.apply(this, arguments) && filter2.apply(this, arguments);\n  } : filter1 : filter2;\n}\n\nconst AnyRange = {\n  type: 3,\n  lower: -Infinity,\n  lowerOpen: false,\n  upper: [[]],\n  upperOpen: false\n};\n\nfunction workaroundForUndefinedPrimKey(keyPath) {\n  return typeof keyPath === \"string\" && !/\\./.test(keyPath) ? obj => {\n    if (obj[keyPath] === undefined && keyPath in obj) {\n      obj = deepClone(obj);\n      delete obj[keyPath];\n    }\n\n    return obj;\n  } : obj => obj;\n}\n\nclass Table {\n  _trans(mode, fn, writeLocked) {\n    const trans = this._tx || PSD.trans;\n    const tableName = this.name;\n\n    function checkTableInTransaction(resolve, reject, trans) {\n      if (!trans.schema[tableName]) throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n      return fn(trans.idbtrans, trans);\n    }\n\n    const wasRootExec = beginMicroTickScope();\n\n    try {\n      return trans && trans.db === this.db ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), {\n        trans: trans,\n        transless: PSD.transless || PSD\n      }) : tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n    } finally {\n      if (wasRootExec) endMicroTickScope();\n    }\n  }\n\n  get(keyOrCrit, cb) {\n    if (keyOrCrit && keyOrCrit.constructor === Object) return this.where(keyOrCrit).first(cb);\n    return this._trans('readonly', trans => {\n      return this.core.get({\n        trans,\n        key: keyOrCrit\n      }).then(res => this.hook.reading.fire(res));\n    }).then(cb);\n  }\n\n  where(indexOrCrit) {\n    if (typeof indexOrCrit === 'string') return new this.db.WhereClause(this, indexOrCrit);\n    if (isArray(indexOrCrit)) return new this.db.WhereClause(this, `[${indexOrCrit.join('+')}]`);\n    const keyPaths = keys(indexOrCrit);\n    if (keyPaths.length === 1) return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);\n    const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(ix => ix.compound && keyPaths.every(keyPath => ix.keyPath.indexOf(keyPath) >= 0) && ix.keyPath.every(keyPath => keyPaths.indexOf(keyPath) >= 0))[0];\n    if (compoundIndex && this.db._maxKey !== maxString) return this.where(compoundIndex.name).equals(compoundIndex.keyPath.map(kp => indexOrCrit[kp]));\n    if (!compoundIndex && debug) console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a ` + `compound index [${keyPaths.join('+')}]`);\n    const {\n      idxByName\n    } = this.schema;\n    const idb = this.db._deps.indexedDB;\n\n    function equals(a, b) {\n      try {\n        return idb.cmp(a, b) === 0;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath) => {\n      const index = idxByName[keyPath];\n      const value = indexOrCrit[keyPath];\n      return [prevIndex || index, prevIndex || !index ? combine(prevFilterFn, index && index.multi ? x => {\n        const prop = getByKeyPath(x, keyPath);\n        return isArray(prop) && prop.some(item => equals(value, item));\n      } : x => equals(value, getByKeyPath(x, keyPath))) : prevFilterFn];\n    }, [null, null]);\n    return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals('');\n  }\n\n  filter(filterFunction) {\n    return this.toCollection().and(filterFunction);\n  }\n\n  count(thenShortcut) {\n    return this.toCollection().count(thenShortcut);\n  }\n\n  offset(offset) {\n    return this.toCollection().offset(offset);\n  }\n\n  limit(numRows) {\n    return this.toCollection().limit(numRows);\n  }\n\n  each(callback) {\n    return this.toCollection().each(callback);\n  }\n\n  toArray(thenShortcut) {\n    return this.toCollection().toArray(thenShortcut);\n  }\n\n  toCollection() {\n    return new this.db.Collection(new this.db.WhereClause(this));\n  }\n\n  orderBy(index) {\n    return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ? `[${index.join('+')}]` : index));\n  }\n\n  reverse() {\n    return this.toCollection().reverse();\n  }\n\n  mapToClass(constructor) {\n    this.schema.mappedClass = constructor;\n\n    const readHook = obj => {\n      if (!obj) return obj;\n      const res = Object.create(constructor.prototype);\n\n      for (var m in obj) if (hasOwn(obj, m)) try {\n        res[m] = obj[m];\n      } catch (_) {}\n\n      return res;\n    };\n\n    if (this.schema.readHook) {\n      this.hook.reading.unsubscribe(this.schema.readHook);\n    }\n\n    this.schema.readHook = readHook;\n    this.hook(\"reading\", readHook);\n    return constructor;\n  }\n\n  defineClass() {\n    function Class(content) {\n      extend(this, content);\n    }\n\n    return this.mapToClass(Class);\n  }\n\n  add(obj, key) {\n    const {\n      auto,\n      keyPath\n    } = this.schema.primKey;\n    let objToAdd = obj;\n\n    if (keyPath && auto) {\n      objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n    }\n\n    return this._trans('readwrite', trans => {\n      return this.core.mutate({\n        trans,\n        type: 'add',\n        keys: key != null ? [key] : null,\n        values: [objToAdd]\n      });\n    }).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then(lastResult => {\n      if (keyPath) {\n        try {\n          setByKeyPath(obj, keyPath, lastResult);\n        } catch (_) {}\n      }\n\n      return lastResult;\n    });\n  }\n\n  update(keyOrObject, modifications) {\n    if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n      const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n      if (key === undefined) return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n\n      try {\n        if (typeof modifications !== \"function\") {\n          keys(modifications).forEach(keyPath => {\n            setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n          });\n        } else {\n          modifications(keyOrObject, {\n            value: keyOrObject,\n            primKey: key\n          });\n        }\n      } catch (_a) {}\n\n      return this.where(\":id\").equals(key).modify(modifications);\n    } else {\n      return this.where(\":id\").equals(keyOrObject).modify(modifications);\n    }\n  }\n\n  put(obj, key) {\n    const {\n      auto,\n      keyPath\n    } = this.schema.primKey;\n    let objToAdd = obj;\n\n    if (keyPath && auto) {\n      objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n    }\n\n    return this._trans('readwrite', trans => this.core.mutate({\n      trans,\n      type: 'put',\n      values: [objToAdd],\n      keys: key != null ? [key] : null\n    })).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then(lastResult => {\n      if (keyPath) {\n        try {\n          setByKeyPath(obj, keyPath, lastResult);\n        } catch (_) {}\n      }\n\n      return lastResult;\n    });\n  }\n\n  delete(key) {\n    return this._trans('readwrite', trans => this.core.mutate({\n      trans,\n      type: 'delete',\n      keys: [key]\n    })).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n  }\n\n  clear() {\n    return this._trans('readwrite', trans => this.core.mutate({\n      trans,\n      type: 'deleteRange',\n      range: AnyRange\n    })).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n  }\n\n  bulkGet(keys) {\n    return this._trans('readonly', trans => {\n      return this.core.getMany({\n        keys,\n        trans\n      }).then(result => result.map(res => this.hook.reading.fire(res)));\n    });\n  }\n\n  bulkAdd(objects, keysOrOptions, options) {\n    const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n    options = options || (keys ? undefined : keysOrOptions);\n    const wantResults = options ? options.allKeys : undefined;\n    return this._trans('readwrite', trans => {\n      const {\n        auto,\n        keyPath\n      } = this.schema.primKey;\n      if (keyPath && keys) throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n      if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n      const numObjects = objects.length;\n      let objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;\n      return this.core.mutate({\n        trans,\n        type: 'add',\n        keys: keys,\n        values: objectsToAdd,\n        wantResults\n      }).then(({\n        numFailures,\n        results,\n        lastResult,\n        failures\n      }) => {\n        const result = wantResults ? results : lastResult;\n        if (numFailures === 0) return result;\n        throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);\n      });\n    });\n  }\n\n  bulkPut(objects, keysOrOptions, options) {\n    const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n    options = options || (keys ? undefined : keysOrOptions);\n    const wantResults = options ? options.allKeys : undefined;\n    return this._trans('readwrite', trans => {\n      const {\n        auto,\n        keyPath\n      } = this.schema.primKey;\n      if (keyPath && keys) throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n      if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n      const numObjects = objects.length;\n      let objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;\n      return this.core.mutate({\n        trans,\n        type: 'put',\n        keys: keys,\n        values: objectsToPut,\n        wantResults\n      }).then(({\n        numFailures,\n        results,\n        lastResult,\n        failures\n      }) => {\n        const result = wantResults ? results : lastResult;\n        if (numFailures === 0) return result;\n        throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);\n      });\n    });\n  }\n\n  bulkDelete(keys) {\n    const numKeys = keys.length;\n    return this._trans('readwrite', trans => {\n      return this.core.mutate({\n        trans,\n        type: 'delete',\n        keys: keys\n      });\n    }).then(({\n      numFailures,\n      lastResult,\n      failures\n    }) => {\n      if (numFailures === 0) return lastResult;\n      throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);\n    });\n  }\n\n}\n\nfunction Events(ctx) {\n  var evs = {};\n\n  var rv = function (eventName, subscriber) {\n    if (subscriber) {\n      var i = arguments.length,\n          args = new Array(i - 1);\n\n      while (--i) args[i - 1] = arguments[i];\n\n      evs[eventName].subscribe.apply(null, args);\n      return ctx;\n    } else if (typeof eventName === 'string') {\n      return evs[eventName];\n    }\n  };\n\n  rv.addEventType = add;\n\n  for (var i = 1, l = arguments.length; i < l; ++i) {\n    add(arguments[i]);\n  }\n\n  return rv;\n\n  function add(eventName, chainFunction, defaultFunction) {\n    if (typeof eventName === 'object') return addConfiguredEvents(eventName);\n    if (!chainFunction) chainFunction = reverseStoppableEventChain;\n    if (!defaultFunction) defaultFunction = nop;\n    var context = {\n      subscribers: [],\n      fire: defaultFunction,\n      subscribe: function (cb) {\n        if (context.subscribers.indexOf(cb) === -1) {\n          context.subscribers.push(cb);\n          context.fire = chainFunction(context.fire, cb);\n        }\n      },\n      unsubscribe: function (cb) {\n        context.subscribers = context.subscribers.filter(function (fn) {\n          return fn !== cb;\n        });\n        context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n      }\n    };\n    evs[eventName] = rv[eventName] = context;\n    return context;\n  }\n\n  function addConfiguredEvents(cfg) {\n    keys(cfg).forEach(function (eventName) {\n      var args = cfg[eventName];\n\n      if (isArray(args)) {\n        add(eventName, cfg[eventName][0], cfg[eventName][1]);\n      } else if (args === 'asap') {\n        var context = add(eventName, mirror, function fire() {\n          var i = arguments.length,\n              args = new Array(i);\n\n          while (i--) args[i] = arguments[i];\n\n          context.subscribers.forEach(function (fn) {\n            asap$1(function fireEvent() {\n              fn.apply(null, args);\n            });\n          });\n        });\n      } else throw new exceptions.InvalidArgument(\"Invalid event config\");\n    });\n  }\n}\n\nfunction makeClassConstructor(prototype, constructor) {\n  derive(constructor).from({\n    prototype\n  });\n  return constructor;\n}\n\nfunction createTableConstructor(db) {\n  return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n    this.db = db;\n    this._tx = trans;\n    this.name = name;\n    this.schema = tableSchema;\n    this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n      \"creating\": [hookCreatingChain, nop],\n      \"reading\": [pureFunctionChain, mirror],\n      \"updating\": [hookUpdatingChain, nop],\n      \"deleting\": [hookDeletingChain, nop]\n    });\n  });\n}\n\nfunction isPlainKeyRange(ctx, ignoreLimitFilter) {\n  return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n}\n\nfunction addFilter(ctx, fn) {\n  ctx.filter = combine(ctx.filter, fn);\n}\n\nfunction addReplayFilter(ctx, factory, isLimitFilter) {\n  var curr = ctx.replayFilter;\n  ctx.replayFilter = curr ? () => combine(curr(), factory()) : factory;\n  ctx.justLimit = isLimitFilter && !curr;\n}\n\nfunction addMatchFilter(ctx, fn) {\n  ctx.isMatch = combine(ctx.isMatch, fn);\n}\n\nfunction getIndexOrStore(ctx, coreSchema) {\n  if (ctx.isPrimKey) return coreSchema.primaryKey;\n  const index = coreSchema.getIndexByKeyPath(ctx.index);\n  if (!index) throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n  return index;\n}\n\nfunction openCursor(ctx, coreTable, trans) {\n  const index = getIndexOrStore(ctx, coreTable.schema);\n  return coreTable.openCursor({\n    trans,\n    values: !ctx.keysOnly,\n    reverse: ctx.dir === 'prev',\n    unique: !!ctx.unique,\n    query: {\n      index,\n      range: ctx.range\n    }\n  });\n}\n\nfunction iter(ctx, fn, coreTrans, coreTable) {\n  const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n\n  if (!ctx.or) {\n    return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n  } else {\n    const set = {};\n\n    const union = (item, cursor, advance) => {\n      if (!filter || filter(cursor, advance, result => cursor.stop(result), err => cursor.fail(err))) {\n        var primaryKey = cursor.primaryKey;\n        var key = '' + primaryKey;\n        if (key === '[object ArrayBuffer]') key = '' + new Uint8Array(primaryKey);\n\n        if (!hasOwn(set, key)) {\n          set[key] = true;\n          fn(item, cursor, advance);\n        }\n      }\n    };\n\n    return Promise.all([ctx.or._iterate(union, coreTrans), iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)]);\n  }\n}\n\nfunction iterate(cursorPromise, filter, fn, valueMapper) {\n  var mappedFn = valueMapper ? (x, c, a) => fn(valueMapper(x), c, a) : fn;\n  var wrappedFn = wrap(mappedFn);\n  return cursorPromise.then(cursor => {\n    if (cursor) {\n      return cursor.start(() => {\n        var c = () => cursor.continue();\n\n        if (!filter || filter(cursor, advancer => c = advancer, val => {\n          cursor.stop(val);\n          c = nop;\n        }, e => {\n          cursor.fail(e);\n          c = nop;\n        })) wrappedFn(cursor.value, cursor, advancer => c = advancer);\n        c();\n      });\n    }\n  });\n}\n\nfunction cmp(a, b) {\n  try {\n    const ta = type(a);\n    const tb = type(b);\n\n    if (ta !== tb) {\n      if (ta === 'Array') return 1;\n      if (tb === 'Array') return -1;\n      if (ta === 'binary') return 1;\n      if (tb === 'binary') return -1;\n      if (ta === 'string') return 1;\n      if (tb === 'string') return -1;\n      if (ta === 'Date') return 1;\n      if (tb !== 'Date') return NaN;\n      return -1;\n    }\n\n    switch (ta) {\n      case 'number':\n      case 'Date':\n      case 'string':\n        return a > b ? 1 : a < b ? -1 : 0;\n\n      case 'binary':\n        {\n          return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n        }\n\n      case 'Array':\n        return compareArrays(a, b);\n    }\n  } catch (_a) {}\n\n  return NaN;\n}\n\nfunction compareArrays(a, b) {\n  const al = a.length;\n  const bl = b.length;\n  const l = al < bl ? al : bl;\n\n  for (let i = 0; i < l; ++i) {\n    const res = cmp(a[i], b[i]);\n    if (res !== 0) return res;\n  }\n\n  return al === bl ? 0 : al < bl ? -1 : 1;\n}\n\nfunction compareUint8Arrays(a, b) {\n  const al = a.length;\n  const bl = b.length;\n  const l = al < bl ? al : bl;\n\n  for (let i = 0; i < l; ++i) {\n    if (a[i] !== b[i]) return a[i] < b[i] ? -1 : 1;\n  }\n\n  return al === bl ? 0 : al < bl ? -1 : 1;\n}\n\nfunction type(x) {\n  const t = typeof x;\n  if (t !== 'object') return t;\n  if (ArrayBuffer.isView(x)) return 'binary';\n  const tsTag = toStringTag(x);\n  return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n}\n\nfunction getUint8Array(a) {\n  if (a instanceof Uint8Array) return a;\n  if (ArrayBuffer.isView(a)) return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n  return new Uint8Array(a);\n}\n\nclass Collection {\n  _read(fn, cb) {\n    var ctx = this._ctx;\n    return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans('readonly', fn).then(cb);\n  }\n\n  _write(fn) {\n    var ctx = this._ctx;\n    return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans('readwrite', fn, \"locked\");\n  }\n\n  _addAlgorithm(fn) {\n    var ctx = this._ctx;\n    ctx.algorithm = combine(ctx.algorithm, fn);\n  }\n\n  _iterate(fn, coreTrans) {\n    return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n  }\n\n  clone(props) {\n    var rv = Object.create(this.constructor.prototype),\n        ctx = Object.create(this._ctx);\n    if (props) extend(ctx, props);\n    rv._ctx = ctx;\n    return rv;\n  }\n\n  raw() {\n    this._ctx.valueMapper = null;\n    return this;\n  }\n\n  each(fn) {\n    var ctx = this._ctx;\n    return this._read(trans => iter(ctx, fn, trans, ctx.table.core));\n  }\n\n  count(cb) {\n    return this._read(trans => {\n      const ctx = this._ctx;\n      const coreTable = ctx.table.core;\n\n      if (isPlainKeyRange(ctx, true)) {\n        return coreTable.count({\n          trans,\n          query: {\n            index: getIndexOrStore(ctx, coreTable.schema),\n            range: ctx.range\n          }\n        }).then(count => Math.min(count, ctx.limit));\n      } else {\n        var count = 0;\n        return iter(ctx, () => {\n          ++count;\n          return false;\n        }, trans, coreTable).then(() => count);\n      }\n    }).then(cb);\n  }\n\n  sortBy(keyPath, cb) {\n    const parts = keyPath.split('.').reverse(),\n          lastPart = parts[0],\n          lastIndex = parts.length - 1;\n\n    function getval(obj, i) {\n      if (i) return getval(obj[parts[i]], i - 1);\n      return obj[lastPart];\n    }\n\n    var order = this._ctx.dir === \"next\" ? 1 : -1;\n\n    function sorter(a, b) {\n      var aVal = getval(a, lastIndex),\n          bVal = getval(b, lastIndex);\n      return aVal < bVal ? -order : aVal > bVal ? order : 0;\n    }\n\n    return this.toArray(function (a) {\n      return a.sort(sorter);\n    }).then(cb);\n  }\n\n  toArray(cb) {\n    return this._read(trans => {\n      var ctx = this._ctx;\n\n      if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n        const {\n          valueMapper\n        } = ctx;\n        const index = getIndexOrStore(ctx, ctx.table.core.schema);\n        return ctx.table.core.query({\n          trans,\n          limit: ctx.limit,\n          values: true,\n          query: {\n            index,\n            range: ctx.range\n          }\n        }).then(({\n          result\n        }) => valueMapper ? result.map(valueMapper) : result);\n      } else {\n        const a = [];\n        return iter(ctx, item => a.push(item), trans, ctx.table.core).then(() => a);\n      }\n    }, cb);\n  }\n\n  offset(offset) {\n    var ctx = this._ctx;\n    if (offset <= 0) return this;\n    ctx.offset += offset;\n\n    if (isPlainKeyRange(ctx)) {\n      addReplayFilter(ctx, () => {\n        var offsetLeft = offset;\n        return (cursor, advance) => {\n          if (offsetLeft === 0) return true;\n\n          if (offsetLeft === 1) {\n            --offsetLeft;\n            return false;\n          }\n\n          advance(() => {\n            cursor.advance(offsetLeft);\n            offsetLeft = 0;\n          });\n          return false;\n        };\n      });\n    } else {\n      addReplayFilter(ctx, () => {\n        var offsetLeft = offset;\n        return () => --offsetLeft < 0;\n      });\n    }\n\n    return this;\n  }\n\n  limit(numRows) {\n    this._ctx.limit = Math.min(this._ctx.limit, numRows);\n    addReplayFilter(this._ctx, () => {\n      var rowsLeft = numRows;\n      return function (cursor, advance, resolve) {\n        if (--rowsLeft <= 0) advance(resolve);\n        return rowsLeft >= 0;\n      };\n    }, true);\n    return this;\n  }\n\n  until(filterFunction, bIncludeStopEntry) {\n    addFilter(this._ctx, function (cursor, advance, resolve) {\n      if (filterFunction(cursor.value)) {\n        advance(resolve);\n        return bIncludeStopEntry;\n      } else {\n        return true;\n      }\n    });\n    return this;\n  }\n\n  first(cb) {\n    return this.limit(1).toArray(function (a) {\n      return a[0];\n    }).then(cb);\n  }\n\n  last(cb) {\n    return this.reverse().first(cb);\n  }\n\n  filter(filterFunction) {\n    addFilter(this._ctx, function (cursor) {\n      return filterFunction(cursor.value);\n    });\n    addMatchFilter(this._ctx, filterFunction);\n    return this;\n  }\n\n  and(filter) {\n    return this.filter(filter);\n  }\n\n  or(indexName) {\n    return new this.db.WhereClause(this._ctx.table, indexName, this);\n  }\n\n  reverse() {\n    this._ctx.dir = this._ctx.dir === \"prev\" ? \"next\" : \"prev\";\n    if (this._ondirectionchange) this._ondirectionchange(this._ctx.dir);\n    return this;\n  }\n\n  desc() {\n    return this.reverse();\n  }\n\n  eachKey(cb) {\n    var ctx = this._ctx;\n    ctx.keysOnly = !ctx.isMatch;\n    return this.each(function (val, cursor) {\n      cb(cursor.key, cursor);\n    });\n  }\n\n  eachUniqueKey(cb) {\n    this._ctx.unique = \"unique\";\n    return this.eachKey(cb);\n  }\n\n  eachPrimaryKey(cb) {\n    var ctx = this._ctx;\n    ctx.keysOnly = !ctx.isMatch;\n    return this.each(function (val, cursor) {\n      cb(cursor.primaryKey, cursor);\n    });\n  }\n\n  keys(cb) {\n    var ctx = this._ctx;\n    ctx.keysOnly = !ctx.isMatch;\n    var a = [];\n    return this.each(function (item, cursor) {\n      a.push(cursor.key);\n    }).then(function () {\n      return a;\n    }).then(cb);\n  }\n\n  primaryKeys(cb) {\n    var ctx = this._ctx;\n\n    if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n      return this._read(trans => {\n        var index = getIndexOrStore(ctx, ctx.table.core.schema);\n        return ctx.table.core.query({\n          trans,\n          values: false,\n          limit: ctx.limit,\n          query: {\n            index,\n            range: ctx.range\n          }\n        });\n      }).then(({\n        result\n      }) => result).then(cb);\n    }\n\n    ctx.keysOnly = !ctx.isMatch;\n    var a = [];\n    return this.each(function (item, cursor) {\n      a.push(cursor.primaryKey);\n    }).then(function () {\n      return a;\n    }).then(cb);\n  }\n\n  uniqueKeys(cb) {\n    this._ctx.unique = \"unique\";\n    return this.keys(cb);\n  }\n\n  firstKey(cb) {\n    return this.limit(1).keys(function (a) {\n      return a[0];\n    }).then(cb);\n  }\n\n  lastKey(cb) {\n    return this.reverse().firstKey(cb);\n  }\n\n  distinct() {\n    var ctx = this._ctx,\n        idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n    if (!idx || !idx.multi) return this;\n    var set = {};\n    addFilter(this._ctx, function (cursor) {\n      var strKey = cursor.primaryKey.toString();\n      var found = hasOwn(set, strKey);\n      set[strKey] = true;\n      return !found;\n    });\n    return this;\n  }\n\n  modify(changes) {\n    var ctx = this._ctx;\n    return this._write(trans => {\n      var modifyer;\n\n      if (typeof changes === 'function') {\n        modifyer = changes;\n      } else {\n        var keyPaths = keys(changes);\n        var numKeys = keyPaths.length;\n\n        modifyer = function (item) {\n          var anythingModified = false;\n\n          for (var i = 0; i < numKeys; ++i) {\n            var keyPath = keyPaths[i],\n                val = changes[keyPath];\n\n            if (getByKeyPath(item, keyPath) !== val) {\n              setByKeyPath(item, keyPath, val);\n              anythingModified = true;\n            }\n          }\n\n          return anythingModified;\n        };\n      }\n\n      const coreTable = ctx.table.core;\n      const {\n        outbound,\n        extractKey\n      } = coreTable.schema.primaryKey;\n      const limit = this.db._options.modifyChunkSize || 200;\n      const totalFailures = [];\n      let successCount = 0;\n      const failedKeys = [];\n\n      const applyMutateResult = (expectedCount, res) => {\n        const {\n          failures,\n          numFailures\n        } = res;\n        successCount += expectedCount - numFailures;\n\n        for (let pos of keys(failures)) {\n          totalFailures.push(failures[pos]);\n        }\n      };\n\n      return this.clone().primaryKeys().then(keys => {\n        const nextChunk = offset => {\n          const count = Math.min(limit, keys.length - offset);\n          return coreTable.getMany({\n            trans,\n            keys: keys.slice(offset, offset + count),\n            cache: \"immutable\"\n          }).then(values => {\n            const addValues = [];\n            const putValues = [];\n            const putKeys = outbound ? [] : null;\n            const deleteKeys = [];\n\n            for (let i = 0; i < count; ++i) {\n              const origValue = values[i];\n              const ctx = {\n                value: deepClone(origValue),\n                primKey: keys[offset + i]\n              };\n\n              if (modifyer.call(ctx, ctx.value, ctx) !== false) {\n                if (ctx.value == null) {\n                  deleteKeys.push(keys[offset + i]);\n                } else if (!outbound && cmp(extractKey(origValue), extractKey(ctx.value)) !== 0) {\n                  deleteKeys.push(keys[offset + i]);\n                  addValues.push(ctx.value);\n                } else {\n                  putValues.push(ctx.value);\n                  if (outbound) putKeys.push(keys[offset + i]);\n                }\n              }\n            }\n\n            const criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== 'function' || changes === deleteCallback) && {\n              index: ctx.index,\n              range: ctx.range\n            };\n            return Promise.resolve(addValues.length > 0 && coreTable.mutate({\n              trans,\n              type: 'add',\n              values: addValues\n            }).then(res => {\n              for (let pos in res.failures) {\n                deleteKeys.splice(parseInt(pos), 1);\n              }\n\n              applyMutateResult(addValues.length, res);\n            })).then(() => (putValues.length > 0 || criteria && typeof changes === 'object') && coreTable.mutate({\n              trans,\n              type: 'put',\n              keys: putKeys,\n              values: putValues,\n              criteria,\n              changeSpec: typeof changes !== 'function' && changes\n            }).then(res => applyMutateResult(putValues.length, res))).then(() => (deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({\n              trans,\n              type: 'delete',\n              keys: deleteKeys,\n              criteria\n            }).then(res => applyMutateResult(deleteKeys.length, res))).then(() => {\n              return keys.length > offset + count && nextChunk(offset + limit);\n            });\n          });\n        };\n\n        return nextChunk(0).then(() => {\n          if (totalFailures.length > 0) throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n          return keys.length;\n        });\n      });\n    });\n  }\n\n  delete() {\n    var ctx = this._ctx,\n        range = ctx.range;\n\n    if (isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || range.type === 3)) {\n      return this._write(trans => {\n        const {\n          primaryKey\n        } = ctx.table.core.schema;\n        const coreRange = range;\n        return ctx.table.core.count({\n          trans,\n          query: {\n            index: primaryKey,\n            range: coreRange\n          }\n        }).then(count => {\n          return ctx.table.core.mutate({\n            trans,\n            type: 'deleteRange',\n            range: coreRange\n          }).then(({\n            failures,\n            lastResult,\n            results,\n            numFailures\n          }) => {\n            if (numFailures) throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(pos => failures[pos]), count - numFailures);\n            return count - numFailures;\n          });\n        });\n      });\n    }\n\n    return this.modify(deleteCallback);\n  }\n\n}\n\nconst deleteCallback = (value, ctx) => ctx.value = null;\n\nfunction createCollectionConstructor(db) {\n  return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n    this.db = db;\n    let keyRange = AnyRange,\n        error = null;\n    if (keyRangeGenerator) try {\n      keyRange = keyRangeGenerator();\n    } catch (ex) {\n      error = ex;\n    }\n    const whereCtx = whereClause._ctx;\n    const table = whereCtx.table;\n    const readingHook = table.hook.reading.fire;\n    this._ctx = {\n      table: table,\n      index: whereCtx.index,\n      isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,\n      range: keyRange,\n      keysOnly: false,\n      dir: \"next\",\n      unique: \"\",\n      algorithm: null,\n      filter: null,\n      replayFilter: null,\n      justLimit: true,\n      isMatch: null,\n      offset: 0,\n      limit: Infinity,\n      error: error,\n      or: whereCtx.or,\n      valueMapper: readingHook !== mirror ? readingHook : null\n    };\n  });\n}\n\nfunction simpleCompare(a, b) {\n  return a < b ? -1 : a === b ? 0 : 1;\n}\n\nfunction simpleCompareReverse(a, b) {\n  return a > b ? -1 : a === b ? 0 : 1;\n}\n\nfunction fail(collectionOrWhereClause, err, T) {\n  var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;\n  collection._ctx.error = T ? new T(err) : new TypeError(err);\n  return collection;\n}\n\nfunction emptyCollection(whereClause) {\n  return new whereClause.Collection(whereClause, () => rangeEqual(\"\")).limit(0);\n}\n\nfunction upperFactory(dir) {\n  return dir === \"next\" ? s => s.toUpperCase() : s => s.toLowerCase();\n}\n\nfunction lowerFactory(dir) {\n  return dir === \"next\" ? s => s.toLowerCase() : s => s.toUpperCase();\n}\n\nfunction nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n  var length = Math.min(key.length, lowerNeedle.length);\n  var llp = -1;\n\n  for (var i = 0; i < length; ++i) {\n    var lwrKeyChar = lowerKey[i];\n\n    if (lwrKeyChar !== lowerNeedle[i]) {\n      if (cmp(key[i], upperNeedle[i]) < 0) return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n      if (cmp(key[i], lowerNeedle[i]) < 0) return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n      if (llp >= 0) return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n      return null;\n    }\n\n    if (cmp(key[i], lwrKeyChar) < 0) llp = i;\n  }\n\n  if (length < lowerNeedle.length && dir === \"next\") return key + upperNeedle.substr(key.length);\n  if (length < key.length && dir === \"prev\") return key.substr(0, upperNeedle.length);\n  return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);\n}\n\nfunction addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n  var upper,\n      lower,\n      compare,\n      upperNeedles,\n      lowerNeedles,\n      direction,\n      nextKeySuffix,\n      needlesLen = needles.length;\n\n  if (!needles.every(s => typeof s === 'string')) {\n    return fail(whereClause, STRING_EXPECTED);\n  }\n\n  function initDirection(dir) {\n    upper = upperFactory(dir);\n    lower = lowerFactory(dir);\n    compare = dir === \"next\" ? simpleCompare : simpleCompareReverse;\n    var needleBounds = needles.map(function (needle) {\n      return {\n        lower: lower(needle),\n        upper: upper(needle)\n      };\n    }).sort(function (a, b) {\n      return compare(a.lower, b.lower);\n    });\n    upperNeedles = needleBounds.map(function (nb) {\n      return nb.upper;\n    });\n    lowerNeedles = needleBounds.map(function (nb) {\n      return nb.lower;\n    });\n    direction = dir;\n    nextKeySuffix = dir === \"next\" ? \"\" : suffix;\n  }\n\n  initDirection(\"next\");\n  var c = new whereClause.Collection(whereClause, () => createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));\n\n  c._ondirectionchange = function (direction) {\n    initDirection(direction);\n  };\n\n  var firstPossibleNeedle = 0;\n\n  c._addAlgorithm(function (cursor, advance, resolve) {\n    var key = cursor.key;\n    if (typeof key !== 'string') return false;\n    var lowerKey = lower(key);\n\n    if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n      return true;\n    } else {\n      var lowestPossibleCasing = null;\n\n      for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n        var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n        if (casing === null && lowestPossibleCasing === null) firstPossibleNeedle = i + 1;else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n          lowestPossibleCasing = casing;\n        }\n      }\n\n      if (lowestPossibleCasing !== null) {\n        advance(function () {\n          cursor.continue(lowestPossibleCasing + nextKeySuffix);\n        });\n      } else {\n        advance(resolve);\n      }\n\n      return false;\n    }\n  });\n\n  return c;\n}\n\nfunction createRange(lower, upper, lowerOpen, upperOpen) {\n  return {\n    type: 2,\n    lower,\n    upper,\n    lowerOpen,\n    upperOpen\n  };\n}\n\nfunction rangeEqual(value) {\n  return {\n    type: 1,\n    lower: value,\n    upper: value\n  };\n}\n\nclass WhereClause {\n  get Collection() {\n    return this._ctx.table.db.Collection;\n  }\n\n  between(lower, upper, includeLower, includeUpper) {\n    includeLower = includeLower !== false;\n    includeUpper = includeUpper === true;\n\n    try {\n      if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)) return emptyCollection(this);\n      return new this.Collection(this, () => createRange(lower, upper, !includeLower, !includeUpper));\n    } catch (e) {\n      return fail(this, INVALID_KEY_ARGUMENT);\n    }\n  }\n\n  equals(value) {\n    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n    return new this.Collection(this, () => rangeEqual(value));\n  }\n\n  above(value) {\n    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n    return new this.Collection(this, () => createRange(value, undefined, true));\n  }\n\n  aboveOrEqual(value) {\n    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n    return new this.Collection(this, () => createRange(value, undefined, false));\n  }\n\n  below(value) {\n    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n    return new this.Collection(this, () => createRange(undefined, value, false, true));\n  }\n\n  belowOrEqual(value) {\n    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n    return new this.Collection(this, () => createRange(undefined, value));\n  }\n\n  startsWith(str) {\n    if (typeof str !== 'string') return fail(this, STRING_EXPECTED);\n    return this.between(str, str + maxString, true, true);\n  }\n\n  startsWithIgnoreCase(str) {\n    if (str === \"\") return this.startsWith(str);\n    return addIgnoreCaseAlgorithm(this, (x, a) => x.indexOf(a[0]) === 0, [str], maxString);\n  }\n\n  equalsIgnoreCase(str) {\n    return addIgnoreCaseAlgorithm(this, (x, a) => x === a[0], [str], \"\");\n  }\n\n  anyOfIgnoreCase() {\n    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n    if (set.length === 0) return emptyCollection(this);\n    return addIgnoreCaseAlgorithm(this, (x, a) => a.indexOf(x) !== -1, set, \"\");\n  }\n\n  startsWithAnyOfIgnoreCase() {\n    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n    if (set.length === 0) return emptyCollection(this);\n    return addIgnoreCaseAlgorithm(this, (x, a) => a.some(n => x.indexOf(n) === 0), set, maxString);\n  }\n\n  anyOf() {\n    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n    let compare = this._cmp;\n\n    try {\n      set.sort(compare);\n    } catch (e) {\n      return fail(this, INVALID_KEY_ARGUMENT);\n    }\n\n    if (set.length === 0) return emptyCollection(this);\n    const c = new this.Collection(this, () => createRange(set[0], set[set.length - 1]));\n\n    c._ondirectionchange = direction => {\n      compare = direction === \"next\" ? this._ascending : this._descending;\n      set.sort(compare);\n    };\n\n    let i = 0;\n\n    c._addAlgorithm((cursor, advance, resolve) => {\n      const key = cursor.key;\n\n      while (compare(key, set[i]) > 0) {\n        ++i;\n\n        if (i === set.length) {\n          advance(resolve);\n          return false;\n        }\n      }\n\n      if (compare(key, set[i]) === 0) {\n        return true;\n      } else {\n        advance(() => {\n          cursor.continue(set[i]);\n        });\n        return false;\n      }\n    });\n\n    return c;\n  }\n\n  notEqual(value) {\n    return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], {\n      includeLowers: false,\n      includeUppers: false\n    });\n  }\n\n  noneOf() {\n    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n    if (set.length === 0) return new this.Collection(this);\n\n    try {\n      set.sort(this._ascending);\n    } catch (e) {\n      return fail(this, INVALID_KEY_ARGUMENT);\n    }\n\n    const ranges = set.reduce((res, val) => res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]], null);\n    ranges.push([set[set.length - 1], this.db._maxKey]);\n    return this.inAnyRange(ranges, {\n      includeLowers: false,\n      includeUppers: false\n    });\n  }\n\n  inAnyRange(ranges, options) {\n    const cmp = this._cmp,\n          ascending = this._ascending,\n          descending = this._descending,\n          min = this._min,\n          max = this._max;\n    if (ranges.length === 0) return emptyCollection(this);\n\n    if (!ranges.every(range => range[0] !== undefined && range[1] !== undefined && ascending(range[0], range[1]) <= 0)) {\n      return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n    }\n\n    const includeLowers = !options || options.includeLowers !== false;\n    const includeUppers = options && options.includeUppers === true;\n\n    function addRange(ranges, newRange) {\n      let i = 0,\n          l = ranges.length;\n\n      for (; i < l; ++i) {\n        const range = ranges[i];\n\n        if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n          range[0] = min(range[0], newRange[0]);\n          range[1] = max(range[1], newRange[1]);\n          break;\n        }\n      }\n\n      if (i === l) ranges.push(newRange);\n      return ranges;\n    }\n\n    let sortDirection = ascending;\n\n    function rangeSorter(a, b) {\n      return sortDirection(a[0], b[0]);\n    }\n\n    let set;\n\n    try {\n      set = ranges.reduce(addRange, []);\n      set.sort(rangeSorter);\n    } catch (ex) {\n      return fail(this, INVALID_KEY_ARGUMENT);\n    }\n\n    let rangePos = 0;\n    const keyIsBeyondCurrentEntry = includeUppers ? key => ascending(key, set[rangePos][1]) > 0 : key => ascending(key, set[rangePos][1]) >= 0;\n    const keyIsBeforeCurrentEntry = includeLowers ? key => descending(key, set[rangePos][0]) > 0 : key => descending(key, set[rangePos][0]) >= 0;\n\n    function keyWithinCurrentRange(key) {\n      return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n    }\n\n    let checkKey = keyIsBeyondCurrentEntry;\n    const c = new this.Collection(this, () => createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));\n\n    c._ondirectionchange = direction => {\n      if (direction === \"next\") {\n        checkKey = keyIsBeyondCurrentEntry;\n        sortDirection = ascending;\n      } else {\n        checkKey = keyIsBeforeCurrentEntry;\n        sortDirection = descending;\n      }\n\n      set.sort(rangeSorter);\n    };\n\n    c._addAlgorithm((cursor, advance, resolve) => {\n      var key = cursor.key;\n\n      while (checkKey(key)) {\n        ++rangePos;\n\n        if (rangePos === set.length) {\n          advance(resolve);\n          return false;\n        }\n      }\n\n      if (keyWithinCurrentRange(key)) {\n        return true;\n      } else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {\n        return false;\n      } else {\n        advance(() => {\n          if (sortDirection === ascending) cursor.continue(set[rangePos][0]);else cursor.continue(set[rangePos][1]);\n        });\n        return false;\n      }\n    });\n\n    return c;\n  }\n\n  startsWithAnyOf() {\n    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n\n    if (!set.every(s => typeof s === 'string')) {\n      return fail(this, \"startsWithAnyOf() only works with strings\");\n    }\n\n    if (set.length === 0) return emptyCollection(this);\n    return this.inAnyRange(set.map(str => [str, str + maxString]));\n  }\n\n}\n\nfunction createWhereClauseConstructor(db) {\n  return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n    this.db = db;\n    this._ctx = {\n      table: table,\n      index: index === \":id\" ? null : index,\n      or: orCollection\n    };\n    const indexedDB = db._deps.indexedDB;\n    if (!indexedDB) throw new exceptions.MissingAPI();\n    this._cmp = this._ascending = indexedDB.cmp.bind(indexedDB);\n\n    this._descending = (a, b) => indexedDB.cmp(b, a);\n\n    this._max = (a, b) => indexedDB.cmp(a, b) > 0 ? a : b;\n\n    this._min = (a, b) => indexedDB.cmp(a, b) < 0 ? a : b;\n\n    this._IDBKeyRange = db._deps.IDBKeyRange;\n  });\n}\n\nfunction eventRejectHandler(reject) {\n  return wrap(function (event) {\n    preventDefault(event);\n    reject(event.target.error);\n    return false;\n  });\n}\n\nfunction preventDefault(event) {\n  if (event.stopPropagation) event.stopPropagation();\n  if (event.preventDefault) event.preventDefault();\n}\n\nconst DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\nconst STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\nconst globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n\nclass Transaction {\n  _lock() {\n    assert(!PSD.global);\n    ++this._reculock;\n    if (this._reculock === 1 && !PSD.global) PSD.lockOwnerFor = this;\n    return this;\n  }\n\n  _unlock() {\n    assert(!PSD.global);\n\n    if (--this._reculock === 0) {\n      if (!PSD.global) PSD.lockOwnerFor = null;\n\n      while (this._blockedFuncs.length > 0 && !this._locked()) {\n        var fnAndPSD = this._blockedFuncs.shift();\n\n        try {\n          usePSD(fnAndPSD[1], fnAndPSD[0]);\n        } catch (e) {}\n      }\n    }\n\n    return this;\n  }\n\n  _locked() {\n    return this._reculock && PSD.lockOwnerFor !== this;\n  }\n\n  create(idbtrans) {\n    if (!this.mode) return this;\n    const idbdb = this.db.idbdb;\n    const dbOpenError = this.db._state.dbOpenError;\n    assert(!this.idbtrans);\n\n    if (!idbtrans && !idbdb) {\n      switch (dbOpenError && dbOpenError.name) {\n        case \"DatabaseClosedError\":\n          throw new exceptions.DatabaseClosed(dbOpenError);\n\n        case \"MissingAPIError\":\n          throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n\n        default:\n          throw new exceptions.OpenFailed(dbOpenError);\n      }\n    }\n\n    if (!this.active) throw new exceptions.TransactionInactive();\n    assert(this._completion._state === null);\n    idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, {\n      durability: this.chromeTransactionDurability\n    }) : idbdb.transaction(this.storeNames, this.mode, {\n      durability: this.chromeTransactionDurability\n    }));\n    idbtrans.onerror = wrap(ev => {\n      preventDefault(ev);\n\n      this._reject(idbtrans.error);\n    });\n    idbtrans.onabort = wrap(ev => {\n      preventDefault(ev);\n      this.active && this._reject(new exceptions.Abort(idbtrans.error));\n      this.active = false;\n      this.on(\"abort\").fire(ev);\n    });\n    idbtrans.oncomplete = wrap(() => {\n      this.active = false;\n\n      this._resolve();\n\n      if ('mutatedParts' in idbtrans) {\n        globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n      }\n    });\n    return this;\n  }\n\n  _promise(mode, fn, bWriteLock) {\n    if (mode === 'readwrite' && this.mode !== 'readwrite') return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n    if (!this.active) return rejection(new exceptions.TransactionInactive());\n\n    if (this._locked()) {\n      return new DexiePromise((resolve, reject) => {\n        this._blockedFuncs.push([() => {\n          this._promise(mode, fn, bWriteLock).then(resolve, reject);\n        }, PSD]);\n      });\n    } else if (bWriteLock) {\n      return newScope(() => {\n        var p = new DexiePromise((resolve, reject) => {\n          this._lock();\n\n          const rv = fn(resolve, reject, this);\n          if (rv && rv.then) rv.then(resolve, reject);\n        });\n        p.finally(() => this._unlock());\n        p._lib = true;\n        return p;\n      });\n    } else {\n      var p = new DexiePromise((resolve, reject) => {\n        var rv = fn(resolve, reject, this);\n        if (rv && rv.then) rv.then(resolve, reject);\n      });\n      p._lib = true;\n      return p;\n    }\n  }\n\n  _root() {\n    return this.parent ? this.parent._root() : this;\n  }\n\n  waitFor(promiseLike) {\n    var root = this._root();\n\n    const promise = DexiePromise.resolve(promiseLike);\n\n    if (root._waitingFor) {\n      root._waitingFor = root._waitingFor.then(() => promise);\n    } else {\n      root._waitingFor = promise;\n      root._waitingQueue = [];\n      var store = root.idbtrans.objectStore(root.storeNames[0]);\n\n      (function spin() {\n        ++root._spinCount;\n\n        while (root._waitingQueue.length) root._waitingQueue.shift()();\n\n        if (root._waitingFor) store.get(-Infinity).onsuccess = spin;\n      })();\n    }\n\n    var currentWaitPromise = root._waitingFor;\n    return new DexiePromise((resolve, reject) => {\n      promise.then(res => root._waitingQueue.push(wrap(resolve.bind(null, res))), err => root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(() => {\n        if (root._waitingFor === currentWaitPromise) {\n          root._waitingFor = null;\n        }\n      });\n    });\n  }\n\n  abort() {\n    if (this.active) {\n      this.active = false;\n      if (this.idbtrans) this.idbtrans.abort();\n\n      this._reject(new exceptions.Abort());\n    }\n  }\n\n  table(tableName) {\n    const memoizedTables = this._memoizedTables || (this._memoizedTables = {});\n    if (hasOwn(memoizedTables, tableName)) return memoizedTables[tableName];\n    const tableSchema = this.schema[tableName];\n\n    if (!tableSchema) {\n      throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n    }\n\n    const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n    transactionBoundTable.core = this.db.core.table(tableName);\n    memoizedTables[tableName] = transactionBoundTable;\n    return transactionBoundTable;\n  }\n\n}\n\nfunction createTransactionConstructor(db) {\n  return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n    this.db = db;\n    this.mode = mode;\n    this.storeNames = storeNames;\n    this.schema = dbschema;\n    this.chromeTransactionDurability = chromeTransactionDurability;\n    this.idbtrans = null;\n    this.on = Events(this, \"complete\", \"error\", \"abort\");\n    this.parent = parent || null;\n    this.active = true;\n    this._reculock = 0;\n    this._blockedFuncs = [];\n    this._resolve = null;\n    this._reject = null;\n    this._waitingFor = null;\n    this._waitingQueue = null;\n    this._spinCount = 0;\n    this._completion = new DexiePromise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n\n    this._completion.then(() => {\n      this.active = false;\n      this.on.complete.fire();\n    }, e => {\n      var wasActive = this.active;\n      this.active = false;\n      this.on.error.fire(e);\n      this.parent ? this.parent._reject(e) : wasActive && this.idbtrans && this.idbtrans.abort();\n      return rejection(e);\n    });\n  });\n}\n\nfunction createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n  return {\n    name,\n    keyPath,\n    unique,\n    multi,\n    auto,\n    compound,\n    src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n  };\n}\n\nfunction nameFromKeyPath(keyPath) {\n  return typeof keyPath === 'string' ? keyPath : keyPath ? '[' + [].join.call(keyPath, '+') + ']' : \"\";\n}\n\nfunction createTableSchema(name, primKey, indexes) {\n  return {\n    name,\n    primKey,\n    indexes,\n    mappedClass: null,\n    idxByName: arrayToObject(indexes, index => [index.name, index])\n  };\n}\n\nfunction safariMultiStoreFix(storeNames) {\n  return storeNames.length === 1 ? storeNames[0] : storeNames;\n}\n\nlet getMaxKey = IdbKeyRange => {\n  try {\n    IdbKeyRange.only([[]]);\n\n    getMaxKey = () => [[]];\n\n    return [[]];\n  } catch (e) {\n    getMaxKey = () => maxString;\n\n    return maxString;\n  }\n};\n\nfunction getKeyExtractor(keyPath) {\n  if (keyPath == null) {\n    return () => undefined;\n  } else if (typeof keyPath === 'string') {\n    return getSinglePathKeyExtractor(keyPath);\n  } else {\n    return obj => getByKeyPath(obj, keyPath);\n  }\n}\n\nfunction getSinglePathKeyExtractor(keyPath) {\n  const split = keyPath.split('.');\n\n  if (split.length === 1) {\n    return obj => obj[keyPath];\n  } else {\n    return obj => getByKeyPath(obj, keyPath);\n  }\n}\n\nfunction arrayify(arrayLike) {\n  return [].slice.call(arrayLike);\n}\n\nlet _id_counter = 0;\n\nfunction getKeyPathAlias(keyPath) {\n  return keyPath == null ? \":id\" : typeof keyPath === 'string' ? keyPath : `[${keyPath.join('+')}]`;\n}\n\nfunction createDBCore(db, IdbKeyRange, tmpTrans) {\n  function extractSchema(db, trans) {\n    const tables = arrayify(db.objectStoreNames);\n    return {\n      schema: {\n        name: db.name,\n        tables: tables.map(table => trans.objectStore(table)).map(store => {\n          const {\n            keyPath,\n            autoIncrement\n          } = store;\n          const compound = isArray(keyPath);\n          const outbound = keyPath == null;\n          const indexByKeyPath = {};\n          const result = {\n            name: store.name,\n            primaryKey: {\n              name: null,\n              isPrimaryKey: true,\n              outbound,\n              compound,\n              keyPath,\n              autoIncrement,\n              unique: true,\n              extractKey: getKeyExtractor(keyPath)\n            },\n            indexes: arrayify(store.indexNames).map(indexName => store.index(indexName)).map(index => {\n              const {\n                name,\n                unique,\n                multiEntry,\n                keyPath\n              } = index;\n              const compound = isArray(keyPath);\n              const result = {\n                name,\n                compound,\n                keyPath,\n                unique,\n                multiEntry,\n                extractKey: getKeyExtractor(keyPath)\n              };\n              indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n              return result;\n            }),\n            getIndexByKeyPath: keyPath => indexByKeyPath[getKeyPathAlias(keyPath)]\n          };\n          indexByKeyPath[\":id\"] = result.primaryKey;\n\n          if (keyPath != null) {\n            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n          }\n\n          return result;\n        })\n      },\n      hasGetAll: tables.length > 0 && 'getAll' in trans.objectStore(tables[0]) && !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n    };\n  }\n\n  function makeIDBKeyRange(range) {\n    if (range.type === 3) return null;\n    if (range.type === 4) throw new Error(\"Cannot convert never type to IDBKeyRange\");\n    const {\n      lower,\n      upper,\n      lowerOpen,\n      upperOpen\n    } = range;\n    const idbRange = lower === undefined ? upper === undefined ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === undefined ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n    return idbRange;\n  }\n\n  function createDbCoreTable(tableSchema) {\n    const tableName = tableSchema.name;\n\n    function mutate({\n      trans,\n      type,\n      keys,\n      values,\n      range\n    }) {\n      return new Promise((resolve, reject) => {\n        resolve = wrap(resolve);\n        const store = trans.objectStore(tableName);\n        const outbound = store.keyPath == null;\n        const isAddOrPut = type === \"put\" || type === \"add\";\n        if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange') throw new Error(\"Invalid operation type: \" + type);\n        const {\n          length\n        } = keys || values || {\n          length: 1\n        };\n\n        if (keys && values && keys.length !== values.length) {\n          throw new Error(\"Given keys array must have same length as given values array.\");\n        }\n\n        if (length === 0) return resolve({\n          numFailures: 0,\n          failures: {},\n          results: [],\n          lastResult: undefined\n        });\n        let req;\n        const reqs = [];\n        const failures = [];\n        let numFailures = 0;\n\n        const errorHandler = event => {\n          ++numFailures;\n          preventDefault(event);\n        };\n\n        if (type === 'deleteRange') {\n          if (range.type === 4) return resolve({\n            numFailures,\n            failures,\n            results: [],\n            lastResult: undefined\n          });\n          if (range.type === 3) reqs.push(req = store.clear());else reqs.push(req = store.delete(makeIDBKeyRange(range)));\n        } else {\n          const [args1, args2] = isAddOrPut ? outbound ? [values, keys] : [values, null] : [keys, null];\n\n          if (isAddOrPut) {\n            for (let i = 0; i < length; ++i) {\n              reqs.push(req = args2 && args2[i] !== undefined ? store[type](args1[i], args2[i]) : store[type](args1[i]));\n              req.onerror = errorHandler;\n            }\n          } else {\n            for (let i = 0; i < length; ++i) {\n              reqs.push(req = store[type](args1[i]));\n              req.onerror = errorHandler;\n            }\n          }\n        }\n\n        const done = event => {\n          const lastResult = event.target.result;\n          reqs.forEach((req, i) => req.error != null && (failures[i] = req.error));\n          resolve({\n            numFailures,\n            failures,\n            results: type === \"delete\" ? keys : reqs.map(req => req.result),\n            lastResult\n          });\n        };\n\n        req.onerror = event => {\n          errorHandler(event);\n          done(event);\n        };\n\n        req.onsuccess = done;\n      });\n    }\n\n    function openCursor({\n      trans,\n      values,\n      query,\n      reverse,\n      unique\n    }) {\n      return new Promise((resolve, reject) => {\n        resolve = wrap(resolve);\n        const {\n          index,\n          range\n        } = query;\n        const store = trans.objectStore(tableName);\n        const source = index.isPrimaryKey ? store : store.index(index.name);\n        const direction = reverse ? unique ? \"prevunique\" : \"prev\" : unique ? \"nextunique\" : \"next\";\n        const req = values || !('openKeyCursor' in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);\n        req.onerror = eventRejectHandler(reject);\n        req.onsuccess = wrap(ev => {\n          const cursor = req.result;\n\n          if (!cursor) {\n            resolve(null);\n            return;\n          }\n\n          cursor.___id = ++_id_counter;\n          cursor.done = false;\n\n          const _cursorContinue = cursor.continue.bind(cursor);\n\n          let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n          if (_cursorContinuePrimaryKey) _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n\n          const _cursorAdvance = cursor.advance.bind(cursor);\n\n          const doThrowCursorIsNotStarted = () => {\n            throw new Error(\"Cursor not started\");\n          };\n\n          const doThrowCursorIsStopped = () => {\n            throw new Error(\"Cursor not stopped\");\n          };\n\n          cursor.trans = trans;\n          cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n          cursor.fail = wrap(reject);\n\n          cursor.next = function () {\n            let gotOne = 1;\n            return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);\n          };\n\n          cursor.start = callback => {\n            const iterationPromise = new Promise((resolveIteration, rejectIteration) => {\n              resolveIteration = wrap(resolveIteration);\n              req.onerror = eventRejectHandler(rejectIteration);\n              cursor.fail = rejectIteration;\n\n              cursor.stop = value => {\n                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                resolveIteration(value);\n              };\n            });\n\n            const guardedCallback = () => {\n              if (req.result) {\n                try {\n                  callback();\n                } catch (err) {\n                  cursor.fail(err);\n                }\n              } else {\n                cursor.done = true;\n\n                cursor.start = () => {\n                  throw new Error(\"Cursor behind last entry\");\n                };\n\n                cursor.stop();\n              }\n            };\n\n            req.onsuccess = wrap(ev => {\n              req.onsuccess = guardedCallback;\n              guardedCallback();\n            });\n            cursor.continue = _cursorContinue;\n            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n            cursor.advance = _cursorAdvance;\n            guardedCallback();\n            return iterationPromise;\n          };\n\n          resolve(cursor);\n        }, reject);\n      });\n    }\n\n    function query(hasGetAll) {\n      return request => {\n        return new Promise((resolve, reject) => {\n          resolve = wrap(resolve);\n          const {\n            trans,\n            values,\n            limit,\n            query\n          } = request;\n          const nonInfinitLimit = limit === Infinity ? undefined : limit;\n          const {\n            index,\n            range\n          } = query;\n          const store = trans.objectStore(tableName);\n          const source = index.isPrimaryKey ? store : store.index(index.name);\n          const idbKeyRange = makeIDBKeyRange(range);\n          if (limit === 0) return resolve({\n            result: []\n          });\n\n          if (hasGetAll) {\n            const req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);\n\n            req.onsuccess = event => resolve({\n              result: event.target.result\n            });\n\n            req.onerror = eventRejectHandler(reject);\n          } else {\n            let count = 0;\n            const req = values || !('openKeyCursor' in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);\n            const result = [];\n\n            req.onsuccess = event => {\n              const cursor = req.result;\n              if (!cursor) return resolve({\n                result\n              });\n              result.push(values ? cursor.value : cursor.primaryKey);\n              if (++count === limit) return resolve({\n                result\n              });\n              cursor.continue();\n            };\n\n            req.onerror = eventRejectHandler(reject);\n          }\n        });\n      };\n    }\n\n    return {\n      name: tableName,\n      schema: tableSchema,\n      mutate,\n\n      getMany({\n        trans,\n        keys\n      }) {\n        return new Promise((resolve, reject) => {\n          resolve = wrap(resolve);\n          const store = trans.objectStore(tableName);\n          const length = keys.length;\n          const result = new Array(length);\n          let keyCount = 0;\n          let callbackCount = 0;\n          let req;\n\n          const successHandler = event => {\n            const req = event.target;\n            if ((result[req._pos] = req.result) != null) ;\n            if (++callbackCount === keyCount) resolve(result);\n          };\n\n          const errorHandler = eventRejectHandler(reject);\n\n          for (let i = 0; i < length; ++i) {\n            const key = keys[i];\n\n            if (key != null) {\n              req = store.get(keys[i]);\n              req._pos = i;\n              req.onsuccess = successHandler;\n              req.onerror = errorHandler;\n              ++keyCount;\n            }\n          }\n\n          if (keyCount === 0) resolve(result);\n        });\n      },\n\n      get({\n        trans,\n        key\n      }) {\n        return new Promise((resolve, reject) => {\n          resolve = wrap(resolve);\n          const store = trans.objectStore(tableName);\n          const req = store.get(key);\n\n          req.onsuccess = event => resolve(event.target.result);\n\n          req.onerror = eventRejectHandler(reject);\n        });\n      },\n\n      query: query(hasGetAll),\n      openCursor,\n\n      count({\n        query,\n        trans\n      }) {\n        const {\n          index,\n          range\n        } = query;\n        return new Promise((resolve, reject) => {\n          const store = trans.objectStore(tableName);\n          const source = index.isPrimaryKey ? store : store.index(index.name);\n          const idbKeyRange = makeIDBKeyRange(range);\n          const req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n          req.onsuccess = wrap(ev => resolve(ev.target.result));\n          req.onerror = eventRejectHandler(reject);\n        });\n      }\n\n    };\n  }\n\n  const {\n    schema,\n    hasGetAll\n  } = extractSchema(db, tmpTrans);\n  const tables = schema.tables.map(tableSchema => createDbCoreTable(tableSchema));\n  const tableMap = {};\n  tables.forEach(table => tableMap[table.name] = table);\n  return {\n    stack: \"dbcore\",\n    transaction: db.transaction.bind(db),\n\n    table(name) {\n      const result = tableMap[name];\n      if (!result) throw new Error(`Table '${name}' not found`);\n      return tableMap[name];\n    },\n\n    MIN_KEY: -Infinity,\n    MAX_KEY: getMaxKey(IdbKeyRange),\n    schema\n  };\n}\n\nfunction createMiddlewareStack(stackImpl, middlewares) {\n  return middlewares.reduce((down, {\n    create\n  }) => ({ ...down,\n    ...create(down)\n  }), stackImpl);\n}\n\nfunction createMiddlewareStacks(middlewares, idbdb, {\n  IDBKeyRange,\n  indexedDB\n}, tmpTrans) {\n  const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n  return {\n    dbcore\n  };\n}\n\nfunction generateMiddlewareStacks({\n  _novip: db\n}, tmpTrans) {\n  const idbdb = tmpTrans.db;\n  const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n  db.core = stacks.dbcore;\n  db.tables.forEach(table => {\n    const tableName = table.name;\n\n    if (db.core.schema.tables.some(tbl => tbl.name === tableName)) {\n      table.core = db.core.table(tableName);\n\n      if (db[tableName] instanceof db.Table) {\n        db[tableName].core = table.core;\n      }\n    }\n  });\n}\n\nfunction setApiOnPlace({\n  _novip: db\n}, objs, tableNames, dbschema) {\n  tableNames.forEach(tableName => {\n    const schema = dbschema[tableName];\n    objs.forEach(obj => {\n      const propDesc = getPropertyDescriptor(obj, tableName);\n\n      if (!propDesc || \"value\" in propDesc && propDesc.value === undefined) {\n        if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n          setProp(obj, tableName, {\n            get() {\n              return this.table(tableName);\n            },\n\n            set(value) {\n              defineProperty(this, tableName, {\n                value,\n                writable: true,\n                configurable: true,\n                enumerable: true\n              });\n            }\n\n          });\n        } else {\n          obj[tableName] = new db.Table(tableName, schema);\n        }\n      }\n    });\n  });\n}\n\nfunction removeTablesApi({\n  _novip: db\n}, objs) {\n  objs.forEach(obj => {\n    for (let key in obj) {\n      if (obj[key] instanceof db.Table) delete obj[key];\n    }\n  });\n}\n\nfunction lowerVersionFirst(a, b) {\n  return a._cfg.version - b._cfg.version;\n}\n\nfunction runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n  const globalSchema = db._dbSchema;\n\n  const trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n\n  trans.create(idbUpgradeTrans);\n\n  trans._completion.catch(reject);\n\n  const rejectTransaction = trans._reject.bind(trans);\n\n  const transless = PSD.transless || PSD;\n  newScope(() => {\n    PSD.trans = trans;\n    PSD.transless = transless;\n\n    if (oldVersion === 0) {\n      keys(globalSchema).forEach(tableName => {\n        createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n      });\n      generateMiddlewareStacks(db, idbUpgradeTrans);\n      DexiePromise.follow(() => db.on.populate.fire(trans)).catch(rejectTransaction);\n    } else updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);\n  });\n}\n\nfunction updateTablesAndIndexes({\n  _novip: db\n}, oldVersion, trans, idbUpgradeTrans) {\n  const queue = [];\n  const versions = db._versions;\n  let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n  let anyContentUpgraderHasRun = false;\n  const versToRun = versions.filter(v => v._cfg.version >= oldVersion);\n  versToRun.forEach(version => {\n    queue.push(() => {\n      const oldSchema = globalSchema;\n      const newSchema = version._cfg.dbschema;\n      adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n      adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n      globalSchema = db._dbSchema = newSchema;\n      const diff = getSchemaDiff(oldSchema, newSchema);\n      diff.add.forEach(tuple => {\n        createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n      });\n      diff.change.forEach(change => {\n        if (change.recreate) {\n          throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n        } else {\n          const store = idbUpgradeTrans.objectStore(change.name);\n          change.add.forEach(idx => addIndex(store, idx));\n          change.change.forEach(idx => {\n            store.deleteIndex(idx.name);\n            addIndex(store, idx);\n          });\n          change.del.forEach(idxName => store.deleteIndex(idxName));\n        }\n      });\n      const contentUpgrade = version._cfg.contentUpgrade;\n\n      if (contentUpgrade && version._cfg.version > oldVersion) {\n        generateMiddlewareStacks(db, idbUpgradeTrans);\n        trans._memoizedTables = {};\n        anyContentUpgraderHasRun = true;\n        let upgradeSchema = shallowClone(newSchema);\n        diff.del.forEach(table => {\n          upgradeSchema[table] = oldSchema[table];\n        });\n        removeTablesApi(db, [db.Transaction.prototype]);\n        setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema), upgradeSchema);\n        trans.schema = upgradeSchema;\n        const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);\n\n        if (contentUpgradeIsAsync) {\n          incrementExpectedAwaits();\n        }\n\n        let returnValue;\n        const promiseFollowed = DexiePromise.follow(() => {\n          returnValue = contentUpgrade(trans);\n\n          if (returnValue) {\n            if (contentUpgradeIsAsync) {\n              var decrementor = decrementExpectedAwaits.bind(null, null);\n              returnValue.then(decrementor, decrementor);\n            }\n          }\n        });\n        return returnValue && typeof returnValue.then === 'function' ? DexiePromise.resolve(returnValue) : promiseFollowed.then(() => returnValue);\n      }\n    });\n    queue.push(idbtrans => {\n      if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\n        const newSchema = version._cfg.dbschema;\n        deleteRemovedTables(newSchema, idbtrans);\n      }\n\n      removeTablesApi(db, [db.Transaction.prototype]);\n      setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n      trans.schema = db._dbSchema;\n    });\n  });\n\n  function runQueue() {\n    return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();\n  }\n\n  return runQueue().then(() => {\n    createMissingTables(globalSchema, idbUpgradeTrans);\n  });\n}\n\nfunction getSchemaDiff(oldSchema, newSchema) {\n  const diff = {\n    del: [],\n    add: [],\n    change: []\n  };\n  let table;\n\n  for (table in oldSchema) {\n    if (!newSchema[table]) diff.del.push(table);\n  }\n\n  for (table in newSchema) {\n    const oldDef = oldSchema[table],\n          newDef = newSchema[table];\n\n    if (!oldDef) {\n      diff.add.push([table, newDef]);\n    } else {\n      const change = {\n        name: table,\n        def: newDef,\n        recreate: false,\n        del: [],\n        add: [],\n        change: []\n      };\n\n      if ('' + (oldDef.primKey.keyPath || '') !== '' + (newDef.primKey.keyPath || '') || oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge) {\n        change.recreate = true;\n        diff.change.push(change);\n      } else {\n        const oldIndexes = oldDef.idxByName;\n        const newIndexes = newDef.idxByName;\n        let idxName;\n\n        for (idxName in oldIndexes) {\n          if (!newIndexes[idxName]) change.del.push(idxName);\n        }\n\n        for (idxName in newIndexes) {\n          const oldIdx = oldIndexes[idxName],\n                newIdx = newIndexes[idxName];\n          if (!oldIdx) change.add.push(newIdx);else if (oldIdx.src !== newIdx.src) change.change.push(newIdx);\n        }\n\n        if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n          diff.change.push(change);\n        }\n      }\n    }\n  }\n\n  return diff;\n}\n\nfunction createTable(idbtrans, tableName, primKey, indexes) {\n  const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? {\n    keyPath: primKey.keyPath,\n    autoIncrement: primKey.auto\n  } : {\n    autoIncrement: primKey.auto\n  });\n  indexes.forEach(idx => addIndex(store, idx));\n  return store;\n}\n\nfunction createMissingTables(newSchema, idbtrans) {\n  keys(newSchema).forEach(tableName => {\n    if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n      createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n    }\n  });\n}\n\nfunction deleteRemovedTables(newSchema, idbtrans) {\n  [].slice.call(idbtrans.db.objectStoreNames).forEach(storeName => newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));\n}\n\nfunction addIndex(store, idx) {\n  store.createIndex(idx.name, idx.keyPath, {\n    unique: idx.unique,\n    multiEntry: idx.multi\n  });\n}\n\nfunction buildGlobalSchema(db, idbdb, tmpTrans) {\n  const globalSchema = {};\n  const dbStoreNames = slice(idbdb.objectStoreNames, 0);\n  dbStoreNames.forEach(storeName => {\n    const store = tmpTrans.objectStore(storeName);\n    let keyPath = store.keyPath;\n    const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n    const indexes = [];\n\n    for (let j = 0; j < store.indexNames.length; ++j) {\n      const idbindex = store.index(store.indexNames[j]);\n      keyPath = idbindex.keyPath;\n      var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n      indexes.push(index);\n    }\n\n    globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n  });\n  return globalSchema;\n}\n\nfunction readGlobalSchema({\n  _novip: db\n}, idbdb, tmpTrans) {\n  db.verno = idbdb.version / 10;\n  const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n  db._storeNames = slice(idbdb.objectStoreNames, 0);\n  setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n}\n\nfunction verifyInstalledSchema(db, tmpTrans) {\n  const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n  const diff = getSchemaDiff(installedSchema, db._dbSchema);\n  return !(diff.add.length || diff.change.some(ch => ch.add.length || ch.change.length));\n}\n\nfunction adjustToExistingIndexNames({\n  _novip: db\n}, schema, idbtrans) {\n  const storeNames = idbtrans.db.objectStoreNames;\n\n  for (let i = 0; i < storeNames.length; ++i) {\n    const storeName = storeNames[i];\n    const store = idbtrans.objectStore(storeName);\n    db._hasGetAll = 'getAll' in store;\n\n    for (let j = 0; j < store.indexNames.length; ++j) {\n      const indexName = store.indexNames[j];\n      const keyPath = store.index(indexName).keyPath;\n      const dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n\n      if (schema[storeName]) {\n        const indexSpec = schema[storeName].idxByName[dexieName];\n\n        if (indexSpec) {\n          indexSpec.name = indexName;\n          delete schema[storeName].idxByName[dexieName];\n          schema[storeName].idxByName[indexName] = indexSpec;\n        }\n      }\n    }\n  }\n\n  if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n    db._hasGetAll = false;\n  }\n}\n\nfunction parseIndexSyntax(primKeyAndIndexes) {\n  return primKeyAndIndexes.split(',').map((index, indexNum) => {\n    index = index.trim();\n    const name = index.replace(/([&*]|\\+\\+)/g, \"\");\n    const keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n    return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n  });\n}\n\nclass Version {\n  _parseStoresSpec(stores, outSchema) {\n    keys(stores).forEach(tableName => {\n      if (stores[tableName] !== null) {\n        var indexes = parseIndexSyntax(stores[tableName]);\n        var primKey = indexes.shift();\n        if (primKey.multi) throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n        indexes.forEach(idx => {\n          if (idx.auto) throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n          if (!idx.keyPath) throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n        });\n        outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n      }\n    });\n  }\n\n  stores(stores) {\n    const db = this.db;\n    this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;\n    const versions = db._versions;\n    const storesSpec = {};\n    let dbschema = {};\n    versions.forEach(version => {\n      extend(storesSpec, version._cfg.storesSource);\n      dbschema = version._cfg.dbschema = {};\n\n      version._parseStoresSpec(storesSpec, dbschema);\n    });\n    db._dbSchema = dbschema;\n    removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n    setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n    db._storeNames = keys(dbschema);\n    return this;\n  }\n\n  upgrade(upgradeFunction) {\n    this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n    return this;\n  }\n\n}\n\nfunction createVersionConstructor(db) {\n  return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n    this.db = db;\n    this._cfg = {\n      version: versionNumber,\n      storesSource: null,\n      dbschema: {},\n      tables: {},\n      contentUpgrade: null\n    };\n  });\n}\n\nfunction getDbNamesTable(indexedDB, IDBKeyRange) {\n  let dbNamesDB = indexedDB[\"_dbNamesDB\"];\n\n  if (!dbNamesDB) {\n    dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n      addons: [],\n      indexedDB,\n      IDBKeyRange\n    });\n    dbNamesDB.version(1).stores({\n      dbnames: \"name\"\n    });\n  }\n\n  return dbNamesDB.table(\"dbnames\");\n}\n\nfunction hasDatabasesNative(indexedDB) {\n  return indexedDB && typeof indexedDB.databases === \"function\";\n}\n\nfunction getDatabaseNames({\n  indexedDB,\n  IDBKeyRange\n}) {\n  return hasDatabasesNative(indexedDB) ? Promise.resolve(indexedDB.databases()).then(infos => infos.map(info => info.name).filter(name => name !== DBNAMES_DB)) : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n}\n\nfunction _onDatabaseCreated({\n  indexedDB,\n  IDBKeyRange\n}, name) {\n  !hasDatabasesNative(indexedDB) && name !== DBNAMES_DB && getDbNamesTable(indexedDB, IDBKeyRange).put({\n    name\n  }).catch(nop);\n}\n\nfunction _onDatabaseDeleted({\n  indexedDB,\n  IDBKeyRange\n}, name) {\n  !hasDatabasesNative(indexedDB) && name !== DBNAMES_DB && getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n}\n\nfunction vip(fn) {\n  return newScope(function () {\n    PSD.letThrough = true;\n    return fn();\n  });\n}\n\nfunction idbReady() {\n  var isSafari = !navigator.userAgentData && /Safari\\//.test(navigator.userAgent) && !/Chrom(e|ium)\\//.test(navigator.userAgent);\n  if (!isSafari || !indexedDB.databases) return Promise.resolve();\n  var intervalId;\n  return new Promise(function (resolve) {\n    var tryIdb = function () {\n      return indexedDB.databases().finally(resolve);\n    };\n\n    intervalId = setInterval(tryIdb, 100);\n    tryIdb();\n  }).finally(function () {\n    return clearInterval(intervalId);\n  });\n}\n\nfunction dexieOpen(db) {\n  const state = db._state;\n  const {\n    indexedDB\n  } = db._deps;\n  if (state.isBeingOpened || db.idbdb) return state.dbReadyPromise.then(() => state.dbOpenError ? rejection(state.dbOpenError) : db);\n  debug && (state.openCanceller._stackHolder = getErrorWithStack());\n  state.isBeingOpened = true;\n  state.dbOpenError = null;\n  state.openComplete = false;\n  const openCanceller = state.openCanceller;\n\n  function throwIfCancelled() {\n    if (state.openCanceller !== openCanceller) throw new exceptions.DatabaseClosed('db.open() was cancelled');\n  }\n\n  let resolveDbReady = state.dbReadyResolve,\n      upgradeTransaction = null,\n      wasCreated = false;\n  return DexiePromise.race([openCanceller, (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(() => new DexiePromise((resolve, reject) => {\n    throwIfCancelled();\n    if (!indexedDB) throw new exceptions.MissingAPI();\n    const dbName = db.name;\n    const req = state.autoSchema ? indexedDB.open(dbName) : indexedDB.open(dbName, Math.round(db.verno * 10));\n    if (!req) throw new exceptions.MissingAPI();\n    req.onerror = eventRejectHandler(reject);\n    req.onblocked = wrap(db._fireOnBlocked);\n    req.onupgradeneeded = wrap(e => {\n      upgradeTransaction = req.transaction;\n\n      if (state.autoSchema && !db._options.allowEmptyDB) {\n        req.onerror = preventDefault;\n        upgradeTransaction.abort();\n        req.result.close();\n        const delreq = indexedDB.deleteDatabase(dbName);\n        delreq.onsuccess = delreq.onerror = wrap(() => {\n          reject(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));\n        });\n      } else {\n        upgradeTransaction.onerror = eventRejectHandler(reject);\n        var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n        wasCreated = oldVer < 1;\n        db._novip.idbdb = req.result;\n        runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n      }\n    }, reject);\n    req.onsuccess = wrap(() => {\n      upgradeTransaction = null;\n      const idbdb = db._novip.idbdb = req.result;\n      const objectStoreNames = slice(idbdb.objectStoreNames);\n      if (objectStoreNames.length > 0) try {\n        const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n        if (state.autoSchema) readGlobalSchema(db, idbdb, tmpTrans);else {\n          adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n\n          if (!verifyInstalledSchema(db, tmpTrans)) {\n            console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);\n          }\n        }\n        generateMiddlewareStacks(db, tmpTrans);\n      } catch (e) {}\n      connections.push(db);\n      idbdb.onversionchange = wrap(ev => {\n        state.vcFired = true;\n        db.on(\"versionchange\").fire(ev);\n      });\n      idbdb.onclose = wrap(ev => {\n        db.on(\"close\").fire(ev);\n      });\n      if (wasCreated) _onDatabaseCreated(db._deps, dbName);\n      resolve();\n    }, reject);\n  }))]).then(() => {\n    throwIfCancelled();\n    state.onReadyBeingFired = [];\n    return DexiePromise.resolve(vip(() => db.on.ready.fire(db.vip))).then(function fireRemainders() {\n      if (state.onReadyBeingFired.length > 0) {\n        let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);\n        state.onReadyBeingFired = [];\n        return DexiePromise.resolve(vip(() => remainders(db.vip))).then(fireRemainders);\n      }\n    });\n  }).finally(() => {\n    state.onReadyBeingFired = null;\n    state.isBeingOpened = false;\n  }).then(() => {\n    return db;\n  }).catch(err => {\n    state.dbOpenError = err;\n\n    try {\n      upgradeTransaction && upgradeTransaction.abort();\n    } catch (_a) {}\n\n    if (openCanceller === state.openCanceller) {\n      db._close();\n    }\n\n    return rejection(err);\n  }).finally(() => {\n    state.openComplete = true;\n    resolveDbReady();\n  });\n}\n\nfunction awaitIterator(iterator) {\n  var callNext = result => iterator.next(result),\n      doThrow = error => iterator.throw(error),\n      onSuccess = step(callNext),\n      onError = step(doThrow);\n\n  function step(getNext) {\n    return val => {\n      var next = getNext(val),\n          value = next.value;\n      return next.done ? value : !value || typeof value.then !== 'function' ? isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);\n    };\n  }\n\n  return step(callNext)();\n}\n\nfunction extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n  var i = arguments.length;\n  if (i < 2) throw new exceptions.InvalidArgument(\"Too few arguments\");\n  var args = new Array(i - 1);\n\n  while (--i) args[i - 1] = arguments[i];\n\n  scopeFunc = args.pop();\n  var tables = flatten(args);\n  return [mode, tables, scopeFunc];\n}\n\nfunction enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n  return DexiePromise.resolve().then(() => {\n    const transless = PSD.transless || PSD;\n\n    const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n\n    const zoneProps = {\n      trans: trans,\n      transless: transless\n    };\n\n    if (parentTransaction) {\n      trans.idbtrans = parentTransaction.idbtrans;\n    } else {\n      trans.create();\n    }\n\n    const scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n\n    if (scopeFuncIsAsync) {\n      incrementExpectedAwaits();\n    }\n\n    let returnValue;\n    const promiseFollowed = DexiePromise.follow(() => {\n      returnValue = scopeFunc.call(trans, trans);\n\n      if (returnValue) {\n        if (scopeFuncIsAsync) {\n          var decrementor = decrementExpectedAwaits.bind(null, null);\n          returnValue.then(decrementor, decrementor);\n        } else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n          returnValue = awaitIterator(returnValue);\n        }\n      }\n    }, zoneProps);\n    return (returnValue && typeof returnValue.then === 'function' ? DexiePromise.resolve(returnValue).then(x => trans.active ? x : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\"))) : promiseFollowed.then(() => returnValue)).then(x => {\n      if (parentTransaction) trans._resolve();\n      return trans._completion.then(() => x);\n    }).catch(e => {\n      trans._reject(e);\n\n      return rejection(e);\n    });\n  });\n}\n\nfunction pad(a, value, count) {\n  const result = isArray(a) ? a.slice() : [a];\n\n  for (let i = 0; i < count; ++i) result.push(value);\n\n  return result;\n}\n\nfunction createVirtualIndexMiddleware(down) {\n  return { ...down,\n\n    table(tableName) {\n      const table = down.table(tableName);\n      const {\n        schema\n      } = table;\n      const indexLookup = {};\n      const allVirtualIndexes = [];\n\n      function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n        const keyPathAlias = getKeyPathAlias(keyPath);\n        const indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];\n        const keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n        const isVirtual = keyTail > 0;\n        const virtualIndex = { ...lowLevelIndex,\n          isVirtual,\n          keyTail,\n          keyLength,\n          extractKey: getKeyExtractor(keyPath),\n          unique: !isVirtual && lowLevelIndex.unique\n        };\n        indexList.push(virtualIndex);\n\n        if (!virtualIndex.isPrimaryKey) {\n          allVirtualIndexes.push(virtualIndex);\n        }\n\n        if (keyLength > 1) {\n          const virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);\n          addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n        }\n\n        indexList.sort((a, b) => a.keyTail - b.keyTail);\n        return virtualIndex;\n      }\n\n      const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n      indexLookup[\":id\"] = [primaryKey];\n\n      for (const index of schema.indexes) {\n        addVirtualIndexes(index.keyPath, 0, index);\n      }\n\n      function findBestIndex(keyPath) {\n        const result = indexLookup[getKeyPathAlias(keyPath)];\n        return result && result[0];\n      }\n\n      function translateRange(range, keyTail) {\n        return {\n          type: range.type === 1 ? 2 : range.type,\n          lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n          lowerOpen: true,\n          upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n          upperOpen: true\n        };\n      }\n\n      function translateRequest(req) {\n        const index = req.query.index;\n        return index.isVirtual ? { ...req,\n          query: {\n            index,\n            range: translateRange(req.query.range, index.keyTail)\n          }\n        } : req;\n      }\n\n      const result = { ...table,\n        schema: { ...schema,\n          primaryKey,\n          indexes: allVirtualIndexes,\n          getIndexByKeyPath: findBestIndex\n        },\n\n        count(req) {\n          return table.count(translateRequest(req));\n        },\n\n        query(req) {\n          return table.query(translateRequest(req));\n        },\n\n        openCursor(req) {\n          const {\n            keyTail,\n            isVirtual,\n            keyLength\n          } = req.query.index;\n          if (!isVirtual) return table.openCursor(req);\n\n          function createVirtualCursor(cursor) {\n            function _continue(key) {\n              key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();\n            }\n\n            const virtualCursor = Object.create(cursor, {\n              continue: {\n                value: _continue\n              },\n              continuePrimaryKey: {\n                value(key, primaryKey) {\n                  cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                }\n\n              },\n              primaryKey: {\n                get() {\n                  return cursor.primaryKey;\n                }\n\n              },\n              key: {\n                get() {\n                  const key = cursor.key;\n                  return keyLength === 1 ? key[0] : key.slice(0, keyLength);\n                }\n\n              },\n              value: {\n                get() {\n                  return cursor.value;\n                }\n\n              }\n            });\n            return virtualCursor;\n          }\n\n          return table.openCursor(translateRequest(req)).then(cursor => cursor && createVirtualCursor(cursor));\n        }\n\n      };\n      return result;\n    }\n\n  };\n}\n\nconst virtualIndexMiddleware = {\n  stack: \"dbcore\",\n  name: \"VirtualIndexMiddleware\",\n  level: 1,\n  create: createVirtualIndexMiddleware\n};\n\nfunction getObjectDiff(a, b, rv, prfx) {\n  rv = rv || {};\n  prfx = prfx || '';\n  keys(a).forEach(prop => {\n    if (!hasOwn(b, prop)) {\n      rv[prfx + prop] = undefined;\n    } else {\n      var ap = a[prop],\n          bp = b[prop];\n\n      if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n        const apTypeName = toStringTag(ap);\n        const bpTypeName = toStringTag(bp);\n\n        if (apTypeName !== bpTypeName) {\n          rv[prfx + prop] = b[prop];\n        } else if (apTypeName === 'Object') {\n          getObjectDiff(ap, bp, rv, prfx + prop + '.');\n        } else if (ap !== bp) {\n          rv[prfx + prop] = b[prop];\n        }\n      } else if (ap !== bp) rv[prfx + prop] = b[prop];\n    }\n  });\n  keys(b).forEach(prop => {\n    if (!hasOwn(a, prop)) {\n      rv[prfx + prop] = b[prop];\n    }\n  });\n  return rv;\n}\n\nfunction getEffectiveKeys(primaryKey, req) {\n  if (req.type === 'delete') return req.keys;\n  return req.keys || req.values.map(primaryKey.extractKey);\n}\n\nconst hooksMiddleware = {\n  stack: \"dbcore\",\n  name: \"HooksMiddleware\",\n  level: 2,\n  create: downCore => ({ ...downCore,\n\n    table(tableName) {\n      const downTable = downCore.table(tableName);\n      const {\n        primaryKey\n      } = downTable.schema;\n      const tableMiddleware = { ...downTable,\n\n        mutate(req) {\n          const dxTrans = PSD.trans;\n          const {\n            deleting,\n            creating,\n            updating\n          } = dxTrans.table(tableName).hook;\n\n          switch (req.type) {\n            case 'add':\n              if (creating.fire === nop) break;\n              return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n\n            case 'put':\n              if (creating.fire === nop && updating.fire === nop) break;\n              return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n\n            case 'delete':\n              if (deleting.fire === nop) break;\n              return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n\n            case 'deleteRange':\n              if (deleting.fire === nop) break;\n              return dxTrans._promise('readwrite', () => deleteRange(req), true);\n          }\n\n          return downTable.mutate(req);\n\n          function addPutOrDelete(req) {\n            const dxTrans = PSD.trans;\n            const keys = req.keys || getEffectiveKeys(primaryKey, req);\n            if (!keys) throw new Error(\"Keys missing\");\n            req = req.type === 'add' || req.type === 'put' ? { ...req,\n              keys\n            } : { ...req\n            };\n            if (req.type !== 'delete') req.values = [...req.values];\n            if (req.keys) req.keys = [...req.keys];\n            return getExistingValues(downTable, req, keys).then(existingValues => {\n              const contexts = keys.map((key, i) => {\n                const existingValue = existingValues[i];\n                const ctx = {\n                  onerror: null,\n                  onsuccess: null\n                };\n\n                if (req.type === 'delete') {\n                  deleting.fire.call(ctx, key, existingValue, dxTrans);\n                } else if (req.type === 'add' || existingValue === undefined) {\n                  const generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n\n                  if (key == null && generatedPrimaryKey != null) {\n                    key = generatedPrimaryKey;\n                    req.keys[i] = key;\n\n                    if (!primaryKey.outbound) {\n                      setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                    }\n                  }\n                } else {\n                  const objectDiff = getObjectDiff(existingValue, req.values[i]);\n                  const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n\n                  if (additionalChanges) {\n                    const requestedValue = req.values[i];\n                    Object.keys(additionalChanges).forEach(keyPath => {\n                      if (hasOwn(requestedValue, keyPath)) {\n                        requestedValue[keyPath] = additionalChanges[keyPath];\n                      } else {\n                        setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);\n                      }\n                    });\n                  }\n                }\n\n                return ctx;\n              });\n              return downTable.mutate(req).then(({\n                failures,\n                results,\n                numFailures,\n                lastResult\n              }) => {\n                for (let i = 0; i < keys.length; ++i) {\n                  const primKey = results ? results[i] : keys[i];\n                  const ctx = contexts[i];\n\n                  if (primKey == null) {\n                    ctx.onerror && ctx.onerror(failures[i]);\n                  } else {\n                    ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ? req.values[i] : primKey);\n                  }\n                }\n\n                return {\n                  failures,\n                  results,\n                  numFailures,\n                  lastResult\n                };\n              }).catch(error => {\n                contexts.forEach(ctx => ctx.onerror && ctx.onerror(error));\n                return Promise.reject(error);\n              });\n            });\n          }\n\n          function deleteRange(req) {\n            return deleteNextChunk(req.trans, req.range, 10000);\n          }\n\n          function deleteNextChunk(trans, range, limit) {\n            return downTable.query({\n              trans,\n              values: false,\n              query: {\n                index: primaryKey,\n                range\n              },\n              limit\n            }).then(({\n              result\n            }) => {\n              return addPutOrDelete({\n                type: 'delete',\n                keys: result,\n                trans\n              }).then(res => {\n                if (res.numFailures > 0) return Promise.reject(res.failures[0]);\n\n                if (result.length < limit) {\n                  return {\n                    failures: [],\n                    numFailures: 0,\n                    lastResult: undefined\n                  };\n                } else {\n                  return deleteNextChunk(trans, { ...range,\n                    lower: result[result.length - 1],\n                    lowerOpen: true\n                  }, limit);\n                }\n              });\n            });\n          }\n        }\n\n      };\n      return tableMiddleware;\n    }\n\n  })\n};\n\nfunction getExistingValues(table, req, effectiveKeys) {\n  return req.type === \"add\" ? Promise.resolve([]) : table.getMany({\n    trans: req.trans,\n    keys: effectiveKeys,\n    cache: \"immutable\"\n  });\n}\n\nfunction getFromTransactionCache(keys, cache, clone) {\n  try {\n    if (!cache) return null;\n    if (cache.keys.length < keys.length) return null;\n    const result = [];\n\n    for (let i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n      if (cmp(cache.keys[i], keys[j]) !== 0) continue;\n      result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n      ++j;\n    }\n\n    return result.length === keys.length ? result : null;\n  } catch (_a) {\n    return null;\n  }\n}\n\nconst cacheExistingValuesMiddleware = {\n  stack: \"dbcore\",\n  level: -1,\n  create: core => {\n    return {\n      table: tableName => {\n        const table = core.table(tableName);\n        return { ...table,\n          getMany: req => {\n            if (!req.cache) {\n              return table.getMany(req);\n            }\n\n            const cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n\n            if (cachedResult) {\n              return DexiePromise.resolve(cachedResult);\n            }\n\n            return table.getMany(req).then(res => {\n              req.trans[\"_cache\"] = {\n                keys: req.keys,\n                values: req.cache === \"clone\" ? deepClone(res) : res\n              };\n              return res;\n            });\n          },\n          mutate: req => {\n            if (req.type !== \"add\") req.trans[\"_cache\"] = null;\n            return table.mutate(req);\n          }\n        };\n      }\n    };\n  }\n};\n\nfunction isEmptyRange(node) {\n  return !(\"from\" in node);\n}\n\nconst RangeSet = function (fromOrTree, to) {\n  if (this) {\n    extend(this, arguments.length ? {\n      d: 1,\n      from: fromOrTree,\n      to: arguments.length > 1 ? to : fromOrTree\n    } : {\n      d: 0\n    });\n  } else {\n    const rv = new RangeSet();\n\n    if (fromOrTree && \"d\" in fromOrTree) {\n      extend(rv, fromOrTree);\n    }\n\n    return rv;\n  }\n};\n\nprops(RangeSet.prototype, {\n  add(rangeSet) {\n    mergeRanges(this, rangeSet);\n    return this;\n  },\n\n  addKey(key) {\n    addRange(this, key, key);\n    return this;\n  },\n\n  addKeys(keys) {\n    keys.forEach(key => addRange(this, key, key));\n    return this;\n  },\n\n  [iteratorSymbol]() {\n    return getRangeSetIterator(this);\n  }\n\n});\n\nfunction addRange(target, from, to) {\n  const diff = cmp(from, to);\n  if (isNaN(diff)) return;\n  if (diff > 0) throw RangeError();\n  if (isEmptyRange(target)) return extend(target, {\n    from,\n    to,\n    d: 1\n  });\n  const left = target.l;\n  const right = target.r;\n\n  if (cmp(to, target.from) < 0) {\n    left ? addRange(left, from, to) : target.l = {\n      from,\n      to,\n      d: 1,\n      l: null,\n      r: null\n    };\n    return rebalance(target);\n  }\n\n  if (cmp(from, target.to) > 0) {\n    right ? addRange(right, from, to) : target.r = {\n      from,\n      to,\n      d: 1,\n      l: null,\n      r: null\n    };\n    return rebalance(target);\n  }\n\n  if (cmp(from, target.from) < 0) {\n    target.from = from;\n    target.l = null;\n    target.d = right ? right.d + 1 : 1;\n  }\n\n  if (cmp(to, target.to) > 0) {\n    target.to = to;\n    target.r = null;\n    target.d = target.l ? target.l.d + 1 : 1;\n  }\n\n  const rightWasCutOff = !target.r;\n\n  if (left && !target.l) {\n    mergeRanges(target, left);\n  }\n\n  if (right && rightWasCutOff) {\n    mergeRanges(target, right);\n  }\n}\n\nfunction mergeRanges(target, newSet) {\n  function _addRangeSet(target, {\n    from,\n    to,\n    l,\n    r\n  }) {\n    addRange(target, from, to);\n    if (l) _addRangeSet(target, l);\n    if (r) _addRangeSet(target, r);\n  }\n\n  if (!isEmptyRange(newSet)) _addRangeSet(target, newSet);\n}\n\nfunction rangesOverlap(rangeSet1, rangeSet2) {\n  const i1 = getRangeSetIterator(rangeSet2);\n  let nextResult1 = i1.next();\n  if (nextResult1.done) return false;\n  let a = nextResult1.value;\n  const i2 = getRangeSetIterator(rangeSet1);\n  let nextResult2 = i2.next(a.from);\n  let b = nextResult2.value;\n\n  while (!nextResult1.done && !nextResult2.done) {\n    if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0) return true;\n    cmp(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;\n  }\n\n  return false;\n}\n\nfunction getRangeSetIterator(node) {\n  let state = isEmptyRange(node) ? null : {\n    s: 0,\n    n: node\n  };\n  return {\n    next(key) {\n      const keyProvided = arguments.length > 0;\n\n      while (state) {\n        switch (state.s) {\n          case 0:\n            state.s = 1;\n\n            if (keyProvided) {\n              while (state.n.l && cmp(key, state.n.from) < 0) state = {\n                up: state,\n                n: state.n.l,\n                s: 1\n              };\n            } else {\n              while (state.n.l) state = {\n                up: state,\n                n: state.n.l,\n                s: 1\n              };\n            }\n\n          case 1:\n            state.s = 2;\n            if (!keyProvided || cmp(key, state.n.to) <= 0) return {\n              value: state.n,\n              done: false\n            };\n\n          case 2:\n            if (state.n.r) {\n              state.s = 3;\n              state = {\n                up: state,\n                n: state.n.r,\n                s: 0\n              };\n              continue;\n            }\n\n          case 3:\n            state = state.up;\n        }\n      }\n\n      return {\n        done: true\n      };\n    }\n\n  };\n}\n\nfunction rebalance(target) {\n  var _a, _b;\n\n  const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n  const r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n\n  if (r) {\n    const l = r === \"r\" ? \"l\" : \"r\";\n    const rootClone = { ...target\n    };\n    const oldRootRight = target[r];\n    target.from = oldRootRight.from;\n    target.to = oldRootRight.to;\n    target[r] = oldRootRight[r];\n    rootClone[r] = oldRootRight[l];\n    target[l] = rootClone;\n    rootClone.d = computeDepth(rootClone);\n  }\n\n  target.d = computeDepth(target);\n}\n\nfunction computeDepth({\n  r,\n  l\n}) {\n  return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;\n}\n\nconst observabilityMiddleware = {\n  stack: \"dbcore\",\n  level: 0,\n  create: core => {\n    const dbName = core.schema.name;\n    const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n    return { ...core,\n      table: tableName => {\n        const table = core.table(tableName);\n        const {\n          schema\n        } = table;\n        const {\n          primaryKey\n        } = schema;\n        const {\n          extractKey,\n          outbound\n        } = primaryKey;\n        const tableClone = { ...table,\n          mutate: req => {\n            const trans = req.trans;\n            const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});\n\n            const getRangeSet = indexName => {\n              const part = `idb://${dbName}/${tableName}/${indexName}`;\n              return mutatedParts[part] || (mutatedParts[part] = new RangeSet());\n            };\n\n            const pkRangeSet = getRangeSet(\"\");\n            const delsRangeSet = getRangeSet(\":dels\");\n            const {\n              type\n            } = req;\n            let [keys, newObjs] = req.type === \"deleteRange\" ? [req.range] : req.type === \"delete\" ? [req.keys] : req.values.length < 50 ? [[], req.values] : [];\n            const oldCache = req.trans[\"_cache\"];\n            return table.mutate(req).then(res => {\n              if (isArray(keys)) {\n                if (type !== \"delete\") keys = res.results;\n                pkRangeSet.addKeys(keys);\n                const oldObjs = getFromTransactionCache(keys, oldCache);\n\n                if (!oldObjs && type !== \"add\") {\n                  delsRangeSet.addKeys(keys);\n                }\n\n                if (oldObjs || newObjs) {\n                  trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                }\n              } else if (keys) {\n                const range = {\n                  from: keys.lower,\n                  to: keys.upper\n                };\n                delsRangeSet.add(range);\n                pkRangeSet.add(range);\n              } else {\n                pkRangeSet.add(FULL_RANGE);\n                delsRangeSet.add(FULL_RANGE);\n                schema.indexes.forEach(idx => getRangeSet(idx.name).add(FULL_RANGE));\n              }\n\n              return res;\n            });\n          }\n        };\n\n        const getRange = ({\n          query: {\n            index,\n            range\n          }\n        }) => {\n          var _a, _b;\n\n          return [index, new RangeSet((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY)];\n        };\n\n        const readSubscribers = {\n          get: req => [primaryKey, new RangeSet(req.key)],\n          getMany: req => [primaryKey, new RangeSet().addKeys(req.keys)],\n          count: getRange,\n          query: getRange,\n          openCursor: getRange\n        };\n        keys(readSubscribers).forEach(method => {\n          tableClone[method] = function (req) {\n            const {\n              subscr\n            } = PSD;\n\n            if (subscr) {\n              const getRangeSet = indexName => {\n                const part = `idb://${dbName}/${tableName}/${indexName}`;\n                return subscr[part] || (subscr[part] = new RangeSet());\n              };\n\n              const pkRangeSet = getRangeSet(\"\");\n              const delsRangeSet = getRangeSet(\":dels\");\n              const [queriedIndex, queriedRanges] = readSubscribers[method](req);\n              getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n\n              if (!queriedIndex.isPrimaryKey) {\n                if (method === \"count\") {\n                  delsRangeSet.add(FULL_RANGE);\n                } else {\n                  const keysPromise = method === \"query\" && outbound && req.values && table.query({ ...req,\n                    values: false\n                  });\n                  return table[method].apply(this, arguments).then(res => {\n                    if (method === \"query\") {\n                      if (outbound && req.values) {\n                        return keysPromise.then(({\n                          result: resultingKeys\n                        }) => {\n                          pkRangeSet.addKeys(resultingKeys);\n                          return res;\n                        });\n                      }\n\n                      const pKeys = req.values ? res.result.map(extractKey) : res.result;\n\n                      if (req.values) {\n                        pkRangeSet.addKeys(pKeys);\n                      } else {\n                        delsRangeSet.addKeys(pKeys);\n                      }\n                    } else if (method === \"openCursor\") {\n                      const cursor = res;\n                      const wantValues = req.values;\n                      return cursor && Object.create(cursor, {\n                        key: {\n                          get() {\n                            delsRangeSet.addKey(cursor.primaryKey);\n                            return cursor.key;\n                          }\n\n                        },\n                        primaryKey: {\n                          get() {\n                            const pkey = cursor.primaryKey;\n                            delsRangeSet.addKey(pkey);\n                            return pkey;\n                          }\n\n                        },\n                        value: {\n                          get() {\n                            wantValues && pkRangeSet.addKey(cursor.primaryKey);\n                            return cursor.value;\n                          }\n\n                        }\n                      });\n                    }\n\n                    return res;\n                  });\n                }\n              }\n            }\n\n            return table[method].apply(this, arguments);\n          };\n        });\n        return tableClone;\n      }\n    };\n  }\n};\n\nfunction trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n  function addAffectedIndex(ix) {\n    const rangeSet = getRangeSet(ix.name || \"\");\n\n    function extractKey(obj) {\n      return obj != null ? ix.extractKey(obj) : null;\n    }\n\n    const addKeyOrKeys = key => ix.multiEntry && isArray(key) ? key.forEach(key => rangeSet.addKey(key)) : rangeSet.addKey(key);\n\n    (oldObjs || newObjs).forEach((_, i) => {\n      const oldKey = oldObjs && extractKey(oldObjs[i]);\n      const newKey = newObjs && extractKey(newObjs[i]);\n\n      if (cmp(oldKey, newKey) !== 0) {\n        if (oldKey != null) addKeyOrKeys(oldKey);\n        if (newKey != null) addKeyOrKeys(newKey);\n      }\n    });\n  }\n\n  schema.indexes.forEach(addAffectedIndex);\n}\n\nclass Dexie$1 {\n  constructor(name, options) {\n    this._middlewares = {};\n    this.verno = 0;\n    const deps = Dexie$1.dependencies;\n    this._options = options = {\n      addons: Dexie$1.addons,\n      autoOpen: true,\n      indexedDB: deps.indexedDB,\n      IDBKeyRange: deps.IDBKeyRange,\n      ...options\n    };\n    this._deps = {\n      indexedDB: options.indexedDB,\n      IDBKeyRange: options.IDBKeyRange\n    };\n    const {\n      addons\n    } = options;\n    this._dbSchema = {};\n    this._versions = [];\n    this._storeNames = [];\n    this._allTables = {};\n    this.idbdb = null;\n    this._novip = this;\n    const state = {\n      dbOpenError: null,\n      isBeingOpened: false,\n      onReadyBeingFired: null,\n      openComplete: false,\n      dbReadyResolve: nop,\n      dbReadyPromise: null,\n      cancelOpen: nop,\n      openCanceller: null,\n      autoSchema: true\n    };\n    state.dbReadyPromise = new DexiePromise(resolve => {\n      state.dbReadyResolve = resolve;\n    });\n    state.openCanceller = new DexiePromise((_, reject) => {\n      state.cancelOpen = reject;\n    });\n    this._state = state;\n    this.name = name;\n    this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", {\n      ready: [promisableChain, nop]\n    });\n    this.on.ready.subscribe = override(this.on.ready.subscribe, subscribe => {\n      return (subscriber, bSticky) => {\n        Dexie$1.vip(() => {\n          const state = this._state;\n\n          if (state.openComplete) {\n            if (!state.dbOpenError) DexiePromise.resolve().then(subscriber);\n            if (bSticky) subscribe(subscriber);\n          } else if (state.onReadyBeingFired) {\n            state.onReadyBeingFired.push(subscriber);\n            if (bSticky) subscribe(subscriber);\n          } else {\n            subscribe(subscriber);\n            const db = this;\n            if (!bSticky) subscribe(function unsubscribe() {\n              db.on.ready.unsubscribe(subscriber);\n              db.on.ready.unsubscribe(unsubscribe);\n            });\n          }\n        });\n      };\n    });\n    this.Collection = createCollectionConstructor(this);\n    this.Table = createTableConstructor(this);\n    this.Transaction = createTransactionConstructor(this);\n    this.Version = createVersionConstructor(this);\n    this.WhereClause = createWhereClauseConstructor(this);\n    this.on(\"versionchange\", ev => {\n      if (ev.newVersion > 0) console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);else console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);\n      this.close();\n    });\n    this.on(\"blocked\", ev => {\n      if (!ev.newVersion || ev.newVersion < ev.oldVersion) console.warn(`Dexie.delete('${this.name}') was blocked`);else console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);\n    });\n    this._maxKey = getMaxKey(options.IDBKeyRange);\n\n    this._createTransaction = (mode, storeNames, dbschema, parentTransaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);\n\n    this._fireOnBlocked = ev => {\n      this.on(\"blocked\").fire(ev);\n      connections.filter(c => c.name === this.name && c !== this && !c._state.vcFired).map(c => c.on(\"versionchange\").fire(ev));\n    };\n\n    this.use(virtualIndexMiddleware);\n    this.use(hooksMiddleware);\n    this.use(observabilityMiddleware);\n    this.use(cacheExistingValuesMiddleware);\n    this.vip = Object.create(this, {\n      _vip: {\n        value: true\n      }\n    });\n    addons.forEach(addon => addon(this));\n  }\n\n  version(versionNumber) {\n    if (isNaN(versionNumber) || versionNumber < 0.1) throw new exceptions.Type(`Given version is not a positive number`);\n    versionNumber = Math.round(versionNumber * 10) / 10;\n    if (this.idbdb || this._state.isBeingOpened) throw new exceptions.Schema(\"Cannot add version when database is open\");\n    this.verno = Math.max(this.verno, versionNumber);\n    const versions = this._versions;\n    var versionInstance = versions.filter(v => v._cfg.version === versionNumber)[0];\n    if (versionInstance) return versionInstance;\n    versionInstance = new this.Version(versionNumber);\n    versions.push(versionInstance);\n    versions.sort(lowerVersionFirst);\n    versionInstance.stores({});\n    this._state.autoSchema = false;\n    return versionInstance;\n  }\n\n  _whenReady(fn) {\n    return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise((resolve, reject) => {\n      if (this._state.openComplete) {\n        return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));\n      }\n\n      if (!this._state.isBeingOpened) {\n        if (!this._options.autoOpen) {\n          reject(new exceptions.DatabaseClosed());\n          return;\n        }\n\n        this.open().catch(nop);\n      }\n\n      this._state.dbReadyPromise.then(resolve, reject);\n    }).then(fn);\n  }\n\n  use({\n    stack,\n    create,\n    level,\n    name\n  }) {\n    if (name) this.unuse({\n      stack,\n      name\n    });\n    const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n    middlewares.push({\n      stack,\n      create,\n      level: level == null ? 10 : level,\n      name\n    });\n    middlewares.sort((a, b) => a.level - b.level);\n    return this;\n  }\n\n  unuse({\n    stack,\n    name,\n    create\n  }) {\n    if (stack && this._middlewares[stack]) {\n      this._middlewares[stack] = this._middlewares[stack].filter(mw => create ? mw.create !== create : name ? mw.name !== name : false);\n    }\n\n    return this;\n  }\n\n  open() {\n    return dexieOpen(this);\n  }\n\n  _close() {\n    const state = this._state;\n    const idx = connections.indexOf(this);\n    if (idx >= 0) connections.splice(idx, 1);\n\n    if (this.idbdb) {\n      try {\n        this.idbdb.close();\n      } catch (e) {}\n\n      this._novip.idbdb = null;\n    }\n\n    state.dbReadyPromise = new DexiePromise(resolve => {\n      state.dbReadyResolve = resolve;\n    });\n    state.openCanceller = new DexiePromise((_, reject) => {\n      state.cancelOpen = reject;\n    });\n  }\n\n  close() {\n    this._close();\n\n    const state = this._state;\n    this._options.autoOpen = false;\n    state.dbOpenError = new exceptions.DatabaseClosed();\n    if (state.isBeingOpened) state.cancelOpen(state.dbOpenError);\n  }\n\n  delete() {\n    const hasArguments = arguments.length > 0;\n    const state = this._state;\n    return new DexiePromise((resolve, reject) => {\n      const doDelete = () => {\n        this.close();\n\n        var req = this._deps.indexedDB.deleteDatabase(this.name);\n\n        req.onsuccess = wrap(() => {\n          _onDatabaseDeleted(this._deps, this.name);\n\n          resolve();\n        });\n        req.onerror = eventRejectHandler(reject);\n        req.onblocked = this._fireOnBlocked;\n      };\n\n      if (hasArguments) throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n\n      if (state.isBeingOpened) {\n        state.dbReadyPromise.then(doDelete);\n      } else {\n        doDelete();\n      }\n    });\n  }\n\n  backendDB() {\n    return this.idbdb;\n  }\n\n  isOpen() {\n    return this.idbdb !== null;\n  }\n\n  hasBeenClosed() {\n    const dbOpenError = this._state.dbOpenError;\n    return dbOpenError && dbOpenError.name === 'DatabaseClosed';\n  }\n\n  hasFailed() {\n    return this._state.dbOpenError !== null;\n  }\n\n  dynamicallyOpened() {\n    return this._state.autoSchema;\n  }\n\n  get tables() {\n    return keys(this._allTables).map(name => this._allTables[name]);\n  }\n\n  transaction() {\n    const args = extractTransactionArgs.apply(this, arguments);\n    return this._transaction.apply(this, args);\n  }\n\n  _transaction(mode, tables, scopeFunc) {\n    let parentTransaction = PSD.trans;\n    if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1) parentTransaction = null;\n    const onlyIfCompatible = mode.indexOf('?') !== -1;\n    mode = mode.replace('!', '').replace('?', '');\n    let idbMode, storeNames;\n\n    try {\n      storeNames = tables.map(table => {\n        var storeName = table instanceof this.Table ? table.name : table;\n        if (typeof storeName !== 'string') throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n        return storeName;\n      });\n      if (mode == \"r\" || mode === READONLY) idbMode = READONLY;else if (mode == \"rw\" || mode == READWRITE) idbMode = READWRITE;else throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n\n      if (parentTransaction) {\n        if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n          if (onlyIfCompatible) {\n            parentTransaction = null;\n          } else throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n        }\n\n        if (parentTransaction) {\n          storeNames.forEach(storeName => {\n            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n              if (onlyIfCompatible) {\n                parentTransaction = null;\n              } else throw new exceptions.SubTransaction(\"Table \" + storeName + \" not included in parent transaction.\");\n            }\n          });\n        }\n\n        if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n          parentTransaction = null;\n        }\n      }\n    } catch (e) {\n      return parentTransaction ? parentTransaction._promise(null, (_, reject) => {\n        reject(e);\n      }) : rejection(e);\n    }\n\n    const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n    return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, \"lock\") : PSD.trans ? usePSD(PSD.transless, () => this._whenReady(enterTransaction)) : this._whenReady(enterTransaction);\n  }\n\n  table(tableName) {\n    if (!hasOwn(this._allTables, tableName)) {\n      throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);\n    }\n\n    return this._allTables[tableName];\n  }\n\n}\n\nconst symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol ? Symbol.observable : \"@@observable\";\n\nclass Observable {\n  constructor(subscribe) {\n    this._subscribe = subscribe;\n  }\n\n  subscribe(x, error, complete) {\n    return this._subscribe(!x || typeof x === \"function\" ? {\n      next: x,\n      error,\n      complete\n    } : x);\n  }\n\n  [symbolObservable]() {\n    return this;\n  }\n\n}\n\nfunction extendObservabilitySet(target, newSet) {\n  keys(newSet).forEach(part => {\n    const rangeSet = target[part] || (target[part] = new RangeSet());\n    mergeRanges(rangeSet, newSet[part]);\n  });\n  return target;\n}\n\nfunction liveQuery(querier) {\n  return new Observable(observer => {\n    const scopeFuncIsAsync = isAsyncFunction(querier);\n\n    function execute(subscr) {\n      if (scopeFuncIsAsync) {\n        incrementExpectedAwaits();\n      }\n\n      const exec = () => newScope(querier, {\n        subscr,\n        trans: null\n      });\n\n      const rv = PSD.trans ? usePSD(PSD.transless, exec) : exec();\n\n      if (scopeFuncIsAsync) {\n        rv.then(decrementExpectedAwaits, decrementExpectedAwaits);\n      }\n\n      return rv;\n    }\n\n    let closed = false;\n    let accumMuts = {};\n    let currentObs = {};\n    const subscription = {\n      get closed() {\n        return closed;\n      },\n\n      unsubscribe: () => {\n        closed = true;\n        globalEvents.storagemutated.unsubscribe(mutationListener);\n      }\n    };\n    observer.start && observer.start(subscription);\n    let querying = false,\n        startedListening = false;\n\n    function shouldNotify() {\n      return keys(currentObs).some(key => accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));\n    }\n\n    const mutationListener = parts => {\n      extendObservabilitySet(accumMuts, parts);\n\n      if (shouldNotify()) {\n        doQuery();\n      }\n    };\n\n    const doQuery = () => {\n      if (querying || closed) return;\n      accumMuts = {};\n      const subscr = {};\n      const ret = execute(subscr);\n\n      if (!startedListening) {\n        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n        startedListening = true;\n      }\n\n      querying = true;\n      Promise.resolve(ret).then(result => {\n        querying = false;\n        if (closed) return;\n\n        if (shouldNotify()) {\n          doQuery();\n        } else {\n          accumMuts = {};\n          currentObs = subscr;\n          observer.next && observer.next(result);\n        }\n      }, err => {\n        querying = false;\n        observer.error && observer.error(err);\n        subscription.unsubscribe();\n      });\n    };\n\n    doQuery();\n    return subscription;\n  });\n}\n\nlet domDeps;\n\ntry {\n  domDeps = {\n    indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n    IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n  };\n} catch (e) {\n  domDeps = {\n    indexedDB: null,\n    IDBKeyRange: null\n  };\n}\n\nconst Dexie = Dexie$1;\nprops(Dexie, { ...fullNameExceptions,\n\n  delete(databaseName) {\n    const db = new Dexie(databaseName, {\n      addons: []\n    });\n    return db.delete();\n  },\n\n  exists(name) {\n    return new Dexie(name, {\n      addons: []\n    }).open().then(db => {\n      db.close();\n      return true;\n    }).catch('NoSuchDatabaseError', () => false);\n  },\n\n  getDatabaseNames(cb) {\n    try {\n      return getDatabaseNames(Dexie.dependencies).then(cb);\n    } catch (_a) {\n      return rejection(new exceptions.MissingAPI());\n    }\n  },\n\n  defineClass() {\n    function Class(content) {\n      extend(this, content);\n    }\n\n    return Class;\n  },\n\n  ignoreTransaction(scopeFunc) {\n    return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();\n  },\n\n  vip,\n  async: function (generatorFn) {\n    return function () {\n      try {\n        var rv = awaitIterator(generatorFn.apply(this, arguments));\n        if (!rv || typeof rv.then !== 'function') return DexiePromise.resolve(rv);\n        return rv;\n      } catch (e) {\n        return rejection(e);\n      }\n    };\n  },\n  spawn: function (generatorFn, args, thiz) {\n    try {\n      var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n      if (!rv || typeof rv.then !== 'function') return DexiePromise.resolve(rv);\n      return rv;\n    } catch (e) {\n      return rejection(e);\n    }\n  },\n  currentTransaction: {\n    get: () => PSD.trans || null\n  },\n  waitFor: function (promiseOrFunction, optionalTimeout) {\n    const promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 60000);\n    return PSD.trans ? PSD.trans.waitFor(promise) : promise;\n  },\n  Promise: DexiePromise,\n  debug: {\n    get: () => debug,\n    set: value => {\n      setDebug(value, value === 'dexie' ? () => true : dexieStackFrameFilter);\n    }\n  },\n  derive: derive,\n  extend: extend,\n  props: props,\n  override: override,\n  Events: Events,\n  on: globalEvents,\n  liveQuery,\n  extendObservabilitySet,\n  getByKeyPath: getByKeyPath,\n  setByKeyPath: setByKeyPath,\n  delByKeyPath: delByKeyPath,\n  shallowClone: shallowClone,\n  deepClone: deepClone,\n  getObjectDiff: getObjectDiff,\n  cmp,\n  asap: asap$1,\n  minKey: minKey,\n  addons: [],\n  connections: connections,\n  errnames: errnames,\n  dependencies: domDeps,\n  semVer: DEXIE_VERSION,\n  version: DEXIE_VERSION.split('.').map(n => parseInt(n)).reduce((p, c, i) => p + c / Math.pow(10, i * 2))\n});\nDexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n\nif (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, updatedParts => {\n    if (!propagatingLocally) {\n      let event;\n\n      if (isIEOrEdge) {\n        event = document.createEvent('CustomEvent');\n        event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);\n      } else {\n        event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n          detail: updatedParts\n        });\n      }\n\n      propagatingLocally = true;\n      dispatchEvent(event);\n      propagatingLocally = false;\n    }\n  });\n  addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({\n    detail\n  }) => {\n    if (!propagatingLocally) {\n      propagateLocally(detail);\n    }\n  });\n}\n\nfunction propagateLocally(updateParts) {\n  let wasMe = propagatingLocally;\n\n  try {\n    propagatingLocally = true;\n    globalEvents.storagemutated.fire(updateParts);\n  } finally {\n    propagatingLocally = wasMe;\n  }\n}\n\nlet propagatingLocally = false;\n\nif (typeof BroadcastChannel !== 'undefined') {\n  const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, changedParts => {\n    if (!propagatingLocally) {\n      bc.postMessage(changedParts);\n    }\n  });\n\n  bc.onmessage = ev => {\n    if (ev.data) propagateLocally(ev.data);\n  };\n} else if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {\n  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, changedParts => {\n    try {\n      if (!propagatingLocally) {\n        if (typeof localStorage !== 'undefined') {\n          localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({\n            trig: Math.random(),\n            changedParts\n          }));\n        }\n\n        if (typeof self['clients'] === 'object') {\n          [...self['clients'].matchAll({\n            includeUncontrolled: true\n          })].forEach(client => client.postMessage({\n            type: STORAGE_MUTATED_DOM_EVENT_NAME,\n            changedParts\n          }));\n        }\n      }\n    } catch (_a) {}\n  });\n  addEventListener('storage', ev => {\n    if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {\n      const data = JSON.parse(ev.newValue);\n      if (data) propagateLocally(data.changedParts);\n    }\n  });\n  const swContainer = self.document && navigator.serviceWorker;\n\n  if (swContainer) {\n    swContainer.addEventListener('message', propagateMessageLocally);\n  }\n}\n\nfunction propagateMessageLocally({\n  data\n}) {\n  if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {\n    propagateLocally(data.changedParts);\n  }\n}\n\nDexiePromise.rejectionMapper = mapError;\nsetDebug(debug, dexieStackFrameFilter);\nexport { Dexie$1 as Dexie, RangeSet, Dexie$1 as default, liveQuery, mergeRanges, rangesOverlap };","map":{"version":3,"sources":["/home/kyle/projects/hockey-engine/node_modules/dexie/dist/modern/dexie.mjs"],"names":["_global","globalThis","self","window","global","keys","Object","isArray","Array","Promise","extend","obj","extension","forEach","key","getProto","getPrototypeOf","_hasOwn","hasOwnProperty","hasOwn","prop","call","props","proto","Reflect","ownKeys","setProp","defineProperty","functionOrGetSet","options","get","set","configurable","value","writable","derive","Child","from","Parent","prototype","create","bind","getOwnPropertyDescriptor","getPropertyDescriptor","pd","_slice","slice","args","start","end","override","origFunc","overridedFactory","assert","b","Error","asap$1","fn","setImmediate","setTimeout","arrayToObject","array","extractor","reduce","result","item","i","nameAndValue","tryCatch","onerror","apply","ex","getByKeyPath","keyPath","rv","l","length","val","push","period","indexOf","innerObj","substr","undefined","setByKeyPath","isFrozen","currentKeyPath","remainingKeyPath","isNaN","parseInt","splice","delByKeyPath","map","kp","shallowClone","m","concat","flatten","a","intrinsicTypeNames","split","num","t","filter","intrinsicTypes","x","circularRefs","deepClone","any","WeakMap","innerDeepClone","constructor","toString","toStringTag","o","iteratorSymbol","Symbol","iterator","getIteratorOf","NO_CHAR_ARRAY","getArrayOf","arrayLike","it","arguments","next","done","isAsyncFunction","debug","location","test","href","setDebug","libraryFilter","NEEDS_THROW_FOR_STACK","stack","getErrorWithStack","e","prettyStack","exception","numIgnoredFrames","name","message","frame","join","dexieErrorNames","idbDomErrorNames","errorList","defaultTexts","VersionChanged","DatabaseClosed","Abort","TransactionInactive","MissingAPI","DexieError","msg","_e","_stack","getMultiErrorMessage","failures","v","s","ModifyError","successCount","failedKeys","BulkError","pos","failuresByPos","errnames","BaseException","exceptions","fullName","msgOrInner","inner","Syntax","SyntaxError","Type","TypeError","Range","RangeError","exceptionMap","mapError","domError","fullNameExceptions","nop","mirror","pureFunctionChain","f1","f2","callBoth","on1","on2","hookCreatingChain","res","onsuccess","res2","hookDeletingChain","hookUpdatingChain","modifications","reverseStoppableEventChain","promisableChain","then","thiz","INTERNAL","LONG_STACKS_CLIP_LIMIT","MAX_LONG_STACKS","ZONE_ECHO_LIMIT","resolvedNativePromise","nativePromiseProto","resolvedGlobalPromise","globalP","resolve","crypto","subtle","nativeP","digest","Uint8Array","nativePromiseThen","NativePromise","patchGlobalPromise","stack_being_generated","schedulePhysicalTick","physicalTick","MutationObserver","hiddenDiv","document","createElement","observe","attributes","setAttribute","asap","callback","microtickQueue","needsNewPhysicalTick","isOutsideMicroTick","unhandledErrors","rejectingErrors","currentFulfiller","rejectionMapper","globalPSD","id","ref","unhandleds","onunhandled","globalError","pgp","env","finalize","uh","PSD","numScheduledCalls","tickFinalizers","DexiePromise","_listeners","onuncatched","_lib","psd","_PSD","_stackHolder","_prev","_numPrev","_state","_value","handleRejection","executePromiseTask","thenProp","microTaskId","totalEchoes","onFulfilled","onRejected","possibleAwait","cleanup","decrementExpectedAwaits","reject","propagateToListener","Listener","nativeAwaitCompatibleWrap","linkToPreviousPromise","_then","catch","type","handler","err","PromiseReject","finally","onFinally","stacks","getStack","timeout","ms","Infinity","handle","Timeout","clearTimeout","snapShot","zone","all","values","onPossibleParallellAsync","remaining","race","newPSD","newScope","usePSD","scheduler","follow","zoneProps","run_at_end_of_this_or_next_physical_tick","allSettled","possiblePromises","results","p","status","reason","AggregateError","failure","promise","shouldExecuteTick","beginMicroTickScope","propagateAllListeners","endMicroTickScope","_promise","origProp","addPossiblyUnhandledError","listeners","len","finalizePhysicalTick","listener","cb","callListener","ret","markErrorAsHandled","limit","errorName","prev","numPrev","wasRootExec","callbacks","unhandledErrs","finalizers","finalizer","some","wrap","errorCatcher","outerScope","switchToZone","task","awaits","echoes","taskCounter","zoneStack","zoneEchoes","zone_id_counter","a1","a2","parent","globalEnv","PromiseProp","nthen","getPatchedPromiseThen","gthen","incrementExpectedAwaits","possiblePromise","rejection","zoneEnterEcho","targetZone","zoneLeaveEcho","pop","bEnteringZone","currentZone","enqueueNativeMicroTask","GlobalPromise","targetEnv","a3","job","outerZone","origThen","onResolved","UNHANDLEDREJECTION","event","eventData","createEvent","initEvent","CustomEvent","detail","dispatchEvent","PromiseRejectionEvent","onunhandledrejection","_","defaultPrevented","console","warn","tempTransaction","db","mode","storeNames","idbdb","openComplete","letThrough","_vip","dbOpenError","isBeingOpened","_options","autoOpen","open","dbReadyPromise","trans","_createTransaction","_dbSchema","_completion","DEXIE_VERSION","maxString","String","fromCharCode","minKey","INVALID_KEY_ARGUMENT","STRING_EXPECTED","connections","isIEOrEdge","navigator","userAgent","hasIEDeleteObjectStoreBug","hangsOnDeleteLargeKeyRange","dexieStackFrameFilter","DBNAMES_DB","READONLY","READWRITE","combine","filter1","filter2","AnyRange","lower","lowerOpen","upper","upperOpen","workaroundForUndefinedPrimKey","Table","_trans","writeLocked","_tx","tableName","checkTableInTransaction","schema","NotFound","idbtrans","transless","keyOrCrit","where","first","core","hook","reading","fire","indexOrCrit","WhereClause","keyPaths","equals","compoundIndex","indexes","primKey","ix","compound","every","_maxKey","JSON","stringify","idxByName","idb","_deps","indexedDB","cmp","idx","filterFunction","prevIndex","prevFilterFn","index","multi","toCollection","and","count","thenShortcut","offset","numRows","each","toArray","Collection","orderBy","reverse","mapToClass","mappedClass","readHook","unsubscribe","defineClass","Class","content","add","auto","objToAdd","mutate","numFailures","lastResult","update","keyOrObject","InvalidArgument","_a","modify","put","delete","clear","range","bulkGet","getMany","bulkAdd","objects","keysOrOptions","wantResults","allKeys","numObjects","objectsToAdd","bulkPut","objectsToPut","bulkDelete","numKeys","Events","ctx","evs","eventName","subscriber","subscribe","addEventType","chainFunction","defaultFunction","addConfiguredEvents","context","subscribers","cfg","fireEvent","makeClassConstructor","createTableConstructor","tableSchema","_allTables","isPlainKeyRange","ignoreLimitFilter","algorithm","or","justLimit","replayFilter","addFilter","addReplayFilter","factory","isLimitFilter","curr","addMatchFilter","isMatch","getIndexOrStore","coreSchema","isPrimKey","primaryKey","getIndexByKeyPath","Schema","openCursor","coreTable","keysOnly","dir","unique","query","iter","coreTrans","iterate","valueMapper","union","cursor","advance","stop","fail","_iterate","cursorPromise","mappedFn","c","wrappedFn","continue","advancer","ta","tb","NaN","compareUint8Arrays","getUint8Array","compareArrays","al","bl","ArrayBuffer","isView","tsTag","buffer","byteOffset","byteLength","_read","_ctx","error","table","_write","_addAlgorithm","clone","raw","Math","min","sortBy","parts","lastPart","lastIndex","getval","order","sorter","aVal","bVal","sort","offsetLeft","rowsLeft","until","bIncludeStopEntry","last","indexName","_ondirectionchange","desc","eachKey","eachUniqueKey","eachPrimaryKey","primaryKeys","uniqueKeys","firstKey","lastKey","distinct","strKey","found","changes","modifyer","anythingModified","outbound","extractKey","modifyChunkSize","totalFailures","applyMutateResult","expectedCount","nextChunk","cache","addValues","putValues","putKeys","deleteKeys","origValue","criteria","deleteCallback","changeSpec","coreRange","createCollectionConstructor","whereClause","keyRangeGenerator","keyRange","whereCtx","readingHook","simpleCompare","simpleCompareReverse","collectionOrWhereClause","T","collection","emptyCollection","rangeEqual","upperFactory","toUpperCase","toLowerCase","lowerFactory","nextCasing","lowerKey","upperNeedle","lowerNeedle","llp","lwrKeyChar","addIgnoreCaseAlgorithm","match","needles","suffix","compare","upperNeedles","lowerNeedles","direction","nextKeySuffix","needlesLen","initDirection","needleBounds","needle","nb","createRange","firstPossibleNeedle","lowestPossibleCasing","casing","between","includeLower","includeUpper","_cmp","above","aboveOrEqual","below","belowOrEqual","startsWith","str","startsWithIgnoreCase","equalsIgnoreCase","anyOfIgnoreCase","startsWithAnyOfIgnoreCase","n","anyOf","_ascending","_descending","notEqual","inAnyRange","includeLowers","includeUppers","noneOf","ranges","ascending","descending","_min","max","_max","addRange","newRange","sortDirection","rangeSorter","rangePos","keyIsBeyondCurrentEntry","keyIsBeforeCurrentEntry","keyWithinCurrentRange","checkKey","startsWithAnyOf","createWhereClauseConstructor","orCollection","_IDBKeyRange","IDBKeyRange","eventRejectHandler","preventDefault","target","stopPropagation","DEXIE_STORAGE_MUTATED_EVENT_NAME","STORAGE_MUTATED_DOM_EVENT_NAME","globalEvents","Transaction","_lock","_reculock","lockOwnerFor","_unlock","_blockedFuncs","_locked","fnAndPSD","shift","OpenFailed","active","transaction","durability","chromeTransactionDurability","ev","_reject","onabort","on","oncomplete","_resolve","storagemutated","bWriteLock","ReadOnly","_root","waitFor","promiseLike","root","_waitingFor","_waitingQueue","store","objectStore","spin","_spinCount","currentWaitPromise","abort","memoizedTables","_memoizedTables","transactionBoundTable","createTransactionConstructor","dbschema","complete","wasActive","createIndexSpec","src","nameFromKeyPath","createTableSchema","safariMultiStoreFix","getMaxKey","IdbKeyRange","only","getKeyExtractor","getSinglePathKeyExtractor","arrayify","_id_counter","getKeyPathAlias","createDBCore","tmpTrans","extractSchema","tables","objectStoreNames","autoIncrement","indexByKeyPath","isPrimaryKey","indexNames","multiEntry","hasGetAll","makeIDBKeyRange","idbRange","upperBound","lowerBound","bound","createDbCoreTable","isAddOrPut","req","reqs","errorHandler","args1","args2","source","openKeyCursor","___id","_cursorContinue","_cursorContinuePrimaryKey","continuePrimaryKey","_cursorAdvance","doThrowCursorIsNotStarted","doThrowCursorIsStopped","gotOne","iterationPromise","resolveIteration","rejectIteration","guardedCallback","request","nonInfinitLimit","idbKeyRange","getAll","getAllKeys","keyCount","callbackCount","successHandler","_pos","tableMap","MIN_KEY","MAX_KEY","createMiddlewareStack","stackImpl","middlewares","down","createMiddlewareStacks","dbcore","generateMiddlewareStacks","_novip","_middlewares","tbl","setApiOnPlace","objs","tableNames","propDesc","enumerable","removeTablesApi","lowerVersionFirst","_cfg","version","runUpgraders","oldVersion","idbUpgradeTrans","globalSchema","_storeNames","rejectTransaction","createTable","populate","updateTablesAndIndexes","queue","versions","_versions","buildGlobalSchema","anyContentUpgraderHasRun","versToRun","oldSchema","newSchema","adjustToExistingIndexNames","diff","getSchemaDiff","tuple","change","recreate","Upgrade","addIndex","deleteIndex","del","idxName","contentUpgrade","upgradeSchema","contentUpgradeIsAsync","returnValue","promiseFollowed","decrementor","deleteRemovedTables","runQueue","createMissingTables","oldDef","newDef","def","oldIndexes","newIndexes","oldIdx","newIdx","createObjectStore","contains","storeName","deleteObjectStore","createIndex","dbStoreNames","j","idbindex","readGlobalSchema","verno","verifyInstalledSchema","installedSchema","ch","_hasGetAll","dexieName","indexSpec","WorkerGlobalScope","parseIndexSyntax","primKeyAndIndexes","indexNum","trim","replace","Version","_parseStoresSpec","stores","outSchema","storesSource","storesSpec","upgrade","upgradeFunction","createVersionConstructor","versionNumber","getDbNamesTable","dbNamesDB","Dexie$1","addons","dbnames","hasDatabasesNative","databases","getDatabaseNames","infos","info","_onDatabaseCreated","_onDatabaseDeleted","vip","idbReady","isSafari","userAgentData","intervalId","tryIdb","setInterval","clearInterval","dexieOpen","state","openCanceller","throwIfCancelled","resolveDbReady","dbReadyResolve","upgradeTransaction","wasCreated","dbName","autoSchema","round","onblocked","_fireOnBlocked","onupgradeneeded","allowEmptyDB","close","delreq","deleteDatabase","NoSuchDatabase","oldVer","pow","onversionchange","vcFired","onclose","onReadyBeingFired","ready","fireRemainders","remainders","_close","awaitIterator","callNext","doThrow","throw","onSuccess","step","onError","getNext","extractTransactionArgs","_tableArgs_","scopeFunc","enterTransactionScope","parentTransaction","scopeFuncIsAsync","PrematureCommit","pad","createVirtualIndexMiddleware","indexLookup","allVirtualIndexes","addVirtualIndexes","keyTail","lowLevelIndex","keyPathAlias","indexList","keyLength","isVirtual","virtualIndex","virtualKeyPath","findBestIndex","translateRange","translateRequest","createVirtualCursor","_continue","virtualCursor","virtualIndexMiddleware","level","getObjectDiff","prfx","ap","bp","apTypeName","bpTypeName","getEffectiveKeys","hooksMiddleware","downCore","downTable","tableMiddleware","dxTrans","deleting","creating","updating","addPutOrDelete","deleteRange","getExistingValues","existingValues","contexts","existingValue","generatedPrimaryKey","objectDiff","additionalChanges","requestedValue","deleteNextChunk","effectiveKeys","getFromTransactionCache","cacheExistingValuesMiddleware","cachedResult","isEmptyRange","node","RangeSet","fromOrTree","to","d","rangeSet","mergeRanges","addKey","addKeys","getRangeSetIterator","left","right","r","rebalance","rightWasCutOff","newSet","_addRangeSet","rangesOverlap","rangeSet1","rangeSet2","i1","nextResult1","i2","nextResult2","keyProvided","up","_b","rootClone","oldRootRight","computeDepth","observabilityMiddleware","FULL_RANGE","tableClone","mutatedParts","getRangeSet","part","pkRangeSet","delsRangeSet","newObjs","oldCache","oldObjs","trackAffectedIndexes","getRange","readSubscribers","method","subscr","queriedIndex","queriedRanges","keysPromise","resultingKeys","pKeys","wantValues","pkey","addAffectedIndex","addKeyOrKeys","oldKey","newKey","deps","dependencies","cancelOpen","bSticky","newVersion","use","addon","versionInstance","_whenReady","unuse","mw","hasArguments","doDelete","backendDB","isOpen","hasBeenClosed","hasFailed","dynamicallyOpened","_transaction","onlyIfCompatible","idbMode","SubTransaction","enterTransaction","InvalidTable","symbolObservable","observable","Observable","_subscribe","extendObservabilitySet","liveQuery","querier","observer","execute","exec","closed","accumMuts","currentObs","subscription","mutationListener","querying","startedListening","shouldNotify","doQuery","domDeps","mozIndexedDB","webkitIndexedDB","msIndexedDB","webkitIDBKeyRange","Dexie","databaseName","exists","ignoreTransaction","async","generatorFn","spawn","currentTransaction","promiseOrFunction","optionalTimeout","semVer","maxKey","addEventListener","updatedParts","propagatingLocally","initCustomEvent","propagateLocally","updateParts","wasMe","BroadcastChannel","bc","changedParts","postMessage","onmessage","data","localStorage","setItem","trig","random","matchAll","includeUncontrolled","client","parse","newValue","swContainer","serviceWorker","propagateMessageLocally","default"],"mappings":"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","sourcesContent":["/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 3.2.0, Thu Nov 18 2021\n *\n * http://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\n \nconst _global = typeof globalThis !== 'undefined' ? globalThis :\n    typeof self !== 'undefined' ? self :\n        typeof window !== 'undefined' ? window :\n            global;\n\nconst keys = Object.keys;\nconst isArray = Array.isArray;\nif (typeof Promise !== 'undefined' && !_global.Promise) {\n    _global.Promise = Promise;\n}\nfunction extend(obj, extension) {\n    if (typeof extension !== 'object')\n        return obj;\n    keys(extension).forEach(function (key) {\n        obj[key] = extension[key];\n    });\n    return obj;\n}\nconst getProto = Object.getPrototypeOf;\nconst _hasOwn = {}.hasOwnProperty;\nfunction hasOwn(obj, prop) {\n    return _hasOwn.call(obj, prop);\n}\nfunction props(proto, extension) {\n    if (typeof extension === 'function')\n        extension = extension(getProto(proto));\n    (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(key => {\n        setProp(proto, key, extension[key]);\n    });\n}\nconst defineProperty = Object.defineProperty;\nfunction setProp(obj, prop, functionOrGetSet, options) {\n    defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ?\n        { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :\n        { value: functionOrGetSet, configurable: true, writable: true }, options));\n}\nfunction derive(Child) {\n    return {\n        from: function (Parent) {\n            Child.prototype = Object.create(Parent.prototype);\n            setProp(Child.prototype, \"constructor\", Child);\n            return {\n                extend: props.bind(null, Child.prototype)\n            };\n        }\n    };\n}\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nfunction getPropertyDescriptor(obj, prop) {\n    const pd = getOwnPropertyDescriptor(obj, prop);\n    let proto;\n    return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n}\nconst _slice = [].slice;\nfunction slice(args, start, end) {\n    return _slice.call(args, start, end);\n}\nfunction override(origFunc, overridedFactory) {\n    return overridedFactory(origFunc);\n}\nfunction assert(b) {\n    if (!b)\n        throw new Error(\"Assertion Failed\");\n}\nfunction asap$1(fn) {\n    if (_global.setImmediate)\n        setImmediate(fn);\n    else\n        setTimeout(fn, 0);\n}\nfunction arrayToObject(array, extractor) {\n    return array.reduce((result, item, i) => {\n        var nameAndValue = extractor(item, i);\n        if (nameAndValue)\n            result[nameAndValue[0]] = nameAndValue[1];\n        return result;\n    }, {});\n}\nfunction tryCatch(fn, onerror, args) {\n    try {\n        fn.apply(null, args);\n    }\n    catch (ex) {\n        onerror && onerror(ex);\n    }\n}\nfunction getByKeyPath(obj, keyPath) {\n    if (hasOwn(obj, keyPath))\n        return obj[keyPath];\n    if (!keyPath)\n        return obj;\n    if (typeof keyPath !== 'string') {\n        var rv = [];\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            var val = getByKeyPath(obj, keyPath[i]);\n            rv.push(val);\n        }\n        return rv;\n    }\n    var period = keyPath.indexOf('.');\n    if (period !== -1) {\n        var innerObj = obj[keyPath.substr(0, period)];\n        return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n    }\n    return undefined;\n}\nfunction setByKeyPath(obj, keyPath, value) {\n    if (!obj || keyPath === undefined)\n        return;\n    if ('isFrozen' in Object && Object.isFrozen(obj))\n        return;\n    if (typeof keyPath !== 'string' && 'length' in keyPath) {\n        assert(typeof value !== 'string' && 'length' in value);\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            setByKeyPath(obj, keyPath[i], value[i]);\n        }\n    }\n    else {\n        var period = keyPath.indexOf('.');\n        if (period !== -1) {\n            var currentKeyPath = keyPath.substr(0, period);\n            var remainingKeyPath = keyPath.substr(period + 1);\n            if (remainingKeyPath === \"\")\n                if (value === undefined) {\n                    if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))\n                        obj.splice(currentKeyPath, 1);\n                    else\n                        delete obj[currentKeyPath];\n                }\n                else\n                    obj[currentKeyPath] = value;\n            else {\n                var innerObj = obj[currentKeyPath];\n                if (!innerObj)\n                    innerObj = (obj[currentKeyPath] = {});\n                setByKeyPath(innerObj, remainingKeyPath, value);\n            }\n        }\n        else {\n            if (value === undefined) {\n                if (isArray(obj) && !isNaN(parseInt(keyPath)))\n                    obj.splice(keyPath, 1);\n                else\n                    delete obj[keyPath];\n            }\n            else\n                obj[keyPath] = value;\n        }\n    }\n}\nfunction delByKeyPath(obj, keyPath) {\n    if (typeof keyPath === 'string')\n        setByKeyPath(obj, keyPath, undefined);\n    else if ('length' in keyPath)\n        [].map.call(keyPath, function (kp) {\n            setByKeyPath(obj, kp, undefined);\n        });\n}\nfunction shallowClone(obj) {\n    var rv = {};\n    for (var m in obj) {\n        if (hasOwn(obj, m))\n            rv[m] = obj[m];\n    }\n    return rv;\n}\nconst concat = [].concat;\nfunction flatten(a) {\n    return concat.apply([], a);\n}\nconst intrinsicTypeNames = \"Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\"\n    .split(',').concat(flatten([8, 16, 32, 64].map(num => [\"Int\", \"Uint\", \"Float\"].map(t => t + num + \"Array\")))).filter(t => _global[t]);\nconst intrinsicTypes = intrinsicTypeNames.map(t => _global[t]);\narrayToObject(intrinsicTypeNames, x => [x, true]);\nlet circularRefs = null;\nfunction deepClone(any) {\n    circularRefs = typeof WeakMap !== 'undefined' && new WeakMap();\n    const rv = innerDeepClone(any);\n    circularRefs = null;\n    return rv;\n}\nfunction innerDeepClone(any) {\n    if (!any || typeof any !== 'object')\n        return any;\n    let rv = circularRefs && circularRefs.get(any);\n    if (rv)\n        return rv;\n    if (isArray(any)) {\n        rv = [];\n        circularRefs && circularRefs.set(any, rv);\n        for (var i = 0, l = any.length; i < l; ++i) {\n            rv.push(innerDeepClone(any[i]));\n        }\n    }\n    else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\n        rv = any;\n    }\n    else {\n        const proto = getProto(any);\n        rv = proto === Object.prototype ? {} : Object.create(proto);\n        circularRefs && circularRefs.set(any, rv);\n        for (var prop in any) {\n            if (hasOwn(any, prop)) {\n                rv[prop] = innerDeepClone(any[prop]);\n            }\n        }\n    }\n    return rv;\n}\nconst { toString } = {};\nfunction toStringTag(o) {\n    return toString.call(o).slice(8, -1);\n}\nconst iteratorSymbol = typeof Symbol !== 'undefined' ?\n    Symbol.iterator :\n    '@@iterator';\nconst getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n    var i;\n    return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n} : function () { return null; };\nconst NO_CHAR_ARRAY = {};\nfunction getArrayOf(arrayLike) {\n    var i, a, x, it;\n    if (arguments.length === 1) {\n        if (isArray(arrayLike))\n            return arrayLike.slice();\n        if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')\n            return [arrayLike];\n        if ((it = getIteratorOf(arrayLike))) {\n            a = [];\n            while ((x = it.next()), !x.done)\n                a.push(x.value);\n            return a;\n        }\n        if (arrayLike == null)\n            return [arrayLike];\n        i = arrayLike.length;\n        if (typeof i === 'number') {\n            a = new Array(i);\n            while (i--)\n                a[i] = arrayLike[i];\n            return a;\n        }\n        return [arrayLike];\n    }\n    i = arguments.length;\n    a = new Array(i);\n    while (i--)\n        a[i] = arguments[i];\n    return a;\n}\nconst isAsyncFunction = typeof Symbol !== 'undefined'\n    ? (fn) => fn[Symbol.toStringTag] === 'AsyncFunction'\n    : () => false;\n\nvar debug = typeof location !== 'undefined' &&\n    /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\nfunction setDebug(value, filter) {\n    debug = value;\n    libraryFilter = filter;\n}\nvar libraryFilter = () => true;\nconst NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\nfunction getErrorWithStack() {\n    if (NEEDS_THROW_FOR_STACK)\n        try {\n            getErrorWithStack.arguments;\n            throw new Error();\n        }\n        catch (e) {\n            return e;\n        }\n    return new Error();\n}\nfunction prettyStack(exception, numIgnoredFrames) {\n    var stack = exception.stack;\n    if (!stack)\n        return \"\";\n    numIgnoredFrames = (numIgnoredFrames || 0);\n    if (stack.indexOf(exception.name) === 0)\n        numIgnoredFrames += (exception.name + exception.message).split('\\n').length;\n    return stack.split('\\n')\n        .slice(numIgnoredFrames)\n        .filter(libraryFilter)\n        .map(frame => \"\\n\" + frame)\n        .join('');\n}\n\nvar dexieErrorNames = [\n    'Modify',\n    'Bulk',\n    'OpenFailed',\n    'VersionChange',\n    'Schema',\n    'Upgrade',\n    'InvalidTable',\n    'MissingAPI',\n    'NoSuchDatabase',\n    'InvalidArgument',\n    'SubTransaction',\n    'Unsupported',\n    'Internal',\n    'DatabaseClosed',\n    'PrematureCommit',\n    'ForeignAwait'\n];\nvar idbDomErrorNames = [\n    'Unknown',\n    'Constraint',\n    'Data',\n    'TransactionInactive',\n    'ReadOnly',\n    'Version',\n    'NotFound',\n    'InvalidState',\n    'InvalidAccess',\n    'Abort',\n    'Timeout',\n    'QuotaExceeded',\n    'Syntax',\n    'DataClone'\n];\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\nvar defaultTexts = {\n    VersionChanged: \"Database version changed by other database connection\",\n    DatabaseClosed: \"Database has been closed\",\n    Abort: \"Transaction aborted\",\n    TransactionInactive: \"Transaction has already completed or failed\",\n    MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n};\nfunction DexieError(name, msg) {\n    this._e = getErrorWithStack();\n    this.name = name;\n    this.message = msg;\n}\nderive(DexieError).from(Error).extend({\n    stack: {\n        get: function () {\n            return this._stack ||\n                (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n        }\n    },\n    toString: function () { return this.name + \": \" + this.message; }\n});\nfunction getMultiErrorMessage(msg, failures) {\n    return msg + \". Errors: \" + Object.keys(failures)\n        .map(key => failures[key].toString())\n        .filter((v, i, s) => s.indexOf(v) === i)\n        .join('\\n');\n}\nfunction ModifyError(msg, failures, successCount, failedKeys) {\n    this._e = getErrorWithStack();\n    this.failures = failures;\n    this.failedKeys = failedKeys;\n    this.successCount = successCount;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(ModifyError).from(DexieError);\nfunction BulkError(msg, failures) {\n    this._e = getErrorWithStack();\n    this.name = \"BulkError\";\n    this.failures = Object.keys(failures).map(pos => failures[pos]);\n    this.failuresByPos = failures;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(BulkError).from(DexieError);\nvar errnames = errorList.reduce((obj, name) => (obj[name] = name + \"Error\", obj), {});\nconst BaseException = DexieError;\nvar exceptions = errorList.reduce((obj, name) => {\n    var fullName = name + \"Error\";\n    function DexieError(msgOrInner, inner) {\n        this._e = getErrorWithStack();\n        this.name = fullName;\n        if (!msgOrInner) {\n            this.message = defaultTexts[name] || fullName;\n            this.inner = null;\n        }\n        else if (typeof msgOrInner === 'string') {\n            this.message = `${msgOrInner}${!inner ? '' : '\\n ' + inner}`;\n            this.inner = inner || null;\n        }\n        else if (typeof msgOrInner === 'object') {\n            this.message = `${msgOrInner.name} ${msgOrInner.message}`;\n            this.inner = msgOrInner;\n        }\n    }\n    derive(DexieError).from(BaseException);\n    obj[name] = DexieError;\n    return obj;\n}, {});\nexceptions.Syntax = SyntaxError;\nexceptions.Type = TypeError;\nexceptions.Range = RangeError;\nvar exceptionMap = idbDomErrorNames.reduce((obj, name) => {\n    obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfunction mapError(domError, message) {\n    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\n        return domError;\n    var rv = new exceptionMap[domError.name](message || domError.message, domError);\n    if (\"stack\" in domError) {\n        setProp(rv, \"stack\", { get: function () {\n                return this.inner.stack;\n            } });\n    }\n    return rv;\n}\nvar fullNameExceptions = errorList.reduce((obj, name) => {\n    if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1)\n        obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfullNameExceptions.ModifyError = ModifyError;\nfullNameExceptions.DexieError = DexieError;\nfullNameExceptions.BulkError = BulkError;\n\nfunction nop() { }\nfunction mirror(val) { return val; }\nfunction pureFunctionChain(f1, f2) {\n    if (f1 == null || f1 === mirror)\n        return f2;\n    return function (val) {\n        return f2(f1(val));\n    };\n}\nfunction callBoth(on1, on2) {\n    return function () {\n        on1.apply(this, arguments);\n        on2.apply(this, arguments);\n    };\n}\nfunction hookCreatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res !== undefined)\n            arguments[0] = res;\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res2 !== undefined ? res2 : res;\n    };\n}\nfunction hookDeletingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        f1.apply(this, arguments);\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = this.onerror = null;\n        f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    };\n}\nfunction hookUpdatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function (modifications) {\n        var res = f1.apply(this, arguments);\n        extend(modifications, res);\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res === undefined ?\n            (res2 === undefined ? undefined : res2) :\n            (extend(res, res2));\n    };\n}\nfunction reverseStoppableEventChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        if (f2.apply(this, arguments) === false)\n            return false;\n        return f1.apply(this, arguments);\n    };\n}\nfunction promisableChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res && typeof res.then === 'function') {\n            var thiz = this, i = arguments.length, args = new Array(i);\n            while (i--)\n                args[i] = arguments[i];\n            return res.then(function () {\n                return f2.apply(thiz, args);\n            });\n        }\n        return f2.apply(this, arguments);\n    };\n}\n\nvar INTERNAL = {};\nconst LONG_STACKS_CLIP_LIMIT = 100,\nMAX_LONG_STACKS = 20, ZONE_ECHO_LIMIT = 100, [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === 'undefined' ?\n    [] :\n    (() => {\n        let globalP = Promise.resolve();\n        if (typeof crypto === 'undefined' || !crypto.subtle)\n            return [globalP, getProto(globalP), globalP];\n        const nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n        return [\n            nativeP,\n            getProto(nativeP),\n            globalP\n        ];\n    })(), nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\nconst NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\nconst patchGlobalPromise = !!resolvedGlobalPromise;\nvar stack_being_generated = false;\nvar schedulePhysicalTick = resolvedGlobalPromise ?\n    () => { resolvedGlobalPromise.then(physicalTick); }\n    :\n        _global.setImmediate ?\n            setImmediate.bind(null, physicalTick) :\n            _global.MutationObserver ?\n                () => {\n                    var hiddenDiv = document.createElement(\"div\");\n                    (new MutationObserver(() => {\n                        physicalTick();\n                        hiddenDiv = null;\n                    })).observe(hiddenDiv, { attributes: true });\n                    hiddenDiv.setAttribute('i', '1');\n                } :\n                () => { setTimeout(physicalTick, 0); };\nvar asap = function (callback, args) {\n    microtickQueue.push([callback, args]);\n    if (needsNewPhysicalTick) {\n        schedulePhysicalTick();\n        needsNewPhysicalTick = false;\n    }\n};\nvar isOutsideMicroTick = true,\nneedsNewPhysicalTick = true,\nunhandledErrors = [],\nrejectingErrors = [],\ncurrentFulfiller = null, rejectionMapper = mirror;\nvar globalPSD = {\n    id: 'global',\n    global: true,\n    ref: 0,\n    unhandleds: [],\n    onunhandled: globalError,\n    pgp: false,\n    env: {},\n    finalize: function () {\n        this.unhandleds.forEach(uh => {\n            try {\n                globalError(uh[0], uh[1]);\n            }\n            catch (e) { }\n        });\n    }\n};\nvar PSD = globalPSD;\nvar microtickQueue = [];\nvar numScheduledCalls = 0;\nvar tickFinalizers = [];\nfunction DexiePromise(fn) {\n    if (typeof this !== 'object')\n        throw new TypeError('Promises must be constructed via new');\n    this._listeners = [];\n    this.onuncatched = nop;\n    this._lib = false;\n    var psd = (this._PSD = PSD);\n    if (debug) {\n        this._stackHolder = getErrorWithStack();\n        this._prev = null;\n        this._numPrev = 0;\n    }\n    if (typeof fn !== 'function') {\n        if (fn !== INTERNAL)\n            throw new TypeError('Not a function');\n        this._state = arguments[1];\n        this._value = arguments[2];\n        if (this._state === false)\n            handleRejection(this, this._value);\n        return;\n    }\n    this._state = null;\n    this._value = null;\n    ++psd.ref;\n    executePromiseTask(this, fn);\n}\nconst thenProp = {\n    get: function () {\n        var psd = PSD, microTaskId = totalEchoes;\n        function then(onFulfilled, onRejected) {\n            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n            const cleanup = possibleAwait && !decrementExpectedAwaits();\n            var rv = new DexiePromise((resolve, reject) => {\n                propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n            });\n            debug && linkToPreviousPromise(rv, this);\n            return rv;\n        }\n        then.prototype = INTERNAL;\n        return then;\n    },\n    set: function (value) {\n        setProp(this, 'then', value && value.prototype === INTERNAL ?\n            thenProp :\n            {\n                get: function () {\n                    return value;\n                },\n                set: thenProp.set\n            });\n    }\n};\nprops(DexiePromise.prototype, {\n    then: thenProp,\n    _then: function (onFulfilled, onRejected) {\n        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n    },\n    catch: function (onRejected) {\n        if (arguments.length === 1)\n            return this.then(null, onRejected);\n        var type = arguments[0], handler = arguments[1];\n        return typeof type === 'function' ? this.then(null, err =>\n        err instanceof type ? handler(err) : PromiseReject(err))\n            : this.then(null, err =>\n            err && err.name === type ? handler(err) : PromiseReject(err));\n    },\n    finally: function (onFinally) {\n        return this.then(value => {\n            onFinally();\n            return value;\n        }, err => {\n            onFinally();\n            return PromiseReject(err);\n        });\n    },\n    stack: {\n        get: function () {\n            if (this._stack)\n                return this._stack;\n            try {\n                stack_being_generated = true;\n                var stacks = getStack(this, [], MAX_LONG_STACKS);\n                var stack = stacks.join(\"\\nFrom previous: \");\n                if (this._state !== null)\n                    this._stack = stack;\n                return stack;\n            }\n            finally {\n                stack_being_generated = false;\n            }\n        }\n    },\n    timeout: function (ms, msg) {\n        return ms < Infinity ?\n            new DexiePromise((resolve, reject) => {\n                var handle = setTimeout(() => reject(new exceptions.Timeout(msg)), ms);\n                this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n            }) : this;\n    }\n});\nif (typeof Symbol !== 'undefined' && Symbol.toStringTag)\n    setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\nglobalPSD.env = snapShot();\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.resolve = resolve;\n    this.reject = reject;\n    this.psd = zone;\n}\nprops(DexiePromise, {\n    all: function () {\n        var values = getArrayOf.apply(null, arguments)\n            .map(onPossibleParallellAsync);\n        return new DexiePromise(function (resolve, reject) {\n            if (values.length === 0)\n                resolve([]);\n            var remaining = values.length;\n            values.forEach((a, i) => DexiePromise.resolve(a).then(x => {\n                values[i] = x;\n                if (!--remaining)\n                    resolve(values);\n            }, reject));\n        });\n    },\n    resolve: value => {\n        if (value instanceof DexiePromise)\n            return value;\n        if (value && typeof value.then === 'function')\n            return new DexiePromise((resolve, reject) => {\n                value.then(resolve, reject);\n            });\n        var rv = new DexiePromise(INTERNAL, true, value);\n        linkToPreviousPromise(rv, currentFulfiller);\n        return rv;\n    },\n    reject: PromiseReject,\n    race: function () {\n        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve, reject) => {\n            values.map(value => DexiePromise.resolve(value).then(resolve, reject));\n        });\n    },\n    PSD: {\n        get: () => PSD,\n        set: value => PSD = value\n    },\n    totalEchoes: { get: () => totalEchoes },\n    newPSD: newScope,\n    usePSD: usePSD,\n    scheduler: {\n        get: () => asap,\n        set: value => { asap = value; }\n    },\n    rejectionMapper: {\n        get: () => rejectionMapper,\n        set: value => { rejectionMapper = value; }\n    },\n    follow: (fn, zoneProps) => {\n        return new DexiePromise((resolve, reject) => {\n            return newScope((resolve, reject) => {\n                var psd = PSD;\n                psd.unhandleds = [];\n                psd.onunhandled = reject;\n                psd.finalize = callBoth(function () {\n                    run_at_end_of_this_or_next_physical_tick(() => {\n                        this.unhandleds.length === 0 ? resolve() : reject(this.unhandleds[0]);\n                    });\n                }, psd.finalize);\n                fn();\n            }, zoneProps, resolve, reject);\n        });\n    }\n});\nif (NativePromise) {\n    if (NativePromise.allSettled)\n        setProp(DexiePromise, \"allSettled\", function () {\n            const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise(resolve => {\n                if (possiblePromises.length === 0)\n                    resolve([]);\n                let remaining = possiblePromises.length;\n                const results = new Array(remaining);\n                possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => results[i] = { status: \"fulfilled\", value }, reason => results[i] = { status: \"rejected\", reason })\n                    .then(() => --remaining || resolve(results)));\n            });\n        });\n    if (NativePromise.any && typeof AggregateError !== 'undefined')\n        setProp(DexiePromise, \"any\", function () {\n            const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise((resolve, reject) => {\n                if (possiblePromises.length === 0)\n                    reject(new AggregateError([]));\n                let remaining = possiblePromises.length;\n                const failures = new Array(remaining);\n                possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => resolve(value), failure => {\n                    failures[i] = failure;\n                    if (!--remaining)\n                        reject(new AggregateError(failures));\n                }));\n            });\n        });\n}\nfunction executePromiseTask(promise, fn) {\n    try {\n        fn(value => {\n            if (promise._state !== null)\n                return;\n            if (value === promise)\n                throw new TypeError('A promise cannot be resolved with itself.');\n            var shouldExecuteTick = promise._lib && beginMicroTickScope();\n            if (value && typeof value.then === 'function') {\n                executePromiseTask(promise, (resolve, reject) => {\n                    value instanceof DexiePromise ?\n                        value._then(resolve, reject) :\n                        value.then(resolve, reject);\n                });\n            }\n            else {\n                promise._state = true;\n                promise._value = value;\n                propagateAllListeners(promise);\n            }\n            if (shouldExecuteTick)\n                endMicroTickScope();\n        }, handleRejection.bind(null, promise));\n    }\n    catch (ex) {\n        handleRejection(promise, ex);\n    }\n}\nfunction handleRejection(promise, reason) {\n    rejectingErrors.push(reason);\n    if (promise._state !== null)\n        return;\n    var shouldExecuteTick = promise._lib && beginMicroTickScope();\n    reason = rejectionMapper(reason);\n    promise._state = false;\n    promise._value = reason;\n    debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(() => {\n        var origProp = getPropertyDescriptor(reason, \"stack\");\n        reason._promise = promise;\n        setProp(reason, \"stack\", {\n            get: () => stack_being_generated ?\n                origProp && (origProp.get ?\n                    origProp.get.apply(reason) :\n                    origProp.value) :\n                promise.stack\n        });\n    });\n    addPossiblyUnhandledError(promise);\n    propagateAllListeners(promise);\n    if (shouldExecuteTick)\n        endMicroTickScope();\n}\nfunction propagateAllListeners(promise) {\n    var listeners = promise._listeners;\n    promise._listeners = [];\n    for (var i = 0, len = listeners.length; i < len; ++i) {\n        propagateToListener(promise, listeners[i]);\n    }\n    var psd = promise._PSD;\n    --psd.ref || psd.finalize();\n    if (numScheduledCalls === 0) {\n        ++numScheduledCalls;\n        asap(() => {\n            if (--numScheduledCalls === 0)\n                finalizePhysicalTick();\n        }, []);\n    }\n}\nfunction propagateToListener(promise, listener) {\n    if (promise._state === null) {\n        promise._listeners.push(listener);\n        return;\n    }\n    var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n    if (cb === null) {\n        return (promise._state ? listener.resolve : listener.reject)(promise._value);\n    }\n    ++listener.psd.ref;\n    ++numScheduledCalls;\n    asap(callListener, [cb, promise, listener]);\n}\nfunction callListener(cb, promise, listener) {\n    try {\n        currentFulfiller = promise;\n        var ret, value = promise._value;\n        if (promise._state) {\n            ret = cb(value);\n        }\n        else {\n            if (rejectingErrors.length)\n                rejectingErrors = [];\n            ret = cb(value);\n            if (rejectingErrors.indexOf(value) === -1)\n                markErrorAsHandled(promise);\n        }\n        listener.resolve(ret);\n    }\n    catch (e) {\n        listener.reject(e);\n    }\n    finally {\n        currentFulfiller = null;\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n        --listener.psd.ref || listener.psd.finalize();\n    }\n}\nfunction getStack(promise, stacks, limit) {\n    if (stacks.length === limit)\n        return stacks;\n    var stack = \"\";\n    if (promise._state === false) {\n        var failure = promise._value, errorName, message;\n        if (failure != null) {\n            errorName = failure.name || \"Error\";\n            message = failure.message || failure;\n            stack = prettyStack(failure, 0);\n        }\n        else {\n            errorName = failure;\n            message = \"\";\n        }\n        stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n    }\n    if (debug) {\n        stack = prettyStack(promise._stackHolder, 2);\n        if (stack && stacks.indexOf(stack) === -1)\n            stacks.push(stack);\n        if (promise._prev)\n            getStack(promise._prev, stacks, limit);\n    }\n    return stacks;\n}\nfunction linkToPreviousPromise(promise, prev) {\n    var numPrev = prev ? prev._numPrev + 1 : 0;\n    if (numPrev < LONG_STACKS_CLIP_LIMIT) {\n        promise._prev = prev;\n        promise._numPrev = numPrev;\n    }\n}\nfunction physicalTick() {\n    beginMicroTickScope() && endMicroTickScope();\n}\nfunction beginMicroTickScope() {\n    var wasRootExec = isOutsideMicroTick;\n    isOutsideMicroTick = false;\n    needsNewPhysicalTick = false;\n    return wasRootExec;\n}\nfunction endMicroTickScope() {\n    var callbacks, i, l;\n    do {\n        while (microtickQueue.length > 0) {\n            callbacks = microtickQueue;\n            microtickQueue = [];\n            l = callbacks.length;\n            for (i = 0; i < l; ++i) {\n                var item = callbacks[i];\n                item[0].apply(null, item[1]);\n            }\n        }\n    } while (microtickQueue.length > 0);\n    isOutsideMicroTick = true;\n    needsNewPhysicalTick = true;\n}\nfunction finalizePhysicalTick() {\n    var unhandledErrs = unhandledErrors;\n    unhandledErrors = [];\n    unhandledErrs.forEach(p => {\n        p._PSD.onunhandled.call(null, p._value, p);\n    });\n    var finalizers = tickFinalizers.slice(0);\n    var i = finalizers.length;\n    while (i)\n        finalizers[--i]();\n}\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\n    function finalizer() {\n        fn();\n        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n    }\n    tickFinalizers.push(finalizer);\n    ++numScheduledCalls;\n    asap(() => {\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n    }, []);\n}\nfunction addPossiblyUnhandledError(promise) {\n    if (!unhandledErrors.some(p => p._value === promise._value))\n        unhandledErrors.push(promise);\n}\nfunction markErrorAsHandled(promise) {\n    var i = unhandledErrors.length;\n    while (i)\n        if (unhandledErrors[--i]._value === promise._value) {\n            unhandledErrors.splice(i, 1);\n            return;\n        }\n}\nfunction PromiseReject(reason) {\n    return new DexiePromise(INTERNAL, false, reason);\n}\nfunction wrap(fn, errorCatcher) {\n    var psd = PSD;\n    return function () {\n        var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n        try {\n            switchToZone(psd, true);\n            return fn.apply(this, arguments);\n        }\n        catch (e) {\n            errorCatcher && errorCatcher(e);\n        }\n        finally {\n            switchToZone(outerScope, false);\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    };\n}\nconst task = { awaits: 0, echoes: 0, id: 0 };\nvar taskCounter = 0;\nvar zoneStack = [];\nvar zoneEchoes = 0;\nvar totalEchoes = 0;\nvar zone_id_counter = 0;\nfunction newScope(fn, props, a1, a2) {\n    var parent = PSD, psd = Object.create(parent);\n    psd.parent = parent;\n    psd.ref = 0;\n    psd.global = false;\n    psd.id = ++zone_id_counter;\n    var globalEnv = globalPSD.env;\n    psd.env = patchGlobalPromise ? {\n        Promise: DexiePromise,\n        PromiseProp: { value: DexiePromise, configurable: true, writable: true },\n        all: DexiePromise.all,\n        race: DexiePromise.race,\n        allSettled: DexiePromise.allSettled,\n        any: DexiePromise.any,\n        resolve: DexiePromise.resolve,\n        reject: DexiePromise.reject,\n        nthen: getPatchedPromiseThen(globalEnv.nthen, psd),\n        gthen: getPatchedPromiseThen(globalEnv.gthen, psd)\n    } : {};\n    if (props)\n        extend(psd, props);\n    ++parent.ref;\n    psd.finalize = function () {\n        --this.parent.ref || this.parent.finalize();\n    };\n    var rv = usePSD(psd, fn, a1, a2);\n    if (psd.ref === 0)\n        psd.finalize();\n    return rv;\n}\nfunction incrementExpectedAwaits() {\n    if (!task.id)\n        task.id = ++taskCounter;\n    ++task.awaits;\n    task.echoes += ZONE_ECHO_LIMIT;\n    return task.id;\n}\nfunction decrementExpectedAwaits() {\n    if (!task.awaits)\n        return false;\n    if (--task.awaits === 0)\n        task.id = 0;\n    task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n    return true;\n}\nif (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n    incrementExpectedAwaits = decrementExpectedAwaits = nop;\n}\nfunction onPossibleParallellAsync(possiblePromise) {\n    if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n        incrementExpectedAwaits();\n        return possiblePromise.then(x => {\n            decrementExpectedAwaits();\n            return x;\n        }, e => {\n            decrementExpectedAwaits();\n            return rejection(e);\n        });\n    }\n    return possiblePromise;\n}\nfunction zoneEnterEcho(targetZone) {\n    ++totalEchoes;\n    if (!task.echoes || --task.echoes === 0) {\n        task.echoes = task.id = 0;\n    }\n    zoneStack.push(PSD);\n    switchToZone(targetZone, true);\n}\nfunction zoneLeaveEcho() {\n    var zone = zoneStack[zoneStack.length - 1];\n    zoneStack.pop();\n    switchToZone(zone, false);\n}\nfunction switchToZone(targetZone, bEnteringZone) {\n    var currentZone = PSD;\n    if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n        enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n    }\n    if (targetZone === PSD)\n        return;\n    PSD = targetZone;\n    if (currentZone === globalPSD)\n        globalPSD.env = snapShot();\n    if (patchGlobalPromise) {\n        var GlobalPromise = globalPSD.env.Promise;\n        var targetEnv = targetZone.env;\n        nativePromiseProto.then = targetEnv.nthen;\n        GlobalPromise.prototype.then = targetEnv.gthen;\n        if (currentZone.global || targetZone.global) {\n            Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n            GlobalPromise.all = targetEnv.all;\n            GlobalPromise.race = targetEnv.race;\n            GlobalPromise.resolve = targetEnv.resolve;\n            GlobalPromise.reject = targetEnv.reject;\n            if (targetEnv.allSettled)\n                GlobalPromise.allSettled = targetEnv.allSettled;\n            if (targetEnv.any)\n                GlobalPromise.any = targetEnv.any;\n        }\n    }\n}\nfunction snapShot() {\n    var GlobalPromise = _global.Promise;\n    return patchGlobalPromise ? {\n        Promise: GlobalPromise,\n        PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n        all: GlobalPromise.all,\n        race: GlobalPromise.race,\n        allSettled: GlobalPromise.allSettled,\n        any: GlobalPromise.any,\n        resolve: GlobalPromise.resolve,\n        reject: GlobalPromise.reject,\n        nthen: nativePromiseProto.then,\n        gthen: GlobalPromise.prototype.then\n    } : {};\n}\nfunction usePSD(psd, fn, a1, a2, a3) {\n    var outerScope = PSD;\n    try {\n        switchToZone(psd, true);\n        return fn(a1, a2, a3);\n    }\n    finally {\n        switchToZone(outerScope, false);\n    }\n}\nfunction enqueueNativeMicroTask(job) {\n    nativePromiseThen.call(resolvedNativePromise, job);\n}\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n    return typeof fn !== 'function' ? fn : function () {\n        var outerZone = PSD;\n        if (possibleAwait)\n            incrementExpectedAwaits();\n        switchToZone(zone, true);\n        try {\n            return fn.apply(this, arguments);\n        }\n        finally {\n            switchToZone(outerZone, false);\n            if (cleanup)\n                enqueueNativeMicroTask(decrementExpectedAwaits);\n        }\n    };\n}\nfunction getPatchedPromiseThen(origThen, zone) {\n    return function (onResolved, onRejected) {\n        return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));\n    };\n}\nconst UNHANDLEDREJECTION = \"unhandledrejection\";\nfunction globalError(err, promise) {\n    var rv;\n    try {\n        rv = promise.onuncatched(err);\n    }\n    catch (e) { }\n    if (rv !== false)\n        try {\n            var event, eventData = { promise: promise, reason: err };\n            if (_global.document && document.createEvent) {\n                event = document.createEvent('Event');\n                event.initEvent(UNHANDLEDREJECTION, true, true);\n                extend(event, eventData);\n            }\n            else if (_global.CustomEvent) {\n                event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });\n                extend(event, eventData);\n            }\n            if (event && _global.dispatchEvent) {\n                dispatchEvent(event);\n                if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)\n                    try {\n                        _global.onunhandledrejection(event);\n                    }\n                    catch (_) { }\n            }\n            if (debug && event && !event.defaultPrevented) {\n                console.warn(`Unhandled rejection: ${err.stack || err}`);\n            }\n        }\n        catch (e) { }\n}\nvar rejection = DexiePromise.reject;\n\nfunction tempTransaction(db, mode, storeNames, fn) {\n    if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {\n        if (db._state.openComplete) {\n            return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n        }\n        if (!db._state.isBeingOpened) {\n            if (!db._options.autoOpen)\n                return rejection(new exceptions.DatabaseClosed());\n            db.open().catch(nop);\n        }\n        return db._state.dbReadyPromise.then(() => tempTransaction(db, mode, storeNames, fn));\n    }\n    else {\n        var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n        try {\n            trans.create();\n        }\n        catch (ex) {\n            return rejection(ex);\n        }\n        return trans._promise(mode, (resolve, reject) => {\n            return newScope(() => {\n                PSD.trans = trans;\n                return fn(resolve, reject, trans);\n            });\n        }).then(result => {\n            return trans._completion.then(() => result);\n        });\n    }\n}\n\nconst DEXIE_VERSION = '3.2.0';\nconst maxString = String.fromCharCode(65535);\nconst minKey = -Infinity;\nconst INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\nconst STRING_EXPECTED = \"String expected.\";\nconst connections = [];\nconst isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\nconst hasIEDeleteObjectStoreBug = isIEOrEdge;\nconst hangsOnDeleteLargeKeyRange = isIEOrEdge;\nconst dexieStackFrameFilter = frame => !/(dexie\\.js|dexie\\.min\\.js)/.test(frame);\nconst DBNAMES_DB = '__dbnames';\nconst READONLY = 'readonly';\nconst READWRITE = 'readwrite';\n\nfunction combine(filter1, filter2) {\n    return filter1 ?\n        filter2 ?\n            function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :\n            filter1 :\n        filter2;\n}\n\nconst AnyRange = {\n    type: 3 ,\n    lower: -Infinity,\n    lowerOpen: false,\n    upper: [[]],\n    upperOpen: false\n};\n\nfunction workaroundForUndefinedPrimKey(keyPath) {\n    return typeof keyPath === \"string\" && !/\\./.test(keyPath)\n        ? (obj) => {\n            if (obj[keyPath] === undefined && (keyPath in obj)) {\n                obj = deepClone(obj);\n                delete obj[keyPath];\n            }\n            return obj;\n        }\n        : (obj) => obj;\n}\n\nclass Table {\n    _trans(mode, fn, writeLocked) {\n        const trans = this._tx || PSD.trans;\n        const tableName = this.name;\n        function checkTableInTransaction(resolve, reject, trans) {\n            if (!trans.schema[tableName])\n                throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n            return fn(trans.idbtrans, trans);\n        }\n        const wasRootExec = beginMicroTickScope();\n        try {\n            return trans && trans.db === this.db ?\n                trans === PSD.trans ?\n                    trans._promise(mode, checkTableInTransaction, writeLocked) :\n                    newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), { trans: trans, transless: PSD.transless || PSD }) :\n                tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n        }\n        finally {\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    }\n    get(keyOrCrit, cb) {\n        if (keyOrCrit && keyOrCrit.constructor === Object)\n            return this.where(keyOrCrit).first(cb);\n        return this._trans('readonly', (trans) => {\n            return this.core.get({ trans, key: keyOrCrit })\n                .then(res => this.hook.reading.fire(res));\n        }).then(cb);\n    }\n    where(indexOrCrit) {\n        if (typeof indexOrCrit === 'string')\n            return new this.db.WhereClause(this, indexOrCrit);\n        if (isArray(indexOrCrit))\n            return new this.db.WhereClause(this, `[${indexOrCrit.join('+')}]`);\n        const keyPaths = keys(indexOrCrit);\n        if (keyPaths.length === 1)\n            return this\n                .where(keyPaths[0])\n                .equals(indexOrCrit[keyPaths[0]]);\n        const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(ix => ix.compound &&\n            keyPaths.every(keyPath => ix.keyPath.indexOf(keyPath) >= 0) &&\n            ix.keyPath.every(keyPath => keyPaths.indexOf(keyPath) >= 0))[0];\n        if (compoundIndex && this.db._maxKey !== maxString)\n            return this\n                .where(compoundIndex.name)\n                .equals(compoundIndex.keyPath.map(kp => indexOrCrit[kp]));\n        if (!compoundIndex && debug)\n            console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a ` +\n                `compound index [${keyPaths.join('+')}]`);\n        const { idxByName } = this.schema;\n        const idb = this.db._deps.indexedDB;\n        function equals(a, b) {\n            try {\n                return idb.cmp(a, b) === 0;\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath) => {\n            const index = idxByName[keyPath];\n            const value = indexOrCrit[keyPath];\n            return [\n                prevIndex || index,\n                prevIndex || !index ?\n                    combine(prevFilterFn, index && index.multi ?\n                        x => {\n                            const prop = getByKeyPath(x, keyPath);\n                            return isArray(prop) && prop.some(item => equals(value, item));\n                        } : x => equals(value, getByKeyPath(x, keyPath)))\n                    : prevFilterFn\n            ];\n        }, [null, null]);\n        return idx ?\n            this.where(idx.name).equals(indexOrCrit[idx.keyPath])\n                .filter(filterFunction) :\n            compoundIndex ?\n                this.filter(filterFunction) :\n                this.where(keyPaths).equals('');\n    }\n    filter(filterFunction) {\n        return this.toCollection().and(filterFunction);\n    }\n    count(thenShortcut) {\n        return this.toCollection().count(thenShortcut);\n    }\n    offset(offset) {\n        return this.toCollection().offset(offset);\n    }\n    limit(numRows) {\n        return this.toCollection().limit(numRows);\n    }\n    each(callback) {\n        return this.toCollection().each(callback);\n    }\n    toArray(thenShortcut) {\n        return this.toCollection().toArray(thenShortcut);\n    }\n    toCollection() {\n        return new this.db.Collection(new this.db.WhereClause(this));\n    }\n    orderBy(index) {\n        return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?\n            `[${index.join('+')}]` :\n            index));\n    }\n    reverse() {\n        return this.toCollection().reverse();\n    }\n    mapToClass(constructor) {\n        this.schema.mappedClass = constructor;\n        const readHook = obj => {\n            if (!obj)\n                return obj;\n            const res = Object.create(constructor.prototype);\n            for (var m in obj)\n                if (hasOwn(obj, m))\n                    try {\n                        res[m] = obj[m];\n                    }\n                    catch (_) { }\n            return res;\n        };\n        if (this.schema.readHook) {\n            this.hook.reading.unsubscribe(this.schema.readHook);\n        }\n        this.schema.readHook = readHook;\n        this.hook(\"reading\", readHook);\n        return constructor;\n    }\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return this.mapToClass(Class);\n    }\n    add(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans('readwrite', trans => {\n            return this.core.mutate({ trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });\n        }).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)\n            .then(lastResult => {\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                }\n                catch (_) { }\n            }\n            return lastResult;\n        });\n    }\n    update(keyOrObject, modifications) {\n        if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n            const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n            if (key === undefined)\n                return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n            try {\n                if (typeof modifications !== \"function\") {\n                    keys(modifications).forEach(keyPath => {\n                        setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n                    });\n                }\n                else {\n                    modifications(keyOrObject, { value: keyOrObject, primKey: key });\n                }\n            }\n            catch (_a) {\n            }\n            return this.where(\":id\").equals(key).modify(modifications);\n        }\n        else {\n            return this.where(\":id\").equals(keyOrObject).modify(modifications);\n        }\n    }\n    put(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)\n            .then(lastResult => {\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                }\n                catch (_) { }\n            }\n            return lastResult;\n        });\n    }\n    delete(key) {\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'delete', keys: [key] }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    clear() {\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'deleteRange', range: AnyRange }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    bulkGet(keys) {\n        return this._trans('readonly', trans => {\n            return this.core.getMany({\n                keys,\n                trans\n            }).then(result => result.map(res => this.hook.reading.fire(res)));\n        });\n    }\n    bulkAdd(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans('readwrite', trans => {\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys)\n                throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length)\n                throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToAdd = keyPath && auto ?\n                objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                objects;\n            return this.core.mutate({ trans, type: 'add', keys: keys, values: objectsToAdd, wantResults })\n                .then(({ numFailures, results, lastResult, failures }) => {\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0)\n                    return result;\n                throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkPut(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans('readwrite', trans => {\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys)\n                throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length)\n                throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToPut = keyPath && auto ?\n                objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                objects;\n            return this.core.mutate({ trans, type: 'put', keys: keys, values: objectsToPut, wantResults })\n                .then(({ numFailures, results, lastResult, failures }) => {\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0)\n                    return result;\n                throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkDelete(keys) {\n        const numKeys = keys.length;\n        return this._trans('readwrite', trans => {\n            return this.core.mutate({ trans, type: 'delete', keys: keys });\n        }).then(({ numFailures, lastResult, failures }) => {\n            if (numFailures === 0)\n                return lastResult;\n            throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);\n        });\n    }\n}\n\nfunction Events(ctx) {\n    var evs = {};\n    var rv = function (eventName, subscriber) {\n        if (subscriber) {\n            var i = arguments.length, args = new Array(i - 1);\n            while (--i)\n                args[i - 1] = arguments[i];\n            evs[eventName].subscribe.apply(null, args);\n            return ctx;\n        }\n        else if (typeof (eventName) === 'string') {\n            return evs[eventName];\n        }\n    };\n    rv.addEventType = add;\n    for (var i = 1, l = arguments.length; i < l; ++i) {\n        add(arguments[i]);\n    }\n    return rv;\n    function add(eventName, chainFunction, defaultFunction) {\n        if (typeof eventName === 'object')\n            return addConfiguredEvents(eventName);\n        if (!chainFunction)\n            chainFunction = reverseStoppableEventChain;\n        if (!defaultFunction)\n            defaultFunction = nop;\n        var context = {\n            subscribers: [],\n            fire: defaultFunction,\n            subscribe: function (cb) {\n                if (context.subscribers.indexOf(cb) === -1) {\n                    context.subscribers.push(cb);\n                    context.fire = chainFunction(context.fire, cb);\n                }\n            },\n            unsubscribe: function (cb) {\n                context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });\n                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n            }\n        };\n        evs[eventName] = rv[eventName] = context;\n        return context;\n    }\n    function addConfiguredEvents(cfg) {\n        keys(cfg).forEach(function (eventName) {\n            var args = cfg[eventName];\n            if (isArray(args)) {\n                add(eventName, cfg[eventName][0], cfg[eventName][1]);\n            }\n            else if (args === 'asap') {\n                var context = add(eventName, mirror, function fire() {\n                    var i = arguments.length, args = new Array(i);\n                    while (i--)\n                        args[i] = arguments[i];\n                    context.subscribers.forEach(function (fn) {\n                        asap$1(function fireEvent() {\n                            fn.apply(null, args);\n                        });\n                    });\n                });\n            }\n            else\n                throw new exceptions.InvalidArgument(\"Invalid event config\");\n        });\n    }\n}\n\nfunction makeClassConstructor(prototype, constructor) {\n    derive(constructor).from({ prototype });\n    return constructor;\n}\n\nfunction createTableConstructor(db) {\n    return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n        this.db = db;\n        this._tx = trans;\n        this.name = name;\n        this.schema = tableSchema;\n        this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n            \"creating\": [hookCreatingChain, nop],\n            \"reading\": [pureFunctionChain, mirror],\n            \"updating\": [hookUpdatingChain, nop],\n            \"deleting\": [hookDeletingChain, nop]\n        });\n    });\n}\n\nfunction isPlainKeyRange(ctx, ignoreLimitFilter) {\n    return !(ctx.filter || ctx.algorithm || ctx.or) &&\n        (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n}\nfunction addFilter(ctx, fn) {\n    ctx.filter = combine(ctx.filter, fn);\n}\nfunction addReplayFilter(ctx, factory, isLimitFilter) {\n    var curr = ctx.replayFilter;\n    ctx.replayFilter = curr ? () => combine(curr(), factory()) : factory;\n    ctx.justLimit = isLimitFilter && !curr;\n}\nfunction addMatchFilter(ctx, fn) {\n    ctx.isMatch = combine(ctx.isMatch, fn);\n}\nfunction getIndexOrStore(ctx, coreSchema) {\n    if (ctx.isPrimKey)\n        return coreSchema.primaryKey;\n    const index = coreSchema.getIndexByKeyPath(ctx.index);\n    if (!index)\n        throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n    return index;\n}\nfunction openCursor(ctx, coreTable, trans) {\n    const index = getIndexOrStore(ctx, coreTable.schema);\n    return coreTable.openCursor({\n        trans,\n        values: !ctx.keysOnly,\n        reverse: ctx.dir === 'prev',\n        unique: !!ctx.unique,\n        query: {\n            index,\n            range: ctx.range\n        }\n    });\n}\nfunction iter(ctx, fn, coreTrans, coreTable) {\n    const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n    if (!ctx.or) {\n        return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n    }\n    else {\n        const set = {};\n        const union = (item, cursor, advance) => {\n            if (!filter || filter(cursor, advance, result => cursor.stop(result), err => cursor.fail(err))) {\n                var primaryKey = cursor.primaryKey;\n                var key = '' + primaryKey;\n                if (key === '[object ArrayBuffer]')\n                    key = '' + new Uint8Array(primaryKey);\n                if (!hasOwn(set, key)) {\n                    set[key] = true;\n                    fn(item, cursor, advance);\n                }\n            }\n        };\n        return Promise.all([\n            ctx.or._iterate(union, coreTrans),\n            iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n        ]);\n    }\n}\nfunction iterate(cursorPromise, filter, fn, valueMapper) {\n    var mappedFn = valueMapper ? (x, c, a) => fn(valueMapper(x), c, a) : fn;\n    var wrappedFn = wrap(mappedFn);\n    return cursorPromise.then(cursor => {\n        if (cursor) {\n            return cursor.start(() => {\n                var c = () => cursor.continue();\n                if (!filter || filter(cursor, advancer => c = advancer, val => { cursor.stop(val); c = nop; }, e => { cursor.fail(e); c = nop; }))\n                    wrappedFn(cursor.value, cursor, advancer => c = advancer);\n                c();\n            });\n        }\n    });\n}\n\nfunction cmp(a, b) {\n    try {\n        const ta = type(a);\n        const tb = type(b);\n        if (ta !== tb) {\n            if (ta === 'Array')\n                return 1;\n            if (tb === 'Array')\n                return -1;\n            if (ta === 'binary')\n                return 1;\n            if (tb === 'binary')\n                return -1;\n            if (ta === 'string')\n                return 1;\n            if (tb === 'string')\n                return -1;\n            if (ta === 'Date')\n                return 1;\n            if (tb !== 'Date')\n                return NaN;\n            return -1;\n        }\n        switch (ta) {\n            case 'number':\n            case 'Date':\n            case 'string':\n                return a > b ? 1 : a < b ? -1 : 0;\n            case 'binary': {\n                return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n            }\n            case 'Array':\n                return compareArrays(a, b);\n        }\n    }\n    catch (_a) { }\n    return NaN;\n}\nfunction compareArrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for (let i = 0; i < l; ++i) {\n        const res = cmp(a[i], b[i]);\n        if (res !== 0)\n            return res;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction compareUint8Arrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for (let i = 0; i < l; ++i) {\n        if (a[i] !== b[i])\n            return a[i] < b[i] ? -1 : 1;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction type(x) {\n    const t = typeof x;\n    if (t !== 'object')\n        return t;\n    if (ArrayBuffer.isView(x))\n        return 'binary';\n    const tsTag = toStringTag(x);\n    return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n}\nfunction getUint8Array(a) {\n    if (a instanceof Uint8Array)\n        return a;\n    if (ArrayBuffer.isView(a))\n        return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n    return new Uint8Array(a);\n}\n\nclass Collection {\n    _read(fn, cb) {\n        var ctx = this._ctx;\n        return ctx.error ?\n            ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n            ctx.table._trans('readonly', fn).then(cb);\n    }\n    _write(fn) {\n        var ctx = this._ctx;\n        return ctx.error ?\n            ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n            ctx.table._trans('readwrite', fn, \"locked\");\n    }\n    _addAlgorithm(fn) {\n        var ctx = this._ctx;\n        ctx.algorithm = combine(ctx.algorithm, fn);\n    }\n    _iterate(fn, coreTrans) {\n        return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n    }\n    clone(props) {\n        var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n        if (props)\n            extend(ctx, props);\n        rv._ctx = ctx;\n        return rv;\n    }\n    raw() {\n        this._ctx.valueMapper = null;\n        return this;\n    }\n    each(fn) {\n        var ctx = this._ctx;\n        return this._read(trans => iter(ctx, fn, trans, ctx.table.core));\n    }\n    count(cb) {\n        return this._read(trans => {\n            const ctx = this._ctx;\n            const coreTable = ctx.table.core;\n            if (isPlainKeyRange(ctx, true)) {\n                return coreTable.count({\n                    trans,\n                    query: {\n                        index: getIndexOrStore(ctx, coreTable.schema),\n                        range: ctx.range\n                    }\n                }).then(count => Math.min(count, ctx.limit));\n            }\n            else {\n                var count = 0;\n                return iter(ctx, () => { ++count; return false; }, trans, coreTable)\n                    .then(() => count);\n            }\n        }).then(cb);\n    }\n    sortBy(keyPath, cb) {\n        const parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n        function getval(obj, i) {\n            if (i)\n                return getval(obj[parts[i]], i - 1);\n            return obj[lastPart];\n        }\n        var order = this._ctx.dir === \"next\" ? 1 : -1;\n        function sorter(a, b) {\n            var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n            return aVal < bVal ? -order : aVal > bVal ? order : 0;\n        }\n        return this.toArray(function (a) {\n            return a.sort(sorter);\n        }).then(cb);\n    }\n    toArray(cb) {\n        return this._read(trans => {\n            var ctx = this._ctx;\n            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                const { valueMapper } = ctx;\n                const index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    limit: ctx.limit,\n                    values: true,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                }).then(({ result }) => valueMapper ? result.map(valueMapper) : result);\n            }\n            else {\n                const a = [];\n                return iter(ctx, item => a.push(item), trans, ctx.table.core).then(() => a);\n            }\n        }, cb);\n    }\n    offset(offset) {\n        var ctx = this._ctx;\n        if (offset <= 0)\n            return this;\n        ctx.offset += offset;\n        if (isPlainKeyRange(ctx)) {\n            addReplayFilter(ctx, () => {\n                var offsetLeft = offset;\n                return (cursor, advance) => {\n                    if (offsetLeft === 0)\n                        return true;\n                    if (offsetLeft === 1) {\n                        --offsetLeft;\n                        return false;\n                    }\n                    advance(() => {\n                        cursor.advance(offsetLeft);\n                        offsetLeft = 0;\n                    });\n                    return false;\n                };\n            });\n        }\n        else {\n            addReplayFilter(ctx, () => {\n                var offsetLeft = offset;\n                return () => (--offsetLeft < 0);\n            });\n        }\n        return this;\n    }\n    limit(numRows) {\n        this._ctx.limit = Math.min(this._ctx.limit, numRows);\n        addReplayFilter(this._ctx, () => {\n            var rowsLeft = numRows;\n            return function (cursor, advance, resolve) {\n                if (--rowsLeft <= 0)\n                    advance(resolve);\n                return rowsLeft >= 0;\n            };\n        }, true);\n        return this;\n    }\n    until(filterFunction, bIncludeStopEntry) {\n        addFilter(this._ctx, function (cursor, advance, resolve) {\n            if (filterFunction(cursor.value)) {\n                advance(resolve);\n                return bIncludeStopEntry;\n            }\n            else {\n                return true;\n            }\n        });\n        return this;\n    }\n    first(cb) {\n        return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);\n    }\n    last(cb) {\n        return this.reverse().first(cb);\n    }\n    filter(filterFunction) {\n        addFilter(this._ctx, function (cursor) {\n            return filterFunction(cursor.value);\n        });\n        addMatchFilter(this._ctx, filterFunction);\n        return this;\n    }\n    and(filter) {\n        return this.filter(filter);\n    }\n    or(indexName) {\n        return new this.db.WhereClause(this._ctx.table, indexName, this);\n    }\n    reverse() {\n        this._ctx.dir = (this._ctx.dir === \"prev\" ? \"next\" : \"prev\");\n        if (this._ondirectionchange)\n            this._ondirectionchange(this._ctx.dir);\n        return this;\n    }\n    desc() {\n        return this.reverse();\n    }\n    eachKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function (val, cursor) { cb(cursor.key, cursor); });\n    }\n    eachUniqueKey(cb) {\n        this._ctx.unique = \"unique\";\n        return this.eachKey(cb);\n    }\n    eachPrimaryKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });\n    }\n    keys(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function (item, cursor) {\n            a.push(cursor.key);\n        }).then(function () {\n            return a;\n        }).then(cb);\n    }\n    primaryKeys(cb) {\n        var ctx = this._ctx;\n        if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n            return this._read(trans => {\n                var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    values: false,\n                    limit: ctx.limit,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                });\n            }).then(({ result }) => result).then(cb);\n        }\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function (item, cursor) {\n            a.push(cursor.primaryKey);\n        }).then(function () {\n            return a;\n        }).then(cb);\n    }\n    uniqueKeys(cb) {\n        this._ctx.unique = \"unique\";\n        return this.keys(cb);\n    }\n    firstKey(cb) {\n        return this.limit(1).keys(function (a) { return a[0]; }).then(cb);\n    }\n    lastKey(cb) {\n        return this.reverse().firstKey(cb);\n    }\n    distinct() {\n        var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n        if (!idx || !idx.multi)\n            return this;\n        var set = {};\n        addFilter(this._ctx, function (cursor) {\n            var strKey = cursor.primaryKey.toString();\n            var found = hasOwn(set, strKey);\n            set[strKey] = true;\n            return !found;\n        });\n        return this;\n    }\n    modify(changes) {\n        var ctx = this._ctx;\n        return this._write(trans => {\n            var modifyer;\n            if (typeof changes === 'function') {\n                modifyer = changes;\n            }\n            else {\n                var keyPaths = keys(changes);\n                var numKeys = keyPaths.length;\n                modifyer = function (item) {\n                    var anythingModified = false;\n                    for (var i = 0; i < numKeys; ++i) {\n                        var keyPath = keyPaths[i], val = changes[keyPath];\n                        if (getByKeyPath(item, keyPath) !== val) {\n                            setByKeyPath(item, keyPath, val);\n                            anythingModified = true;\n                        }\n                    }\n                    return anythingModified;\n                };\n            }\n            const coreTable = ctx.table.core;\n            const { outbound, extractKey } = coreTable.schema.primaryKey;\n            const limit = this.db._options.modifyChunkSize || 200;\n            const totalFailures = [];\n            let successCount = 0;\n            const failedKeys = [];\n            const applyMutateResult = (expectedCount, res) => {\n                const { failures, numFailures } = res;\n                successCount += expectedCount - numFailures;\n                for (let pos of keys(failures)) {\n                    totalFailures.push(failures[pos]);\n                }\n            };\n            return this.clone().primaryKeys().then(keys => {\n                const nextChunk = (offset) => {\n                    const count = Math.min(limit, keys.length - offset);\n                    return coreTable.getMany({\n                        trans,\n                        keys: keys.slice(offset, offset + count),\n                        cache: \"immutable\"\n                    }).then(values => {\n                        const addValues = [];\n                        const putValues = [];\n                        const putKeys = outbound ? [] : null;\n                        const deleteKeys = [];\n                        for (let i = 0; i < count; ++i) {\n                            const origValue = values[i];\n                            const ctx = {\n                                value: deepClone(origValue),\n                                primKey: keys[offset + i]\n                            };\n                            if (modifyer.call(ctx, ctx.value, ctx) !== false) {\n                                if (ctx.value == null) {\n                                    deleteKeys.push(keys[offset + i]);\n                                }\n                                else if (!outbound && cmp(extractKey(origValue), extractKey(ctx.value)) !== 0) {\n                                    deleteKeys.push(keys[offset + i]);\n                                    addValues.push(ctx.value);\n                                }\n                                else {\n                                    putValues.push(ctx.value);\n                                    if (outbound)\n                                        putKeys.push(keys[offset + i]);\n                                }\n                            }\n                        }\n                        const criteria = isPlainKeyRange(ctx) &&\n                            ctx.limit === Infinity &&\n                            (typeof changes !== 'function' || changes === deleteCallback) && {\n                            index: ctx.index,\n                            range: ctx.range\n                        };\n                        return Promise.resolve(addValues.length > 0 &&\n                            coreTable.mutate({ trans, type: 'add', values: addValues })\n                                .then(res => {\n                                for (let pos in res.failures) {\n                                    deleteKeys.splice(parseInt(pos), 1);\n                                }\n                                applyMutateResult(addValues.length, res);\n                            })).then(() => (putValues.length > 0 || (criteria && typeof changes === 'object')) &&\n                            coreTable.mutate({\n                                trans,\n                                type: 'put',\n                                keys: putKeys,\n                                values: putValues,\n                                criteria,\n                                changeSpec: typeof changes !== 'function'\n                                    && changes\n                            }).then(res => applyMutateResult(putValues.length, res))).then(() => (deleteKeys.length > 0 || (criteria && changes === deleteCallback)) &&\n                            coreTable.mutate({\n                                trans,\n                                type: 'delete',\n                                keys: deleteKeys,\n                                criteria\n                            }).then(res => applyMutateResult(deleteKeys.length, res))).then(() => {\n                            return keys.length > offset + count && nextChunk(offset + limit);\n                        });\n                    });\n                };\n                return nextChunk(0).then(() => {\n                    if (totalFailures.length > 0)\n                        throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n                    return keys.length;\n                });\n            });\n        });\n    }\n    delete() {\n        var ctx = this._ctx, range = ctx.range;\n        if (isPlainKeyRange(ctx) &&\n            ((ctx.isPrimKey && !hangsOnDeleteLargeKeyRange) || range.type === 3 ))\n         {\n            return this._write(trans => {\n                const { primaryKey } = ctx.table.core.schema;\n                const coreRange = range;\n                return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then(count => {\n                    return ctx.table.core.mutate({ trans, type: 'deleteRange', range: coreRange })\n                        .then(({ failures, lastResult, results, numFailures }) => {\n                        if (numFailures)\n                            throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(pos => failures[pos]), count - numFailures);\n                        return count - numFailures;\n                    });\n                });\n            });\n        }\n        return this.modify(deleteCallback);\n    }\n}\nconst deleteCallback = (value, ctx) => ctx.value = null;\n\nfunction createCollectionConstructor(db) {\n    return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n        this.db = db;\n        let keyRange = AnyRange, error = null;\n        if (keyRangeGenerator)\n            try {\n                keyRange = keyRangeGenerator();\n            }\n            catch (ex) {\n                error = ex;\n            }\n        const whereCtx = whereClause._ctx;\n        const table = whereCtx.table;\n        const readingHook = table.hook.reading.fire;\n        this._ctx = {\n            table: table,\n            index: whereCtx.index,\n            isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),\n            range: keyRange,\n            keysOnly: false,\n            dir: \"next\",\n            unique: \"\",\n            algorithm: null,\n            filter: null,\n            replayFilter: null,\n            justLimit: true,\n            isMatch: null,\n            offset: 0,\n            limit: Infinity,\n            error: error,\n            or: whereCtx.or,\n            valueMapper: readingHook !== mirror ? readingHook : null\n        };\n    });\n}\n\nfunction simpleCompare(a, b) {\n    return a < b ? -1 : a === b ? 0 : 1;\n}\nfunction simpleCompareReverse(a, b) {\n    return a > b ? -1 : a === b ? 0 : 1;\n}\n\nfunction fail(collectionOrWhereClause, err, T) {\n    var collection = collectionOrWhereClause instanceof WhereClause ?\n        new collectionOrWhereClause.Collection(collectionOrWhereClause) :\n        collectionOrWhereClause;\n    collection._ctx.error = T ? new T(err) : new TypeError(err);\n    return collection;\n}\nfunction emptyCollection(whereClause) {\n    return new whereClause.Collection(whereClause, () => rangeEqual(\"\")).limit(0);\n}\nfunction upperFactory(dir) {\n    return dir === \"next\" ?\n        (s) => s.toUpperCase() :\n        (s) => s.toLowerCase();\n}\nfunction lowerFactory(dir) {\n    return dir === \"next\" ?\n        (s) => s.toLowerCase() :\n        (s) => s.toUpperCase();\n}\nfunction nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n    var length = Math.min(key.length, lowerNeedle.length);\n    var llp = -1;\n    for (var i = 0; i < length; ++i) {\n        var lwrKeyChar = lowerKey[i];\n        if (lwrKeyChar !== lowerNeedle[i]) {\n            if (cmp(key[i], upperNeedle[i]) < 0)\n                return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n            if (cmp(key[i], lowerNeedle[i]) < 0)\n                return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n            if (llp >= 0)\n                return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n            return null;\n        }\n        if (cmp(key[i], lwrKeyChar) < 0)\n            llp = i;\n    }\n    if (length < lowerNeedle.length && dir === \"next\")\n        return key + upperNeedle.substr(key.length);\n    if (length < key.length && dir === \"prev\")\n        return key.substr(0, upperNeedle.length);\n    return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));\n}\nfunction addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n    var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n    if (!needles.every(s => typeof s === 'string')) {\n        return fail(whereClause, STRING_EXPECTED);\n    }\n    function initDirection(dir) {\n        upper = upperFactory(dir);\n        lower = lowerFactory(dir);\n        compare = (dir === \"next\" ? simpleCompare : simpleCompareReverse);\n        var needleBounds = needles.map(function (needle) {\n            return { lower: lower(needle), upper: upper(needle) };\n        }).sort(function (a, b) {\n            return compare(a.lower, b.lower);\n        });\n        upperNeedles = needleBounds.map(function (nb) { return nb.upper; });\n        lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });\n        direction = dir;\n        nextKeySuffix = (dir === \"next\" ? \"\" : suffix);\n    }\n    initDirection(\"next\");\n    var c = new whereClause.Collection(whereClause, () => createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));\n    c._ondirectionchange = function (direction) {\n        initDirection(direction);\n    };\n    var firstPossibleNeedle = 0;\n    c._addAlgorithm(function (cursor, advance, resolve) {\n        var key = cursor.key;\n        if (typeof key !== 'string')\n            return false;\n        var lowerKey = lower(key);\n        if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n            return true;\n        }\n        else {\n            var lowestPossibleCasing = null;\n            for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n                var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n                if (casing === null && lowestPossibleCasing === null)\n                    firstPossibleNeedle = i + 1;\n                else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                    lowestPossibleCasing = casing;\n                }\n            }\n            if (lowestPossibleCasing !== null) {\n                advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });\n            }\n            else {\n                advance(resolve);\n            }\n            return false;\n        }\n    });\n    return c;\n}\nfunction createRange(lower, upper, lowerOpen, upperOpen) {\n    return {\n        type: 2 ,\n        lower,\n        upper,\n        lowerOpen,\n        upperOpen\n    };\n}\nfunction rangeEqual(value) {\n    return {\n        type: 1 ,\n        lower: value,\n        upper: value\n    };\n}\n\nclass WhereClause {\n    get Collection() {\n        return this._ctx.table.db.Collection;\n    }\n    between(lower, upper, includeLower, includeUpper) {\n        includeLower = includeLower !== false;\n        includeUpper = includeUpper === true;\n        try {\n            if ((this._cmp(lower, upper) > 0) ||\n                (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))\n                return emptyCollection(this);\n            return new this.Collection(this, () => createRange(lower, upper, !includeLower, !includeUpper));\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n    }\n    equals(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => rangeEqual(value));\n    }\n    above(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(value, undefined, true));\n    }\n    aboveOrEqual(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(value, undefined, false));\n    }\n    below(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(undefined, value, false, true));\n    }\n    belowOrEqual(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(undefined, value));\n    }\n    startsWith(str) {\n        if (typeof str !== 'string')\n            return fail(this, STRING_EXPECTED);\n        return this.between(str, str + maxString, true, true);\n    }\n    startsWithIgnoreCase(str) {\n        if (str === \"\")\n            return this.startsWith(str);\n        return addIgnoreCaseAlgorithm(this, (x, a) => x.indexOf(a[0]) === 0, [str], maxString);\n    }\n    equalsIgnoreCase(str) {\n        return addIgnoreCaseAlgorithm(this, (x, a) => x === a[0], [str], \"\");\n    }\n    anyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a) => a.indexOf(x) !== -1, set, \"\");\n    }\n    startsWithAnyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a) => a.some(n => x.indexOf(n) === 0), set, maxString);\n    }\n    anyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        let compare = this._cmp;\n        try {\n            set.sort(compare);\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        if (set.length === 0)\n            return emptyCollection(this);\n        const c = new this.Collection(this, () => createRange(set[0], set[set.length - 1]));\n        c._ondirectionchange = direction => {\n            compare = (direction === \"next\" ?\n                this._ascending :\n                this._descending);\n            set.sort(compare);\n        };\n        let i = 0;\n        c._addAlgorithm((cursor, advance, resolve) => {\n            const key = cursor.key;\n            while (compare(key, set[i]) > 0) {\n                ++i;\n                if (i === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (compare(key, set[i]) === 0) {\n                return true;\n            }\n            else {\n                advance(() => { cursor.continue(set[i]); });\n                return false;\n            }\n        });\n        return c;\n    }\n    notEqual(value) {\n        return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });\n    }\n    noneOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return new this.Collection(this);\n        try {\n            set.sort(this._ascending);\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        const ranges = set.reduce((res, val) => res ?\n            res.concat([[res[res.length - 1][1], val]]) :\n            [[minKey, val]], null);\n        ranges.push([set[set.length - 1], this.db._maxKey]);\n        return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\n    }\n    inAnyRange(ranges, options) {\n        const cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n        if (ranges.length === 0)\n            return emptyCollection(this);\n        if (!ranges.every(range => range[0] !== undefined &&\n            range[1] !== undefined &&\n            ascending(range[0], range[1]) <= 0)) {\n            return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n        }\n        const includeLowers = !options || options.includeLowers !== false;\n        const includeUppers = options && options.includeUppers === true;\n        function addRange(ranges, newRange) {\n            let i = 0, l = ranges.length;\n            for (; i < l; ++i) {\n                const range = ranges[i];\n                if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n                    range[0] = min(range[0], newRange[0]);\n                    range[1] = max(range[1], newRange[1]);\n                    break;\n                }\n            }\n            if (i === l)\n                ranges.push(newRange);\n            return ranges;\n        }\n        let sortDirection = ascending;\n        function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }\n        let set;\n        try {\n            set = ranges.reduce(addRange, []);\n            set.sort(rangeSorter);\n        }\n        catch (ex) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        let rangePos = 0;\n        const keyIsBeyondCurrentEntry = includeUppers ?\n            key => ascending(key, set[rangePos][1]) > 0 :\n            key => ascending(key, set[rangePos][1]) >= 0;\n        const keyIsBeforeCurrentEntry = includeLowers ?\n            key => descending(key, set[rangePos][0]) > 0 :\n            key => descending(key, set[rangePos][0]) >= 0;\n        function keyWithinCurrentRange(key) {\n            return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n        }\n        let checkKey = keyIsBeyondCurrentEntry;\n        const c = new this.Collection(this, () => createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));\n        c._ondirectionchange = direction => {\n            if (direction === \"next\") {\n                checkKey = keyIsBeyondCurrentEntry;\n                sortDirection = ascending;\n            }\n            else {\n                checkKey = keyIsBeforeCurrentEntry;\n                sortDirection = descending;\n            }\n            set.sort(rangeSorter);\n        };\n        c._addAlgorithm((cursor, advance, resolve) => {\n            var key = cursor.key;\n            while (checkKey(key)) {\n                ++rangePos;\n                if (rangePos === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (keyWithinCurrentRange(key)) {\n                return true;\n            }\n            else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {\n                return false;\n            }\n            else {\n                advance(() => {\n                    if (sortDirection === ascending)\n                        cursor.continue(set[rangePos][0]);\n                    else\n                        cursor.continue(set[rangePos][1]);\n                });\n                return false;\n            }\n        });\n        return c;\n    }\n    startsWithAnyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (!set.every(s => typeof s === 'string')) {\n            return fail(this, \"startsWithAnyOf() only works with strings\");\n        }\n        if (set.length === 0)\n            return emptyCollection(this);\n        return this.inAnyRange(set.map((str) => [str, str + maxString]));\n    }\n}\n\nfunction createWhereClauseConstructor(db) {\n    return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n        this.db = db;\n        this._ctx = {\n            table: table,\n            index: index === \":id\" ? null : index,\n            or: orCollection\n        };\n        const indexedDB = db._deps.indexedDB;\n        if (!indexedDB)\n            throw new exceptions.MissingAPI();\n        this._cmp = this._ascending = indexedDB.cmp.bind(indexedDB);\n        this._descending = (a, b) => indexedDB.cmp(b, a);\n        this._max = (a, b) => indexedDB.cmp(a, b) > 0 ? a : b;\n        this._min = (a, b) => indexedDB.cmp(a, b) < 0 ? a : b;\n        this._IDBKeyRange = db._deps.IDBKeyRange;\n    });\n}\n\nfunction eventRejectHandler(reject) {\n    return wrap(function (event) {\n        preventDefault(event);\n        reject(event.target.error);\n        return false;\n    });\n}\nfunction preventDefault(event) {\n    if (event.stopPropagation)\n        event.stopPropagation();\n    if (event.preventDefault)\n        event.preventDefault();\n}\n\nconst DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\nconst STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\nconst globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n\nclass Transaction {\n    _lock() {\n        assert(!PSD.global);\n        ++this._reculock;\n        if (this._reculock === 1 && !PSD.global)\n            PSD.lockOwnerFor = this;\n        return this;\n    }\n    _unlock() {\n        assert(!PSD.global);\n        if (--this._reculock === 0) {\n            if (!PSD.global)\n                PSD.lockOwnerFor = null;\n            while (this._blockedFuncs.length > 0 && !this._locked()) {\n                var fnAndPSD = this._blockedFuncs.shift();\n                try {\n                    usePSD(fnAndPSD[1], fnAndPSD[0]);\n                }\n                catch (e) { }\n            }\n        }\n        return this;\n    }\n    _locked() {\n        return this._reculock && PSD.lockOwnerFor !== this;\n    }\n    create(idbtrans) {\n        if (!this.mode)\n            return this;\n        const idbdb = this.db.idbdb;\n        const dbOpenError = this.db._state.dbOpenError;\n        assert(!this.idbtrans);\n        if (!idbtrans && !idbdb) {\n            switch (dbOpenError && dbOpenError.name) {\n                case \"DatabaseClosedError\":\n                    throw new exceptions.DatabaseClosed(dbOpenError);\n                case \"MissingAPIError\":\n                    throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n                default:\n                    throw new exceptions.OpenFailed(dbOpenError);\n            }\n        }\n        if (!this.active)\n            throw new exceptions.TransactionInactive();\n        assert(this._completion._state === null);\n        idbtrans = this.idbtrans = idbtrans ||\n            (this.db.core\n                ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })\n                : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));\n        idbtrans.onerror = wrap(ev => {\n            preventDefault(ev);\n            this._reject(idbtrans.error);\n        });\n        idbtrans.onabort = wrap(ev => {\n            preventDefault(ev);\n            this.active && this._reject(new exceptions.Abort(idbtrans.error));\n            this.active = false;\n            this.on(\"abort\").fire(ev);\n        });\n        idbtrans.oncomplete = wrap(() => {\n            this.active = false;\n            this._resolve();\n            if ('mutatedParts' in idbtrans) {\n                globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n            }\n        });\n        return this;\n    }\n    _promise(mode, fn, bWriteLock) {\n        if (mode === 'readwrite' && this.mode !== 'readwrite')\n            return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n        if (!this.active)\n            return rejection(new exceptions.TransactionInactive());\n        if (this._locked()) {\n            return new DexiePromise((resolve, reject) => {\n                this._blockedFuncs.push([() => {\n                        this._promise(mode, fn, bWriteLock).then(resolve, reject);\n                    }, PSD]);\n            });\n        }\n        else if (bWriteLock) {\n            return newScope(() => {\n                var p = new DexiePromise((resolve, reject) => {\n                    this._lock();\n                    const rv = fn(resolve, reject, this);\n                    if (rv && rv.then)\n                        rv.then(resolve, reject);\n                });\n                p.finally(() => this._unlock());\n                p._lib = true;\n                return p;\n            });\n        }\n        else {\n            var p = new DexiePromise((resolve, reject) => {\n                var rv = fn(resolve, reject, this);\n                if (rv && rv.then)\n                    rv.then(resolve, reject);\n            });\n            p._lib = true;\n            return p;\n        }\n    }\n    _root() {\n        return this.parent ? this.parent._root() : this;\n    }\n    waitFor(promiseLike) {\n        var root = this._root();\n        const promise = DexiePromise.resolve(promiseLike);\n        if (root._waitingFor) {\n            root._waitingFor = root._waitingFor.then(() => promise);\n        }\n        else {\n            root._waitingFor = promise;\n            root._waitingQueue = [];\n            var store = root.idbtrans.objectStore(root.storeNames[0]);\n            (function spin() {\n                ++root._spinCount;\n                while (root._waitingQueue.length)\n                    (root._waitingQueue.shift())();\n                if (root._waitingFor)\n                    store.get(-Infinity).onsuccess = spin;\n            }());\n        }\n        var currentWaitPromise = root._waitingFor;\n        return new DexiePromise((resolve, reject) => {\n            promise.then(res => root._waitingQueue.push(wrap(resolve.bind(null, res))), err => root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(() => {\n                if (root._waitingFor === currentWaitPromise) {\n                    root._waitingFor = null;\n                }\n            });\n        });\n    }\n    abort() {\n        if (this.active) {\n            this.active = false;\n            if (this.idbtrans)\n                this.idbtrans.abort();\n            this._reject(new exceptions.Abort());\n        }\n    }\n    table(tableName) {\n        const memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));\n        if (hasOwn(memoizedTables, tableName))\n            return memoizedTables[tableName];\n        const tableSchema = this.schema[tableName];\n        if (!tableSchema) {\n            throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n        }\n        const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n        transactionBoundTable.core = this.db.core.table(tableName);\n        memoizedTables[tableName] = transactionBoundTable;\n        return transactionBoundTable;\n    }\n}\n\nfunction createTransactionConstructor(db) {\n    return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n        this.db = db;\n        this.mode = mode;\n        this.storeNames = storeNames;\n        this.schema = dbschema;\n        this.chromeTransactionDurability = chromeTransactionDurability;\n        this.idbtrans = null;\n        this.on = Events(this, \"complete\", \"error\", \"abort\");\n        this.parent = parent || null;\n        this.active = true;\n        this._reculock = 0;\n        this._blockedFuncs = [];\n        this._resolve = null;\n        this._reject = null;\n        this._waitingFor = null;\n        this._waitingQueue = null;\n        this._spinCount = 0;\n        this._completion = new DexiePromise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        this._completion.then(() => {\n            this.active = false;\n            this.on.complete.fire();\n        }, e => {\n            var wasActive = this.active;\n            this.active = false;\n            this.on.error.fire(e);\n            this.parent ?\n                this.parent._reject(e) :\n                wasActive && this.idbtrans && this.idbtrans.abort();\n            return rejection(e);\n        });\n    });\n}\n\nfunction createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n    return {\n        name,\n        keyPath,\n        unique,\n        multi,\n        auto,\n        compound,\n        src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n    };\n}\nfunction nameFromKeyPath(keyPath) {\n    return typeof keyPath === 'string' ?\n        keyPath :\n        keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : \"\";\n}\n\nfunction createTableSchema(name, primKey, indexes) {\n    return {\n        name,\n        primKey,\n        indexes,\n        mappedClass: null,\n        idxByName: arrayToObject(indexes, index => [index.name, index])\n    };\n}\n\nfunction safariMultiStoreFix(storeNames) {\n    return storeNames.length === 1 ? storeNames[0] : storeNames;\n}\nlet getMaxKey = (IdbKeyRange) => {\n    try {\n        IdbKeyRange.only([[]]);\n        getMaxKey = () => [[]];\n        return [[]];\n    }\n    catch (e) {\n        getMaxKey = () => maxString;\n        return maxString;\n    }\n};\n\nfunction getKeyExtractor(keyPath) {\n    if (keyPath == null) {\n        return () => undefined;\n    }\n    else if (typeof keyPath === 'string') {\n        return getSinglePathKeyExtractor(keyPath);\n    }\n    else {\n        return obj => getByKeyPath(obj, keyPath);\n    }\n}\nfunction getSinglePathKeyExtractor(keyPath) {\n    const split = keyPath.split('.');\n    if (split.length === 1) {\n        return obj => obj[keyPath];\n    }\n    else {\n        return obj => getByKeyPath(obj, keyPath);\n    }\n}\n\nfunction arrayify(arrayLike) {\n    return [].slice.call(arrayLike);\n}\nlet _id_counter = 0;\nfunction getKeyPathAlias(keyPath) {\n    return keyPath == null ?\n        \":id\" :\n        typeof keyPath === 'string' ?\n            keyPath :\n            `[${keyPath.join('+')}]`;\n}\nfunction createDBCore(db, IdbKeyRange, tmpTrans) {\n    function extractSchema(db, trans) {\n        const tables = arrayify(db.objectStoreNames);\n        return {\n            schema: {\n                name: db.name,\n                tables: tables.map(table => trans.objectStore(table)).map(store => {\n                    const { keyPath, autoIncrement } = store;\n                    const compound = isArray(keyPath);\n                    const outbound = keyPath == null;\n                    const indexByKeyPath = {};\n                    const result = {\n                        name: store.name,\n                        primaryKey: {\n                            name: null,\n                            isPrimaryKey: true,\n                            outbound,\n                            compound,\n                            keyPath,\n                            autoIncrement,\n                            unique: true,\n                            extractKey: getKeyExtractor(keyPath)\n                        },\n                        indexes: arrayify(store.indexNames).map(indexName => store.index(indexName))\n                            .map(index => {\n                            const { name, unique, multiEntry, keyPath } = index;\n                            const compound = isArray(keyPath);\n                            const result = {\n                                name,\n                                compound,\n                                keyPath,\n                                unique,\n                                multiEntry,\n                                extractKey: getKeyExtractor(keyPath)\n                            };\n                            indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n                            return result;\n                        }),\n                        getIndexByKeyPath: (keyPath) => indexByKeyPath[getKeyPathAlias(keyPath)]\n                    };\n                    indexByKeyPath[\":id\"] = result.primaryKey;\n                    if (keyPath != null) {\n                        indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n                    }\n                    return result;\n                })\n            },\n            hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&\n                !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n                    !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n                    [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n        };\n    }\n    function makeIDBKeyRange(range) {\n        if (range.type === 3 )\n            return null;\n        if (range.type === 4 )\n            throw new Error(\"Cannot convert never type to IDBKeyRange\");\n        const { lower, upper, lowerOpen, upperOpen } = range;\n        const idbRange = lower === undefined ?\n            upper === undefined ?\n                null :\n                IdbKeyRange.upperBound(upper, !!upperOpen) :\n            upper === undefined ?\n                IdbKeyRange.lowerBound(lower, !!lowerOpen) :\n                IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n        return idbRange;\n    }\n    function createDbCoreTable(tableSchema) {\n        const tableName = tableSchema.name;\n        function mutate({ trans, type, keys, values, range }) {\n            return new Promise((resolve, reject) => {\n                resolve = wrap(resolve);\n                const store = trans.objectStore(tableName);\n                const outbound = store.keyPath == null;\n                const isAddOrPut = type === \"put\" || type === \"add\";\n                if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')\n                    throw new Error(\"Invalid operation type: \" + type);\n                const { length } = keys || values || { length: 1 };\n                if (keys && values && keys.length !== values.length) {\n                    throw new Error(\"Given keys array must have same length as given values array.\");\n                }\n                if (length === 0)\n                    return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });\n                let req;\n                const reqs = [];\n                const failures = [];\n                let numFailures = 0;\n                const errorHandler = event => {\n                    ++numFailures;\n                    preventDefault(event);\n                };\n                if (type === 'deleteRange') {\n                    if (range.type === 4 )\n                        return resolve({ numFailures, failures, results: [], lastResult: undefined });\n                    if (range.type === 3 )\n                        reqs.push(req = store.clear());\n                    else\n                        reqs.push(req = store.delete(makeIDBKeyRange(range)));\n                }\n                else {\n                    const [args1, args2] = isAddOrPut ?\n                        outbound ?\n                            [values, keys] :\n                            [values, null] :\n                        [keys, null];\n                    if (isAddOrPut) {\n                        for (let i = 0; i < length; ++i) {\n                            reqs.push(req = (args2 && args2[i] !== undefined ?\n                                store[type](args1[i], args2[i]) :\n                                store[type](args1[i])));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                    else {\n                        for (let i = 0; i < length; ++i) {\n                            reqs.push(req = store[type](args1[i]));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                }\n                const done = event => {\n                    const lastResult = event.target.result;\n                    reqs.forEach((req, i) => req.error != null && (failures[i] = req.error));\n                    resolve({\n                        numFailures,\n                        failures,\n                        results: type === \"delete\" ? keys : reqs.map(req => req.result),\n                        lastResult\n                    });\n                };\n                req.onerror = event => {\n                    errorHandler(event);\n                    done(event);\n                };\n                req.onsuccess = done;\n            });\n        }\n        function openCursor({ trans, values, query, reverse, unique }) {\n            return new Promise((resolve, reject) => {\n                resolve = wrap(resolve);\n                const { index, range } = query;\n                const store = trans.objectStore(tableName);\n                const source = index.isPrimaryKey ?\n                    store :\n                    store.index(index.name);\n                const direction = reverse ?\n                    unique ?\n                        \"prevunique\" :\n                        \"prev\" :\n                    unique ?\n                        \"nextunique\" :\n                        \"next\";\n                const req = values || !('openKeyCursor' in source) ?\n                    source.openCursor(makeIDBKeyRange(range), direction) :\n                    source.openKeyCursor(makeIDBKeyRange(range), direction);\n                req.onerror = eventRejectHandler(reject);\n                req.onsuccess = wrap(ev => {\n                    const cursor = req.result;\n                    if (!cursor) {\n                        resolve(null);\n                        return;\n                    }\n                    cursor.___id = ++_id_counter;\n                    cursor.done = false;\n                    const _cursorContinue = cursor.continue.bind(cursor);\n                    let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n                    if (_cursorContinuePrimaryKey)\n                        _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n                    const _cursorAdvance = cursor.advance.bind(cursor);\n                    const doThrowCursorIsNotStarted = () => { throw new Error(\"Cursor not started\"); };\n                    const doThrowCursorIsStopped = () => { throw new Error(\"Cursor not stopped\"); };\n                    cursor.trans = trans;\n                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n                    cursor.fail = wrap(reject);\n                    cursor.next = function () {\n                        let gotOne = 1;\n                        return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);\n                    };\n                    cursor.start = (callback) => {\n                        const iterationPromise = new Promise((resolveIteration, rejectIteration) => {\n                            resolveIteration = wrap(resolveIteration);\n                            req.onerror = eventRejectHandler(rejectIteration);\n                            cursor.fail = rejectIteration;\n                            cursor.stop = value => {\n                                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                                resolveIteration(value);\n                            };\n                        });\n                        const guardedCallback = () => {\n                            if (req.result) {\n                                try {\n                                    callback();\n                                }\n                                catch (err) {\n                                    cursor.fail(err);\n                                }\n                            }\n                            else {\n                                cursor.done = true;\n                                cursor.start = () => { throw new Error(\"Cursor behind last entry\"); };\n                                cursor.stop();\n                            }\n                        };\n                        req.onsuccess = wrap(ev => {\n                            req.onsuccess = guardedCallback;\n                            guardedCallback();\n                        });\n                        cursor.continue = _cursorContinue;\n                        cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n                        cursor.advance = _cursorAdvance;\n                        guardedCallback();\n                        return iterationPromise;\n                    };\n                    resolve(cursor);\n                }, reject);\n            });\n        }\n        function query(hasGetAll) {\n            return (request) => {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const { trans, values, limit, query } = request;\n                    const nonInfinitLimit = limit === Infinity ? undefined : limit;\n                    const { index, range } = query;\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    if (limit === 0)\n                        return resolve({ result: [] });\n                    if (hasGetAll) {\n                        const req = values ?\n                            source.getAll(idbKeyRange, nonInfinitLimit) :\n                            source.getAllKeys(idbKeyRange, nonInfinitLimit);\n                        req.onsuccess = event => resolve({ result: event.target.result });\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                    else {\n                        let count = 0;\n                        const req = values || !('openKeyCursor' in source) ?\n                            source.openCursor(idbKeyRange) :\n                            source.openKeyCursor(idbKeyRange);\n                        const result = [];\n                        req.onsuccess = event => {\n                            const cursor = req.result;\n                            if (!cursor)\n                                return resolve({ result });\n                            result.push(values ? cursor.value : cursor.primaryKey);\n                            if (++count === limit)\n                                return resolve({ result });\n                            cursor.continue();\n                        };\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                });\n            };\n        }\n        return {\n            name: tableName,\n            schema: tableSchema,\n            mutate,\n            getMany({ trans, keys }) {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const length = keys.length;\n                    const result = new Array(length);\n                    let keyCount = 0;\n                    let callbackCount = 0;\n                    let req;\n                    const successHandler = event => {\n                        const req = event.target;\n                        if ((result[req._pos] = req.result) != null)\n                            ;\n                        if (++callbackCount === keyCount)\n                            resolve(result);\n                    };\n                    const errorHandler = eventRejectHandler(reject);\n                    for (let i = 0; i < length; ++i) {\n                        const key = keys[i];\n                        if (key != null) {\n                            req = store.get(keys[i]);\n                            req._pos = i;\n                            req.onsuccess = successHandler;\n                            req.onerror = errorHandler;\n                            ++keyCount;\n                        }\n                    }\n                    if (keyCount === 0)\n                        resolve(result);\n                });\n            },\n            get({ trans, key }) {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const req = store.get(key);\n                    req.onsuccess = event => resolve(event.target.result);\n                    req.onerror = eventRejectHandler(reject);\n                });\n            },\n            query: query(hasGetAll),\n            openCursor,\n            count({ query, trans }) {\n                const { index, range } = query;\n                return new Promise((resolve, reject) => {\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    const req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n                    req.onsuccess = wrap(ev => resolve(ev.target.result));\n                    req.onerror = eventRejectHandler(reject);\n                });\n            }\n        };\n    }\n    const { schema, hasGetAll } = extractSchema(db, tmpTrans);\n    const tables = schema.tables.map(tableSchema => createDbCoreTable(tableSchema));\n    const tableMap = {};\n    tables.forEach(table => tableMap[table.name] = table);\n    return {\n        stack: \"dbcore\",\n        transaction: db.transaction.bind(db),\n        table(name) {\n            const result = tableMap[name];\n            if (!result)\n                throw new Error(`Table '${name}' not found`);\n            return tableMap[name];\n        },\n        MIN_KEY: -Infinity,\n        MAX_KEY: getMaxKey(IdbKeyRange),\n        schema\n    };\n}\n\nfunction createMiddlewareStack(stackImpl, middlewares) {\n    return middlewares.reduce((down, { create }) => ({ ...down, ...create(down) }), stackImpl);\n}\nfunction createMiddlewareStacks(middlewares, idbdb, { IDBKeyRange, indexedDB }, tmpTrans) {\n    const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n    return {\n        dbcore\n    };\n}\nfunction generateMiddlewareStacks({ _novip: db }, tmpTrans) {\n    const idbdb = tmpTrans.db;\n    const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n    db.core = stacks.dbcore;\n    db.tables.forEach(table => {\n        const tableName = table.name;\n        if (db.core.schema.tables.some(tbl => tbl.name === tableName)) {\n            table.core = db.core.table(tableName);\n            if (db[tableName] instanceof db.Table) {\n                db[tableName].core = table.core;\n            }\n        }\n    });\n}\n\nfunction setApiOnPlace({ _novip: db }, objs, tableNames, dbschema) {\n    tableNames.forEach(tableName => {\n        const schema = dbschema[tableName];\n        objs.forEach(obj => {\n            const propDesc = getPropertyDescriptor(obj, tableName);\n            if (!propDesc || (\"value\" in propDesc && propDesc.value === undefined)) {\n                if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n                    setProp(obj, tableName, {\n                        get() { return this.table(tableName); },\n                        set(value) {\n                            defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });\n                        }\n                    });\n                }\n                else {\n                    obj[tableName] = new db.Table(tableName, schema);\n                }\n            }\n        });\n    });\n}\nfunction removeTablesApi({ _novip: db }, objs) {\n    objs.forEach(obj => {\n        for (let key in obj) {\n            if (obj[key] instanceof db.Table)\n                delete obj[key];\n        }\n    });\n}\nfunction lowerVersionFirst(a, b) {\n    return a._cfg.version - b._cfg.version;\n}\nfunction runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n    const globalSchema = db._dbSchema;\n    const trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n    trans.create(idbUpgradeTrans);\n    trans._completion.catch(reject);\n    const rejectTransaction = trans._reject.bind(trans);\n    const transless = PSD.transless || PSD;\n    newScope(() => {\n        PSD.trans = trans;\n        PSD.transless = transless;\n        if (oldVersion === 0) {\n            keys(globalSchema).forEach(tableName => {\n                createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n            });\n            generateMiddlewareStacks(db, idbUpgradeTrans);\n            DexiePromise.follow(() => db.on.populate.fire(trans)).catch(rejectTransaction);\n        }\n        else\n            updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);\n    });\n}\nfunction updateTablesAndIndexes({ _novip: db }, oldVersion, trans, idbUpgradeTrans) {\n    const queue = [];\n    const versions = db._versions;\n    let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n    let anyContentUpgraderHasRun = false;\n    const versToRun = versions.filter(v => v._cfg.version >= oldVersion);\n    versToRun.forEach(version => {\n        queue.push(() => {\n            const oldSchema = globalSchema;\n            const newSchema = version._cfg.dbschema;\n            adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n            adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n            globalSchema = db._dbSchema = newSchema;\n            const diff = getSchemaDiff(oldSchema, newSchema);\n            diff.add.forEach(tuple => {\n                createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n            });\n            diff.change.forEach(change => {\n                if (change.recreate) {\n                    throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n                }\n                else {\n                    const store = idbUpgradeTrans.objectStore(change.name);\n                    change.add.forEach(idx => addIndex(store, idx));\n                    change.change.forEach(idx => {\n                        store.deleteIndex(idx.name);\n                        addIndex(store, idx);\n                    });\n                    change.del.forEach(idxName => store.deleteIndex(idxName));\n                }\n            });\n            const contentUpgrade = version._cfg.contentUpgrade;\n            if (contentUpgrade && version._cfg.version > oldVersion) {\n                generateMiddlewareStacks(db, idbUpgradeTrans);\n                trans._memoizedTables = {};\n                anyContentUpgraderHasRun = true;\n                let upgradeSchema = shallowClone(newSchema);\n                diff.del.forEach(table => {\n                    upgradeSchema[table] = oldSchema[table];\n                });\n                removeTablesApi(db, [db.Transaction.prototype]);\n                setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema), upgradeSchema);\n                trans.schema = upgradeSchema;\n                const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);\n                if (contentUpgradeIsAsync) {\n                    incrementExpectedAwaits();\n                }\n                let returnValue;\n                const promiseFollowed = DexiePromise.follow(() => {\n                    returnValue = contentUpgrade(trans);\n                    if (returnValue) {\n                        if (contentUpgradeIsAsync) {\n                            var decrementor = decrementExpectedAwaits.bind(null, null);\n                            returnValue.then(decrementor, decrementor);\n                        }\n                    }\n                });\n                return (returnValue && typeof returnValue.then === 'function' ?\n                    DexiePromise.resolve(returnValue) : promiseFollowed.then(() => returnValue));\n            }\n        });\n        queue.push(idbtrans => {\n            if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\n                const newSchema = version._cfg.dbschema;\n                deleteRemovedTables(newSchema, idbtrans);\n            }\n            removeTablesApi(db, [db.Transaction.prototype]);\n            setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n            trans.schema = db._dbSchema;\n        });\n    });\n    function runQueue() {\n        return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :\n            DexiePromise.resolve();\n    }\n    return runQueue().then(() => {\n        createMissingTables(globalSchema, idbUpgradeTrans);\n    });\n}\nfunction getSchemaDiff(oldSchema, newSchema) {\n    const diff = {\n        del: [],\n        add: [],\n        change: []\n    };\n    let table;\n    for (table in oldSchema) {\n        if (!newSchema[table])\n            diff.del.push(table);\n    }\n    for (table in newSchema) {\n        const oldDef = oldSchema[table], newDef = newSchema[table];\n        if (!oldDef) {\n            diff.add.push([table, newDef]);\n        }\n        else {\n            const change = {\n                name: table,\n                def: newDef,\n                recreate: false,\n                del: [],\n                add: [],\n                change: []\n            };\n            if ((\n            '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||\n                (oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge))\n             {\n                change.recreate = true;\n                diff.change.push(change);\n            }\n            else {\n                const oldIndexes = oldDef.idxByName;\n                const newIndexes = newDef.idxByName;\n                let idxName;\n                for (idxName in oldIndexes) {\n                    if (!newIndexes[idxName])\n                        change.del.push(idxName);\n                }\n                for (idxName in newIndexes) {\n                    const oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n                    if (!oldIdx)\n                        change.add.push(newIdx);\n                    else if (oldIdx.src !== newIdx.src)\n                        change.change.push(newIdx);\n                }\n                if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n                    diff.change.push(change);\n                }\n            }\n        }\n    }\n    return diff;\n}\nfunction createTable(idbtrans, tableName, primKey, indexes) {\n    const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?\n        { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :\n        { autoIncrement: primKey.auto });\n    indexes.forEach(idx => addIndex(store, idx));\n    return store;\n}\nfunction createMissingTables(newSchema, idbtrans) {\n    keys(newSchema).forEach(tableName => {\n        if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n            createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n        }\n    });\n}\nfunction deleteRemovedTables(newSchema, idbtrans) {\n    [].slice.call(idbtrans.db.objectStoreNames).forEach(storeName => newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));\n}\nfunction addIndex(store, idx) {\n    store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\n}\nfunction buildGlobalSchema(db, idbdb, tmpTrans) {\n    const globalSchema = {};\n    const dbStoreNames = slice(idbdb.objectStoreNames, 0);\n    dbStoreNames.forEach(storeName => {\n        const store = tmpTrans.objectStore(storeName);\n        let keyPath = store.keyPath;\n        const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n        const indexes = [];\n        for (let j = 0; j < store.indexNames.length; ++j) {\n            const idbindex = store.index(store.indexNames[j]);\n            keyPath = idbindex.keyPath;\n            var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n            indexes.push(index);\n        }\n        globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n    });\n    return globalSchema;\n}\nfunction readGlobalSchema({ _novip: db }, idbdb, tmpTrans) {\n    db.verno = idbdb.version / 10;\n    const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n    db._storeNames = slice(idbdb.objectStoreNames, 0);\n    setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n}\nfunction verifyInstalledSchema(db, tmpTrans) {\n    const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n    const diff = getSchemaDiff(installedSchema, db._dbSchema);\n    return !(diff.add.length || diff.change.some(ch => ch.add.length || ch.change.length));\n}\nfunction adjustToExistingIndexNames({ _novip: db }, schema, idbtrans) {\n    const storeNames = idbtrans.db.objectStoreNames;\n    for (let i = 0; i < storeNames.length; ++i) {\n        const storeName = storeNames[i];\n        const store = idbtrans.objectStore(storeName);\n        db._hasGetAll = 'getAll' in store;\n        for (let j = 0; j < store.indexNames.length; ++j) {\n            const indexName = store.indexNames[j];\n            const keyPath = store.index(indexName).keyPath;\n            const dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n            if (schema[storeName]) {\n                const indexSpec = schema[storeName].idxByName[dexieName];\n                if (indexSpec) {\n                    indexSpec.name = indexName;\n                    delete schema[storeName].idxByName[dexieName];\n                    schema[storeName].idxByName[indexName] = indexSpec;\n                }\n            }\n        }\n    }\n    if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n        !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n        _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&\n        [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n        db._hasGetAll = false;\n    }\n}\nfunction parseIndexSyntax(primKeyAndIndexes) {\n    return primKeyAndIndexes.split(',').map((index, indexNum) => {\n        index = index.trim();\n        const name = index.replace(/([&*]|\\+\\+)/g, \"\");\n        const keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n        return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n    });\n}\n\nclass Version {\n    _parseStoresSpec(stores, outSchema) {\n        keys(stores).forEach(tableName => {\n            if (stores[tableName] !== null) {\n                var indexes = parseIndexSyntax(stores[tableName]);\n                var primKey = indexes.shift();\n                if (primKey.multi)\n                    throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n                indexes.forEach(idx => {\n                    if (idx.auto)\n                        throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n                    if (!idx.keyPath)\n                        throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n                });\n                outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n            }\n        });\n    }\n    stores(stores) {\n        const db = this.db;\n        this._cfg.storesSource = this._cfg.storesSource ?\n            extend(this._cfg.storesSource, stores) :\n            stores;\n        const versions = db._versions;\n        const storesSpec = {};\n        let dbschema = {};\n        versions.forEach(version => {\n            extend(storesSpec, version._cfg.storesSource);\n            dbschema = (version._cfg.dbschema = {});\n            version._parseStoresSpec(storesSpec, dbschema);\n        });\n        db._dbSchema = dbschema;\n        removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n        setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n        db._storeNames = keys(dbschema);\n        return this;\n    }\n    upgrade(upgradeFunction) {\n        this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n        return this;\n    }\n}\n\nfunction createVersionConstructor(db) {\n    return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n        this.db = db;\n        this._cfg = {\n            version: versionNumber,\n            storesSource: null,\n            dbschema: {},\n            tables: {},\n            contentUpgrade: null\n        };\n    });\n}\n\nfunction getDbNamesTable(indexedDB, IDBKeyRange) {\n    let dbNamesDB = indexedDB[\"_dbNamesDB\"];\n    if (!dbNamesDB) {\n        dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n            addons: [],\n            indexedDB,\n            IDBKeyRange,\n        });\n        dbNamesDB.version(1).stores({ dbnames: \"name\" });\n    }\n    return dbNamesDB.table(\"dbnames\");\n}\nfunction hasDatabasesNative(indexedDB) {\n    return indexedDB && typeof indexedDB.databases === \"function\";\n}\nfunction getDatabaseNames({ indexedDB, IDBKeyRange, }) {\n    return hasDatabasesNative(indexedDB)\n        ? Promise.resolve(indexedDB.databases()).then((infos) => infos\n            .map((info) => info.name)\n            .filter((name) => name !== DBNAMES_DB))\n        : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n}\nfunction _onDatabaseCreated({ indexedDB, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB) &&\n        name !== DBNAMES_DB &&\n        getDbNamesTable(indexedDB, IDBKeyRange).put({ name }).catch(nop);\n}\nfunction _onDatabaseDeleted({ indexedDB, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB) &&\n        name !== DBNAMES_DB &&\n        getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n}\n\nfunction vip(fn) {\n    return newScope(function () {\n        PSD.letThrough = true;\n        return fn();\n    });\n}\n\nfunction idbReady() {\n    var isSafari = !navigator.userAgentData &&\n        /Safari\\//.test(navigator.userAgent) &&\n        !/Chrom(e|ium)\\//.test(navigator.userAgent);\n    if (!isSafari || !indexedDB.databases)\n        return Promise.resolve();\n    var intervalId;\n    return new Promise(function (resolve) {\n        var tryIdb = function () { return indexedDB.databases().finally(resolve); };\n        intervalId = setInterval(tryIdb, 100);\n        tryIdb();\n    }).finally(function () { return clearInterval(intervalId); });\n}\n\nfunction dexieOpen(db) {\n    const state = db._state;\n    const { indexedDB } = db._deps;\n    if (state.isBeingOpened || db.idbdb)\n        return state.dbReadyPromise.then(() => state.dbOpenError ?\n            rejection(state.dbOpenError) :\n            db);\n    debug && (state.openCanceller._stackHolder = getErrorWithStack());\n    state.isBeingOpened = true;\n    state.dbOpenError = null;\n    state.openComplete = false;\n    const openCanceller = state.openCanceller;\n    function throwIfCancelled() {\n        if (state.openCanceller !== openCanceller)\n            throw new exceptions.DatabaseClosed('db.open() was cancelled');\n    }\n    let resolveDbReady = state.dbReadyResolve,\n    upgradeTransaction = null, wasCreated = false;\n    return DexiePromise.race([openCanceller, (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(() => new DexiePromise((resolve, reject) => {\n            throwIfCancelled();\n            if (!indexedDB)\n                throw new exceptions.MissingAPI();\n            const dbName = db.name;\n            const req = state.autoSchema ?\n                indexedDB.open(dbName) :\n                indexedDB.open(dbName, Math.round(db.verno * 10));\n            if (!req)\n                throw new exceptions.MissingAPI();\n            req.onerror = eventRejectHandler(reject);\n            req.onblocked = wrap(db._fireOnBlocked);\n            req.onupgradeneeded = wrap(e => {\n                upgradeTransaction = req.transaction;\n                if (state.autoSchema && !db._options.allowEmptyDB) {\n                    req.onerror = preventDefault;\n                    upgradeTransaction.abort();\n                    req.result.close();\n                    const delreq = indexedDB.deleteDatabase(dbName);\n                    delreq.onsuccess = delreq.onerror = wrap(() => {\n                        reject(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));\n                    });\n                }\n                else {\n                    upgradeTransaction.onerror = eventRejectHandler(reject);\n                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n                    wasCreated = oldVer < 1;\n                    db._novip.idbdb = req.result;\n                    runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n                }\n            }, reject);\n            req.onsuccess = wrap(() => {\n                upgradeTransaction = null;\n                const idbdb = db._novip.idbdb = req.result;\n                const objectStoreNames = slice(idbdb.objectStoreNames);\n                if (objectStoreNames.length > 0)\n                    try {\n                        const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n                        if (state.autoSchema)\n                            readGlobalSchema(db, idbdb, tmpTrans);\n                        else {\n                            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n                            if (!verifyInstalledSchema(db, tmpTrans)) {\n                                console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);\n                            }\n                        }\n                        generateMiddlewareStacks(db, tmpTrans);\n                    }\n                    catch (e) {\n                    }\n                connections.push(db);\n                idbdb.onversionchange = wrap(ev => {\n                    state.vcFired = true;\n                    db.on(\"versionchange\").fire(ev);\n                });\n                idbdb.onclose = wrap(ev => {\n                    db.on(\"close\").fire(ev);\n                });\n                if (wasCreated)\n                    _onDatabaseCreated(db._deps, dbName);\n                resolve();\n            }, reject);\n        }))]).then(() => {\n        throwIfCancelled();\n        state.onReadyBeingFired = [];\n        return DexiePromise.resolve(vip(() => db.on.ready.fire(db.vip))).then(function fireRemainders() {\n            if (state.onReadyBeingFired.length > 0) {\n                let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);\n                state.onReadyBeingFired = [];\n                return DexiePromise.resolve(vip(() => remainders(db.vip))).then(fireRemainders);\n            }\n        });\n    }).finally(() => {\n        state.onReadyBeingFired = null;\n        state.isBeingOpened = false;\n    }).then(() => {\n        return db;\n    }).catch(err => {\n        state.dbOpenError = err;\n        try {\n            upgradeTransaction && upgradeTransaction.abort();\n        }\n        catch (_a) { }\n        if (openCanceller === state.openCanceller) {\n            db._close();\n        }\n        return rejection(err);\n    }).finally(() => {\n        state.openComplete = true;\n        resolveDbReady();\n    });\n}\n\nfunction awaitIterator(iterator) {\n    var callNext = result => iterator.next(result), doThrow = error => iterator.throw(error), onSuccess = step(callNext), onError = step(doThrow);\n    function step(getNext) {\n        return (val) => {\n            var next = getNext(val), value = next.value;\n            return next.done ? value :\n                (!value || typeof value.then !== 'function' ?\n                    isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :\n                    value.then(onSuccess, onError));\n        };\n    }\n    return step(callNext)();\n}\n\nfunction extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n    var i = arguments.length;\n    if (i < 2)\n        throw new exceptions.InvalidArgument(\"Too few arguments\");\n    var args = new Array(i - 1);\n    while (--i)\n        args[i - 1] = arguments[i];\n    scopeFunc = args.pop();\n    var tables = flatten(args);\n    return [mode, tables, scopeFunc];\n}\nfunction enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n    return DexiePromise.resolve().then(() => {\n        const transless = PSD.transless || PSD;\n        const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n        const zoneProps = {\n            trans: trans,\n            transless: transless\n        };\n        if (parentTransaction) {\n            trans.idbtrans = parentTransaction.idbtrans;\n        }\n        else {\n            trans.create();\n        }\n        const scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n        if (scopeFuncIsAsync) {\n            incrementExpectedAwaits();\n        }\n        let returnValue;\n        const promiseFollowed = DexiePromise.follow(() => {\n            returnValue = scopeFunc.call(trans, trans);\n            if (returnValue) {\n                if (scopeFuncIsAsync) {\n                    var decrementor = decrementExpectedAwaits.bind(null, null);\n                    returnValue.then(decrementor, decrementor);\n                }\n                else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n                    returnValue = awaitIterator(returnValue);\n                }\n            }\n        }, zoneProps);\n        return (returnValue && typeof returnValue.then === 'function' ?\n            DexiePromise.resolve(returnValue).then(x => trans.active ?\n                x\n                : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\")))\n            : promiseFollowed.then(() => returnValue)).then(x => {\n            if (parentTransaction)\n                trans._resolve();\n            return trans._completion.then(() => x);\n        }).catch(e => {\n            trans._reject(e);\n            return rejection(e);\n        });\n    });\n}\n\nfunction pad(a, value, count) {\n    const result = isArray(a) ? a.slice() : [a];\n    for (let i = 0; i < count; ++i)\n        result.push(value);\n    return result;\n}\nfunction createVirtualIndexMiddleware(down) {\n    return {\n        ...down,\n        table(tableName) {\n            const table = down.table(tableName);\n            const { schema } = table;\n            const indexLookup = {};\n            const allVirtualIndexes = [];\n            function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n                const keyPathAlias = getKeyPathAlias(keyPath);\n                const indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);\n                const keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n                const isVirtual = keyTail > 0;\n                const virtualIndex = {\n                    ...lowLevelIndex,\n                    isVirtual,\n                    keyTail,\n                    keyLength,\n                    extractKey: getKeyExtractor(keyPath),\n                    unique: !isVirtual && lowLevelIndex.unique\n                };\n                indexList.push(virtualIndex);\n                if (!virtualIndex.isPrimaryKey) {\n                    allVirtualIndexes.push(virtualIndex);\n                }\n                if (keyLength > 1) {\n                    const virtualKeyPath = keyLength === 2 ?\n                        keyPath[0] :\n                        keyPath.slice(0, keyLength - 1);\n                    addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n                }\n                indexList.sort((a, b) => a.keyTail - b.keyTail);\n                return virtualIndex;\n            }\n            const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n            indexLookup[\":id\"] = [primaryKey];\n            for (const index of schema.indexes) {\n                addVirtualIndexes(index.keyPath, 0, index);\n            }\n            function findBestIndex(keyPath) {\n                const result = indexLookup[getKeyPathAlias(keyPath)];\n                return result && result[0];\n            }\n            function translateRange(range, keyTail) {\n                return {\n                    type: range.type === 1  ?\n                        2  :\n                        range.type,\n                    lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n                    lowerOpen: true,\n                    upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n                    upperOpen: true\n                };\n            }\n            function translateRequest(req) {\n                const index = req.query.index;\n                return index.isVirtual ? {\n                    ...req,\n                    query: {\n                        index,\n                        range: translateRange(req.query.range, index.keyTail)\n                    }\n                } : req;\n            }\n            const result = {\n                ...table,\n                schema: {\n                    ...schema,\n                    primaryKey,\n                    indexes: allVirtualIndexes,\n                    getIndexByKeyPath: findBestIndex\n                },\n                count(req) {\n                    return table.count(translateRequest(req));\n                },\n                query(req) {\n                    return table.query(translateRequest(req));\n                },\n                openCursor(req) {\n                    const { keyTail, isVirtual, keyLength } = req.query.index;\n                    if (!isVirtual)\n                        return table.openCursor(req);\n                    function createVirtualCursor(cursor) {\n                        function _continue(key) {\n                            key != null ?\n                                cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :\n                                req.unique ?\n                                    cursor.continue(cursor.key.slice(0, keyLength)\n                                        .concat(req.reverse\n                                        ? down.MIN_KEY\n                                        : down.MAX_KEY, keyTail)) :\n                                    cursor.continue();\n                        }\n                        const virtualCursor = Object.create(cursor, {\n                            continue: { value: _continue },\n                            continuePrimaryKey: {\n                                value(key, primaryKey) {\n                                    cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                                }\n                            },\n                            primaryKey: {\n                                get() {\n                                    return cursor.primaryKey;\n                                }\n                            },\n                            key: {\n                                get() {\n                                    const key = cursor.key;\n                                    return keyLength === 1 ?\n                                        key[0] :\n                                        key.slice(0, keyLength);\n                                }\n                            },\n                            value: {\n                                get() {\n                                    return cursor.value;\n                                }\n                            }\n                        });\n                        return virtualCursor;\n                    }\n                    return table.openCursor(translateRequest(req))\n                        .then(cursor => cursor && createVirtualCursor(cursor));\n                }\n            };\n            return result;\n        }\n    };\n}\nconst virtualIndexMiddleware = {\n    stack: \"dbcore\",\n    name: \"VirtualIndexMiddleware\",\n    level: 1,\n    create: createVirtualIndexMiddleware\n};\n\nfunction getObjectDiff(a, b, rv, prfx) {\n    rv = rv || {};\n    prfx = prfx || '';\n    keys(a).forEach((prop) => {\n        if (!hasOwn(b, prop)) {\n            rv[prfx + prop] = undefined;\n        }\n        else {\n            var ap = a[prop], bp = b[prop];\n            if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n                const apTypeName = toStringTag(ap);\n                const bpTypeName = toStringTag(bp);\n                if (apTypeName !== bpTypeName) {\n                    rv[prfx + prop] = b[prop];\n                }\n                else if (apTypeName === 'Object') {\n                    getObjectDiff(ap, bp, rv, prfx + prop + '.');\n                }\n                else if (ap !== bp) {\n                    rv[prfx + prop] = b[prop];\n                }\n            }\n            else if (ap !== bp)\n                rv[prfx + prop] = b[prop];\n        }\n    });\n    keys(b).forEach((prop) => {\n        if (!hasOwn(a, prop)) {\n            rv[prfx + prop] = b[prop];\n        }\n    });\n    return rv;\n}\n\nfunction getEffectiveKeys(primaryKey, req) {\n    if (req.type === 'delete')\n        return req.keys;\n    return req.keys || req.values.map(primaryKey.extractKey);\n}\n\nconst hooksMiddleware = {\n    stack: \"dbcore\",\n    name: \"HooksMiddleware\",\n    level: 2,\n    create: (downCore) => ({\n        ...downCore,\n        table(tableName) {\n            const downTable = downCore.table(tableName);\n            const { primaryKey } = downTable.schema;\n            const tableMiddleware = {\n                ...downTable,\n                mutate(req) {\n                    const dxTrans = PSD.trans;\n                    const { deleting, creating, updating } = dxTrans.table(tableName).hook;\n                    switch (req.type) {\n                        case 'add':\n                            if (creating.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'put':\n                            if (creating.fire === nop && updating.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'delete':\n                            if (deleting.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'deleteRange':\n                            if (deleting.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => deleteRange(req), true);\n                    }\n                    return downTable.mutate(req);\n                    function addPutOrDelete(req) {\n                        const dxTrans = PSD.trans;\n                        const keys = req.keys || getEffectiveKeys(primaryKey, req);\n                        if (!keys)\n                            throw new Error(\"Keys missing\");\n                        req = req.type === 'add' || req.type === 'put' ?\n                            { ...req, keys } :\n                            { ...req };\n                        if (req.type !== 'delete')\n                            req.values = [...req.values];\n                        if (req.keys)\n                            req.keys = [...req.keys];\n                        return getExistingValues(downTable, req, keys).then(existingValues => {\n                            const contexts = keys.map((key, i) => {\n                                const existingValue = existingValues[i];\n                                const ctx = { onerror: null, onsuccess: null };\n                                if (req.type === 'delete') {\n                                    deleting.fire.call(ctx, key, existingValue, dxTrans);\n                                }\n                                else if (req.type === 'add' || existingValue === undefined) {\n                                    const generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n                                    if (key == null && generatedPrimaryKey != null) {\n                                        key = generatedPrimaryKey;\n                                        req.keys[i] = key;\n                                        if (!primaryKey.outbound) {\n                                            setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                                        }\n                                    }\n                                }\n                                else {\n                                    const objectDiff = getObjectDiff(existingValue, req.values[i]);\n                                    const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n                                    if (additionalChanges) {\n                                        const requestedValue = req.values[i];\n                                        Object.keys(additionalChanges).forEach(keyPath => {\n                                            if (hasOwn(requestedValue, keyPath)) {\n                                                requestedValue[keyPath] = additionalChanges[keyPath];\n                                            }\n                                            else {\n                                                setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);\n                                            }\n                                        });\n                                    }\n                                }\n                                return ctx;\n                            });\n                            return downTable.mutate(req).then(({ failures, results, numFailures, lastResult }) => {\n                                for (let i = 0; i < keys.length; ++i) {\n                                    const primKey = results ? results[i] : keys[i];\n                                    const ctx = contexts[i];\n                                    if (primKey == null) {\n                                        ctx.onerror && ctx.onerror(failures[i]);\n                                    }\n                                    else {\n                                        ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?\n                                            req.values[i] :\n                                            primKey\n                                        );\n                                    }\n                                }\n                                return { failures, results, numFailures, lastResult };\n                            }).catch(error => {\n                                contexts.forEach(ctx => ctx.onerror && ctx.onerror(error));\n                                return Promise.reject(error);\n                            });\n                        });\n                    }\n                    function deleteRange(req) {\n                        return deleteNextChunk(req.trans, req.range, 10000);\n                    }\n                    function deleteNextChunk(trans, range, limit) {\n                        return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit })\n                            .then(({ result }) => {\n                            return addPutOrDelete({ type: 'delete', keys: result, trans }).then(res => {\n                                if (res.numFailures > 0)\n                                    return Promise.reject(res.failures[0]);\n                                if (result.length < limit) {\n                                    return { failures: [], numFailures: 0, lastResult: undefined };\n                                }\n                                else {\n                                    return deleteNextChunk(trans, { ...range, lower: result[result.length - 1], lowerOpen: true }, limit);\n                                }\n                            });\n                        });\n                    }\n                }\n            };\n            return tableMiddleware;\n        },\n    })\n};\nfunction getExistingValues(table, req, effectiveKeys) {\n    return req.type === \"add\"\n        ? Promise.resolve([])\n        : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: \"immutable\" });\n}\n\nfunction getFromTransactionCache(keys, cache, clone) {\n    try {\n        if (!cache)\n            return null;\n        if (cache.keys.length < keys.length)\n            return null;\n        const result = [];\n        for (let i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n            if (cmp(cache.keys[i], keys[j]) !== 0)\n                continue;\n            result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n            ++j;\n        }\n        return result.length === keys.length ? result : null;\n    }\n    catch (_a) {\n        return null;\n    }\n}\nconst cacheExistingValuesMiddleware = {\n    stack: \"dbcore\",\n    level: -1,\n    create: (core) => {\n        return {\n            table: (tableName) => {\n                const table = core.table(tableName);\n                return {\n                    ...table,\n                    getMany: (req) => {\n                        if (!req.cache) {\n                            return table.getMany(req);\n                        }\n                        const cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n                        if (cachedResult) {\n                            return DexiePromise.resolve(cachedResult);\n                        }\n                        return table.getMany(req).then((res) => {\n                            req.trans[\"_cache\"] = {\n                                keys: req.keys,\n                                values: req.cache === \"clone\" ? deepClone(res) : res,\n                            };\n                            return res;\n                        });\n                    },\n                    mutate: (req) => {\n                        if (req.type !== \"add\")\n                            req.trans[\"_cache\"] = null;\n                        return table.mutate(req);\n                    },\n                };\n            },\n        };\n    },\n};\n\nfunction isEmptyRange(node) {\n    return !(\"from\" in node);\n}\nconst RangeSet = function (fromOrTree, to) {\n    if (this) {\n        extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });\n    }\n    else {\n        const rv = new RangeSet();\n        if (fromOrTree && (\"d\" in fromOrTree)) {\n            extend(rv, fromOrTree);\n        }\n        return rv;\n    }\n};\nprops(RangeSet.prototype, {\n    add(rangeSet) {\n        mergeRanges(this, rangeSet);\n        return this;\n    },\n    addKey(key) {\n        addRange(this, key, key);\n        return this;\n    },\n    addKeys(keys) {\n        keys.forEach(key => addRange(this, key, key));\n        return this;\n    },\n    [iteratorSymbol]() {\n        return getRangeSetIterator(this);\n    }\n});\nfunction addRange(target, from, to) {\n    const diff = cmp(from, to);\n    if (isNaN(diff))\n        return;\n    if (diff > 0)\n        throw RangeError();\n    if (isEmptyRange(target))\n        return extend(target, { from, to, d: 1 });\n    const left = target.l;\n    const right = target.r;\n    if (cmp(to, target.from) < 0) {\n        left\n            ? addRange(left, from, to)\n            : (target.l = { from, to, d: 1, l: null, r: null });\n        return rebalance(target);\n    }\n    if (cmp(from, target.to) > 0) {\n        right\n            ? addRange(right, from, to)\n            : (target.r = { from, to, d: 1, l: null, r: null });\n        return rebalance(target);\n    }\n    if (cmp(from, target.from) < 0) {\n        target.from = from;\n        target.l = null;\n        target.d = right ? right.d + 1 : 1;\n    }\n    if (cmp(to, target.to) > 0) {\n        target.to = to;\n        target.r = null;\n        target.d = target.l ? target.l.d + 1 : 1;\n    }\n    const rightWasCutOff = !target.r;\n    if (left && !target.l) {\n        mergeRanges(target, left);\n    }\n    if (right && rightWasCutOff) {\n        mergeRanges(target, right);\n    }\n}\nfunction mergeRanges(target, newSet) {\n    function _addRangeSet(target, { from, to, l, r }) {\n        addRange(target, from, to);\n        if (l)\n            _addRangeSet(target, l);\n        if (r)\n            _addRangeSet(target, r);\n    }\n    if (!isEmptyRange(newSet))\n        _addRangeSet(target, newSet);\n}\nfunction rangesOverlap(rangeSet1, rangeSet2) {\n    const i1 = getRangeSetIterator(rangeSet2);\n    let nextResult1 = i1.next();\n    if (nextResult1.done)\n        return false;\n    let a = nextResult1.value;\n    const i2 = getRangeSetIterator(rangeSet1);\n    let nextResult2 = i2.next(a.from);\n    let b = nextResult2.value;\n    while (!nextResult1.done && !nextResult2.done) {\n        if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)\n            return true;\n        cmp(a.from, b.from) < 0\n            ? (a = (nextResult1 = i1.next(b.from)).value)\n            : (b = (nextResult2 = i2.next(a.from)).value);\n    }\n    return false;\n}\nfunction getRangeSetIterator(node) {\n    let state = isEmptyRange(node) ? null : { s: 0, n: node };\n    return {\n        next(key) {\n            const keyProvided = arguments.length > 0;\n            while (state) {\n                switch (state.s) {\n                    case 0:\n                        state.s = 1;\n                        if (keyProvided) {\n                            while (state.n.l && cmp(key, state.n.from) < 0)\n                                state = { up: state, n: state.n.l, s: 1 };\n                        }\n                        else {\n                            while (state.n.l)\n                                state = { up: state, n: state.n.l, s: 1 };\n                        }\n                    case 1:\n                        state.s = 2;\n                        if (!keyProvided || cmp(key, state.n.to) <= 0)\n                            return { value: state.n, done: false };\n                    case 2:\n                        if (state.n.r) {\n                            state.s = 3;\n                            state = { up: state, n: state.n.r, s: 0 };\n                            continue;\n                        }\n                    case 3:\n                        state = state.up;\n                }\n            }\n            return { done: true };\n        },\n    };\n}\nfunction rebalance(target) {\n    var _a, _b;\n    const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n    const r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n    if (r) {\n        const l = r === \"r\" ? \"l\" : \"r\";\n        const rootClone = { ...target };\n        const oldRootRight = target[r];\n        target.from = oldRootRight.from;\n        target.to = oldRootRight.to;\n        target[r] = oldRootRight[r];\n        rootClone[r] = oldRootRight[l];\n        target[l] = rootClone;\n        rootClone.d = computeDepth(rootClone);\n    }\n    target.d = computeDepth(target);\n}\nfunction computeDepth({ r, l }) {\n    return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;\n}\n\nconst observabilityMiddleware = {\n    stack: \"dbcore\",\n    level: 0,\n    create: (core) => {\n        const dbName = core.schema.name;\n        const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n        return {\n            ...core,\n            table: (tableName) => {\n                const table = core.table(tableName);\n                const { schema } = table;\n                const { primaryKey } = schema;\n                const { extractKey, outbound } = primaryKey;\n                const tableClone = {\n                    ...table,\n                    mutate: (req) => {\n                        const trans = req.trans;\n                        const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});\n                        const getRangeSet = (indexName) => {\n                            const part = `idb://${dbName}/${tableName}/${indexName}`;\n                            return (mutatedParts[part] ||\n                                (mutatedParts[part] = new RangeSet()));\n                        };\n                        const pkRangeSet = getRangeSet(\"\");\n                        const delsRangeSet = getRangeSet(\":dels\");\n                        const { type } = req;\n                        let [keys, newObjs] = req.type === \"deleteRange\"\n                            ? [req.range]\n                            : req.type === \"delete\"\n                                ? [req.keys]\n                                : req.values.length < 50\n                                    ? [[], req.values]\n                                    : [];\n                        const oldCache = req.trans[\"_cache\"];\n                        return table.mutate(req).then((res) => {\n                            if (isArray(keys)) {\n                                if (type !== \"delete\")\n                                    keys = res.results;\n                                pkRangeSet.addKeys(keys);\n                                const oldObjs = getFromTransactionCache(keys, oldCache);\n                                if (!oldObjs && type !== \"add\") {\n                                    delsRangeSet.addKeys(keys);\n                                }\n                                if (oldObjs || newObjs) {\n                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                                }\n                            }\n                            else if (keys) {\n                                const range = { from: keys.lower, to: keys.upper };\n                                delsRangeSet.add(range);\n                                pkRangeSet.add(range);\n                            }\n                            else {\n                                pkRangeSet.add(FULL_RANGE);\n                                delsRangeSet.add(FULL_RANGE);\n                                schema.indexes.forEach(idx => getRangeSet(idx.name).add(FULL_RANGE));\n                            }\n                            return res;\n                        });\n                    },\n                };\n                const getRange = ({ query: { index, range }, }) => {\n                    var _a, _b;\n                    return [\n                        index,\n                        new RangeSet((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY),\n                    ];\n                };\n                const readSubscribers = {\n                    get: (req) => [primaryKey, new RangeSet(req.key)],\n                    getMany: (req) => [primaryKey, new RangeSet().addKeys(req.keys)],\n                    count: getRange,\n                    query: getRange,\n                    openCursor: getRange,\n                };\n                keys(readSubscribers).forEach(method => {\n                    tableClone[method] = function (req) {\n                        const { subscr } = PSD;\n                        if (subscr) {\n                            const getRangeSet = (indexName) => {\n                                const part = `idb://${dbName}/${tableName}/${indexName}`;\n                                return (subscr[part] ||\n                                    (subscr[part] = new RangeSet()));\n                            };\n                            const pkRangeSet = getRangeSet(\"\");\n                            const delsRangeSet = getRangeSet(\":dels\");\n                            const [queriedIndex, queriedRanges] = readSubscribers[method](req);\n                            getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n                            if (!queriedIndex.isPrimaryKey) {\n                                if (method === \"count\") {\n                                    delsRangeSet.add(FULL_RANGE);\n                                }\n                                else {\n                                    const keysPromise = method === \"query\" &&\n                                        outbound &&\n                                        req.values &&\n                                        table.query({\n                                            ...req,\n                                            values: false,\n                                        });\n                                    return table[method].apply(this, arguments).then((res) => {\n                                        if (method === \"query\") {\n                                            if (outbound && req.values) {\n                                                return keysPromise.then(({ result: resultingKeys }) => {\n                                                    pkRangeSet.addKeys(resultingKeys);\n                                                    return res;\n                                                });\n                                            }\n                                            const pKeys = req.values\n                                                ? res.result.map(extractKey)\n                                                : res.result;\n                                            if (req.values) {\n                                                pkRangeSet.addKeys(pKeys);\n                                            }\n                                            else {\n                                                delsRangeSet.addKeys(pKeys);\n                                            }\n                                        }\n                                        else if (method === \"openCursor\") {\n                                            const cursor = res;\n                                            const wantValues = req.values;\n                                            return (cursor &&\n                                                Object.create(cursor, {\n                                                    key: {\n                                                        get() {\n                                                            delsRangeSet.addKey(cursor.primaryKey);\n                                                            return cursor.key;\n                                                        },\n                                                    },\n                                                    primaryKey: {\n                                                        get() {\n                                                            const pkey = cursor.primaryKey;\n                                                            delsRangeSet.addKey(pkey);\n                                                            return pkey;\n                                                        },\n                                                    },\n                                                    value: {\n                                                        get() {\n                                                            wantValues && pkRangeSet.addKey(cursor.primaryKey);\n                                                            return cursor.value;\n                                                        },\n                                                    },\n                                                }));\n                                        }\n                                        return res;\n                                    });\n                                }\n                            }\n                        }\n                        return table[method].apply(this, arguments);\n                    };\n                });\n                return tableClone;\n            },\n        };\n    },\n};\nfunction trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n    function addAffectedIndex(ix) {\n        const rangeSet = getRangeSet(ix.name || \"\");\n        function extractKey(obj) {\n            return obj != null ? ix.extractKey(obj) : null;\n        }\n        const addKeyOrKeys = (key) => ix.multiEntry && isArray(key)\n            ? key.forEach(key => rangeSet.addKey(key))\n            : rangeSet.addKey(key);\n        (oldObjs || newObjs).forEach((_, i) => {\n            const oldKey = oldObjs && extractKey(oldObjs[i]);\n            const newKey = newObjs && extractKey(newObjs[i]);\n            if (cmp(oldKey, newKey) !== 0) {\n                if (oldKey != null)\n                    addKeyOrKeys(oldKey);\n                if (newKey != null)\n                    addKeyOrKeys(newKey);\n            }\n        });\n    }\n    schema.indexes.forEach(addAffectedIndex);\n}\n\nclass Dexie$1 {\n    constructor(name, options) {\n        this._middlewares = {};\n        this.verno = 0;\n        const deps = Dexie$1.dependencies;\n        this._options = options = {\n            addons: Dexie$1.addons,\n            autoOpen: true,\n            indexedDB: deps.indexedDB,\n            IDBKeyRange: deps.IDBKeyRange,\n            ...options\n        };\n        this._deps = {\n            indexedDB: options.indexedDB,\n            IDBKeyRange: options.IDBKeyRange\n        };\n        const { addons, } = options;\n        this._dbSchema = {};\n        this._versions = [];\n        this._storeNames = [];\n        this._allTables = {};\n        this.idbdb = null;\n        this._novip = this;\n        const state = {\n            dbOpenError: null,\n            isBeingOpened: false,\n            onReadyBeingFired: null,\n            openComplete: false,\n            dbReadyResolve: nop,\n            dbReadyPromise: null,\n            cancelOpen: nop,\n            openCanceller: null,\n            autoSchema: true\n        };\n        state.dbReadyPromise = new DexiePromise(resolve => {\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject) => {\n            state.cancelOpen = reject;\n        });\n        this._state = state;\n        this.name = name;\n        this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", { ready: [promisableChain, nop] });\n        this.on.ready.subscribe = override(this.on.ready.subscribe, subscribe => {\n            return (subscriber, bSticky) => {\n                Dexie$1.vip(() => {\n                    const state = this._state;\n                    if (state.openComplete) {\n                        if (!state.dbOpenError)\n                            DexiePromise.resolve().then(subscriber);\n                        if (bSticky)\n                            subscribe(subscriber);\n                    }\n                    else if (state.onReadyBeingFired) {\n                        state.onReadyBeingFired.push(subscriber);\n                        if (bSticky)\n                            subscribe(subscriber);\n                    }\n                    else {\n                        subscribe(subscriber);\n                        const db = this;\n                        if (!bSticky)\n                            subscribe(function unsubscribe() {\n                                db.on.ready.unsubscribe(subscriber);\n                                db.on.ready.unsubscribe(unsubscribe);\n                            });\n                    }\n                });\n            };\n        });\n        this.Collection = createCollectionConstructor(this);\n        this.Table = createTableConstructor(this);\n        this.Transaction = createTransactionConstructor(this);\n        this.Version = createVersionConstructor(this);\n        this.WhereClause = createWhereClauseConstructor(this);\n        this.on(\"versionchange\", ev => {\n            if (ev.newVersion > 0)\n                console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);\n            else\n                console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);\n            this.close();\n        });\n        this.on(\"blocked\", ev => {\n            if (!ev.newVersion || ev.newVersion < ev.oldVersion)\n                console.warn(`Dexie.delete('${this.name}') was blocked`);\n            else\n                console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);\n        });\n        this._maxKey = getMaxKey(options.IDBKeyRange);\n        this._createTransaction = (mode, storeNames, dbschema, parentTransaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);\n        this._fireOnBlocked = ev => {\n            this.on(\"blocked\").fire(ev);\n            connections\n                .filter(c => c.name === this.name && c !== this && !c._state.vcFired)\n                .map(c => c.on(\"versionchange\").fire(ev));\n        };\n        this.use(virtualIndexMiddleware);\n        this.use(hooksMiddleware);\n        this.use(observabilityMiddleware);\n        this.use(cacheExistingValuesMiddleware);\n        this.vip = Object.create(this, { _vip: { value: true } });\n        addons.forEach(addon => addon(this));\n    }\n    version(versionNumber) {\n        if (isNaN(versionNumber) || versionNumber < 0.1)\n            throw new exceptions.Type(`Given version is not a positive number`);\n        versionNumber = Math.round(versionNumber * 10) / 10;\n        if (this.idbdb || this._state.isBeingOpened)\n            throw new exceptions.Schema(\"Cannot add version when database is open\");\n        this.verno = Math.max(this.verno, versionNumber);\n        const versions = this._versions;\n        var versionInstance = versions.filter(v => v._cfg.version === versionNumber)[0];\n        if (versionInstance)\n            return versionInstance;\n        versionInstance = new this.Version(versionNumber);\n        versions.push(versionInstance);\n        versions.sort(lowerVersionFirst);\n        versionInstance.stores({});\n        this._state.autoSchema = false;\n        return versionInstance;\n    }\n    _whenReady(fn) {\n        return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise((resolve, reject) => {\n            if (this._state.openComplete) {\n                return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));\n            }\n            if (!this._state.isBeingOpened) {\n                if (!this._options.autoOpen) {\n                    reject(new exceptions.DatabaseClosed());\n                    return;\n                }\n                this.open().catch(nop);\n            }\n            this._state.dbReadyPromise.then(resolve, reject);\n        }).then(fn);\n    }\n    use({ stack, create, level, name }) {\n        if (name)\n            this.unuse({ stack, name });\n        const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n        middlewares.push({ stack, create, level: level == null ? 10 : level, name });\n        middlewares.sort((a, b) => a.level - b.level);\n        return this;\n    }\n    unuse({ stack, name, create }) {\n        if (stack && this._middlewares[stack]) {\n            this._middlewares[stack] = this._middlewares[stack].filter(mw => create ? mw.create !== create :\n                name ? mw.name !== name :\n                    false);\n        }\n        return this;\n    }\n    open() {\n        return dexieOpen(this);\n    }\n    _close() {\n        const state = this._state;\n        const idx = connections.indexOf(this);\n        if (idx >= 0)\n            connections.splice(idx, 1);\n        if (this.idbdb) {\n            try {\n                this.idbdb.close();\n            }\n            catch (e) { }\n            this._novip.idbdb = null;\n        }\n        state.dbReadyPromise = new DexiePromise(resolve => {\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject) => {\n            state.cancelOpen = reject;\n        });\n    }\n    close() {\n        this._close();\n        const state = this._state;\n        this._options.autoOpen = false;\n        state.dbOpenError = new exceptions.DatabaseClosed();\n        if (state.isBeingOpened)\n            state.cancelOpen(state.dbOpenError);\n    }\n    delete() {\n        const hasArguments = arguments.length > 0;\n        const state = this._state;\n        return new DexiePromise((resolve, reject) => {\n            const doDelete = () => {\n                this.close();\n                var req = this._deps.indexedDB.deleteDatabase(this.name);\n                req.onsuccess = wrap(() => {\n                    _onDatabaseDeleted(this._deps, this.name);\n                    resolve();\n                });\n                req.onerror = eventRejectHandler(reject);\n                req.onblocked = this._fireOnBlocked;\n            };\n            if (hasArguments)\n                throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n            if (state.isBeingOpened) {\n                state.dbReadyPromise.then(doDelete);\n            }\n            else {\n                doDelete();\n            }\n        });\n    }\n    backendDB() {\n        return this.idbdb;\n    }\n    isOpen() {\n        return this.idbdb !== null;\n    }\n    hasBeenClosed() {\n        const dbOpenError = this._state.dbOpenError;\n        return dbOpenError && (dbOpenError.name === 'DatabaseClosed');\n    }\n    hasFailed() {\n        return this._state.dbOpenError !== null;\n    }\n    dynamicallyOpened() {\n        return this._state.autoSchema;\n    }\n    get tables() {\n        return keys(this._allTables).map(name => this._allTables[name]);\n    }\n    transaction() {\n        const args = extractTransactionArgs.apply(this, arguments);\n        return this._transaction.apply(this, args);\n    }\n    _transaction(mode, tables, scopeFunc) {\n        let parentTransaction = PSD.trans;\n        if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)\n            parentTransaction = null;\n        const onlyIfCompatible = mode.indexOf('?') !== -1;\n        mode = mode.replace('!', '').replace('?', '');\n        let idbMode, storeNames;\n        try {\n            storeNames = tables.map(table => {\n                var storeName = table instanceof this.Table ? table.name : table;\n                if (typeof storeName !== 'string')\n                    throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n                return storeName;\n            });\n            if (mode == \"r\" || mode === READONLY)\n                idbMode = READONLY;\n            else if (mode == \"rw\" || mode == READWRITE)\n                idbMode = READWRITE;\n            else\n                throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n            if (parentTransaction) {\n                if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n                    if (onlyIfCompatible) {\n                        parentTransaction = null;\n                    }\n                    else\n                        throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n                }\n                if (parentTransaction) {\n                    storeNames.forEach(storeName => {\n                        if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                            if (onlyIfCompatible) {\n                                parentTransaction = null;\n                            }\n                            else\n                                throw new exceptions.SubTransaction(\"Table \" + storeName +\n                                    \" not included in parent transaction.\");\n                        }\n                    });\n                }\n                if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n                    parentTransaction = null;\n                }\n            }\n        }\n        catch (e) {\n            return parentTransaction ?\n                parentTransaction._promise(null, (_, reject) => { reject(e); }) :\n                rejection(e);\n        }\n        const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n        return (parentTransaction ?\n            parentTransaction._promise(idbMode, enterTransaction, \"lock\") :\n            PSD.trans ?\n                usePSD(PSD.transless, () => this._whenReady(enterTransaction)) :\n                this._whenReady(enterTransaction));\n    }\n    table(tableName) {\n        if (!hasOwn(this._allTables, tableName)) {\n            throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);\n        }\n        return this._allTables[tableName];\n    }\n}\n\nconst symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol\n    ? Symbol.observable\n    : \"@@observable\";\nclass Observable {\n    constructor(subscribe) {\n        this._subscribe = subscribe;\n    }\n    subscribe(x, error, complete) {\n        return this._subscribe(!x || typeof x === \"function\" ? { next: x, error, complete } : x);\n    }\n    [symbolObservable]() {\n        return this;\n    }\n}\n\nfunction extendObservabilitySet(target, newSet) {\n    keys(newSet).forEach(part => {\n        const rangeSet = target[part] || (target[part] = new RangeSet());\n        mergeRanges(rangeSet, newSet[part]);\n    });\n    return target;\n}\n\nfunction liveQuery(querier) {\n    return new Observable((observer) => {\n        const scopeFuncIsAsync = isAsyncFunction(querier);\n        function execute(subscr) {\n            if (scopeFuncIsAsync) {\n                incrementExpectedAwaits();\n            }\n            const exec = () => newScope(querier, { subscr, trans: null });\n            const rv = PSD.trans\n                ?\n                    usePSD(PSD.transless, exec)\n                : exec();\n            if (scopeFuncIsAsync) {\n                rv.then(decrementExpectedAwaits, decrementExpectedAwaits);\n            }\n            return rv;\n        }\n        let closed = false;\n        let accumMuts = {};\n        let currentObs = {};\n        const subscription = {\n            get closed() {\n                return closed;\n            },\n            unsubscribe: () => {\n                closed = true;\n                globalEvents.storagemutated.unsubscribe(mutationListener);\n            },\n        };\n        observer.start && observer.start(subscription);\n        let querying = false, startedListening = false;\n        function shouldNotify() {\n            return keys(currentObs).some((key) => accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));\n        }\n        const mutationListener = (parts) => {\n            extendObservabilitySet(accumMuts, parts);\n            if (shouldNotify()) {\n                doQuery();\n            }\n        };\n        const doQuery = () => {\n            if (querying || closed)\n                return;\n            accumMuts = {};\n            const subscr = {};\n            const ret = execute(subscr);\n            if (!startedListening) {\n                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n                startedListening = true;\n            }\n            querying = true;\n            Promise.resolve(ret).then((result) => {\n                querying = false;\n                if (closed)\n                    return;\n                if (shouldNotify()) {\n                    doQuery();\n                }\n                else {\n                    accumMuts = {};\n                    currentObs = subscr;\n                    observer.next && observer.next(result);\n                }\n            }, (err) => {\n                querying = false;\n                observer.error && observer.error(err);\n                subscription.unsubscribe();\n            });\n        };\n        doQuery();\n        return subscription;\n    });\n}\n\nlet domDeps;\ntry {\n    domDeps = {\n        indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n        IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n    };\n}\ncatch (e) {\n    domDeps = { indexedDB: null, IDBKeyRange: null };\n}\n\nconst Dexie = Dexie$1;\nprops(Dexie, {\n    ...fullNameExceptions,\n    delete(databaseName) {\n        const db = new Dexie(databaseName, { addons: [] });\n        return db.delete();\n    },\n    exists(name) {\n        return new Dexie(name, { addons: [] }).open().then(db => {\n            db.close();\n            return true;\n        }).catch('NoSuchDatabaseError', () => false);\n    },\n    getDatabaseNames(cb) {\n        try {\n            return getDatabaseNames(Dexie.dependencies).then(cb);\n        }\n        catch (_a) {\n            return rejection(new exceptions.MissingAPI());\n        }\n    },\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return Class;\n    },\n    ignoreTransaction(scopeFunc) {\n        return PSD.trans ?\n            usePSD(PSD.transless, scopeFunc) :\n            scopeFunc();\n    },\n    vip,\n    async: function (generatorFn) {\n        return function () {\n            try {\n                var rv = awaitIterator(generatorFn.apply(this, arguments));\n                if (!rv || typeof rv.then !== 'function')\n                    return DexiePromise.resolve(rv);\n                return rv;\n            }\n            catch (e) {\n                return rejection(e);\n            }\n        };\n    },\n    spawn: function (generatorFn, args, thiz) {\n        try {\n            var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n            if (!rv || typeof rv.then !== 'function')\n                return DexiePromise.resolve(rv);\n            return rv;\n        }\n        catch (e) {\n            return rejection(e);\n        }\n    },\n    currentTransaction: {\n        get: () => PSD.trans || null\n    },\n    waitFor: function (promiseOrFunction, optionalTimeout) {\n        const promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?\n            Dexie.ignoreTransaction(promiseOrFunction) :\n            promiseOrFunction)\n            .timeout(optionalTimeout || 60000);\n        return PSD.trans ?\n            PSD.trans.waitFor(promise) :\n            promise;\n    },\n    Promise: DexiePromise,\n    debug: {\n        get: () => debug,\n        set: value => {\n            setDebug(value, value === 'dexie' ? () => true : dexieStackFrameFilter);\n        }\n    },\n    derive: derive,\n    extend: extend,\n    props: props,\n    override: override,\n    Events: Events,\n    on: globalEvents,\n    liveQuery,\n    extendObservabilitySet,\n    getByKeyPath: getByKeyPath,\n    setByKeyPath: setByKeyPath,\n    delByKeyPath: delByKeyPath,\n    shallowClone: shallowClone,\n    deepClone: deepClone,\n    getObjectDiff: getObjectDiff,\n    cmp,\n    asap: asap$1,\n    minKey: minKey,\n    addons: [],\n    connections: connections,\n    errnames: errnames,\n    dependencies: domDeps,\n    semVer: DEXIE_VERSION,\n    version: DEXIE_VERSION.split('.')\n        .map(n => parseInt(n))\n        .reduce((p, c, i) => p + (c / Math.pow(10, i * 2))),\n});\nDexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n\nif (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, updatedParts => {\n        if (!propagatingLocally) {\n            let event;\n            if (isIEOrEdge) {\n                event = document.createEvent('CustomEvent');\n                event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);\n            }\n            else {\n                event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n                    detail: updatedParts\n                });\n            }\n            propagatingLocally = true;\n            dispatchEvent(event);\n            propagatingLocally = false;\n        }\n    });\n    addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({ detail }) => {\n        if (!propagatingLocally) {\n            propagateLocally(detail);\n        }\n    });\n}\nfunction propagateLocally(updateParts) {\n    let wasMe = propagatingLocally;\n    try {\n        propagatingLocally = true;\n        globalEvents.storagemutated.fire(updateParts);\n    }\n    finally {\n        propagatingLocally = wasMe;\n    }\n}\nlet propagatingLocally = false;\n\nif (typeof BroadcastChannel !== 'undefined') {\n    const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {\n        if (!propagatingLocally) {\n            bc.postMessage(changedParts);\n        }\n    });\n    bc.onmessage = (ev) => {\n        if (ev.data)\n            propagateLocally(ev.data);\n    };\n}\nelse if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {\n        try {\n            if (!propagatingLocally) {\n                if (typeof localStorage !== 'undefined') {\n                    localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({\n                        trig: Math.random(),\n                        changedParts,\n                    }));\n                }\n                if (typeof self['clients'] === 'object') {\n                    [...self['clients'].matchAll({ includeUncontrolled: true })].forEach((client) => client.postMessage({\n                        type: STORAGE_MUTATED_DOM_EVENT_NAME,\n                        changedParts,\n                    }));\n                }\n            }\n        }\n        catch (_a) { }\n    });\n    addEventListener('storage', (ev) => {\n        if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {\n            const data = JSON.parse(ev.newValue);\n            if (data)\n                propagateLocally(data.changedParts);\n        }\n    });\n    const swContainer = self.document && navigator.serviceWorker;\n    if (swContainer) {\n        swContainer.addEventListener('message', propagateMessageLocally);\n    }\n}\nfunction propagateMessageLocally({ data }) {\n    if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {\n        propagateLocally(data.changedParts);\n    }\n}\n\nDexiePromise.rejectionMapper = mapError;\nsetDebug(debug, dexieStackFrameFilter);\n\nexport { Dexie$1 as Dexie, RangeSet, Dexie$1 as default, liveQuery, mergeRanges, rangesOverlap };\n"]},"metadata":{},"sourceType":"module"}